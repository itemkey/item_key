<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Item Key - onoi_notes</title>

  <!-- глобальный стиль сайта -->
  <link rel="stylesheet" href="../../assets/css/styles.css" />

  <style>
    /* =========================================================
       onoi_notes - single-file notes manager (IndexedDB + optional GitHub Sync)
       ========================================================= */
    .notes-wrap, .notes-wrap *{ box-sizing: border-box; }
    :root{
      --footerH: 56px;
      --topbarOffset: 74px;

      --bgCard: rgba(255,255,255,.86);
      --bd: rgba(0,0,0,.14);
      --bd2: rgba(0,0,0,.26);
      --muted: rgba(0,0,0,.62);

      --fs-ui: 12px;
      --fs-note: 16px;
      --lh-note: 1.7;
      --font-ui: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      --font-note: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
      --accent: rgba(0,0,0,.86);
      --accentSoft: rgba(0,0,0,.06);
      --accentSoft2: rgba(0,0,0,.10);


      --radius: 0px;
    }

    .center-stage{
      padding-top: var(--topbarOffset);
      padding-bottom: calc(var(--footerH) + 20px + env(safe-area-inset-bottom));
      overflow-x: hidden;
    }

    .notes-wrap{
      width: 100%;
      max-width: 1320px;
      margin: 0 auto;
      display: grid;
      gap: 14px;
      padding: 12px 18px 22px;
      min-width: 0;
      font-family: var(--font-ui);
    }

    .n-title{
      padding: 6px 0 0;
      text-align: center;
      display: grid;
      gap: 8px;
    }
    .n-title h1{
      margin: 0;
      font-size: 14px;
      letter-spacing: 6px;
      text-transform: uppercase;
    }
    .n-title .sub{
      font-size: 11px;
      letter-spacing: 3.5px;
      text-transform: uppercase;
      color: rgba(0,0,0,.55);
    }

    .n-shell{
      display: grid;
      grid-template-columns: minmax(240px, var(--sidebarW, 320px)) 10px minmax(0, 1fr);
      gap: 12px;
      align-items: start;
      min-width: 0;
    }


    .n-col-left{
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 0;
    }
    .n-col-right{ min-width: 0; }

    .v-splitter{
      width: 10px;
      align-self: stretch;
      border-radius: 999px;
      cursor: col-resize;
      background: linear-gradient(to bottom, rgba(0,0,0,.10), rgba(0,0,0,.04));
      border: 1px solid rgba(0,0,0,.10);
      opacity: .55;
      user-select: none;
      touch-action: none;
    }
    .v-splitter:hover{ opacity: .85; }
    .v-splitter:active{ opacity: 1; }

    body.is-sidebar-collapsed .n-col-left{ display:none; }
    body.is-sidebar-collapsed .v-splitter{ display:none; }
    body.is-sidebar-collapsed .n-shell{ grid-template-columns: 1fr; }
    .n-card{
      border: 1px solid var(--bd);
      background: var(--bgCard);
      padding: 12px;
      border-radius: var(--radius);
      min-width: 0;
    }
    .n-label{
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
      margin-bottom: 8px;
    }

    /* Top utility bar */
    .n-topbar{
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      gap: 10px;
      align-items: center;
    }
    .n-search{
      width: 100%;
      border: 1px solid var(--bd);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
    }
    .n-btn{
      border: 1px solid var(--bd);
      background: rgba(255,255,255,.90);
      padding: 11px 10px;
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform .18s ease, border-color .18s ease, opacity .18s ease;
      border-radius: 0;
      min-height: 40px;
      line-height: 1.2;
      white-space: nowrap;
    }
    .n-btn:hover{ transform: translateY(-1px); border-color: rgba(0,0,0,.30); opacity: .98; }
    .n-btn:disabled{ opacity: .5; cursor: not-allowed; transform: none; }
    .n-btn:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }

    .n-pill{
      border: 1px solid var(--bd);
      background: rgba(255,255,255,.82);
      padding: 5px 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 10px;
      color: rgba(0,0,0,.62);
      border-radius: 0;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
      min-height: 30px;
    }
    .dot{
      width: 8px; height: 8px;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(0,0,0,.10);
      border-radius: 0;
      display: inline-block;
    }
    .dot.ok{ background: rgba(0,0,0,.18); }
    .dot.warn{ background: rgba(255,170,0,.35); border-color: rgba(255,170,0,.6); }
    .dot.bad{ background: rgba(255,0,0,.25); border-color: rgba(255,0,0,.45); }

    /* Category tree */
    .tree{
      display: grid;
      gap: 6px;
      user-select: none;
    }
    .tree-actions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 10px;
    }
    
.tree-breadcrumb{
  margin: 6px 0 10px;
  padding: 6px 8px;
  font-size: 12px;
  color: rgba(0,0,0,.70);
  border: 1px dashed rgba(0,0,0,.16);
  background: rgba(255,255,255,.55);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tree ul{
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 4px;
    }
    .tree-item{
  display: grid;
  grid-template-columns: 22px 1fr auto;
  gap: 6px;
  align-items: center;
  padding: 8px 10px;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.70);
  cursor: pointer;
  min-width: 0;
  position: relative;
  transition: background .12s ease, border-color .12s ease, transform .06s ease;
  outline: none;
}
.tree-item:hover{
  border-color: rgba(0,0,0,.28);
  background: rgba(255,255,255,.86);
}
.tree-item:active{ transform: translateY(1px); }

/* Visually clear selection + navigation context */
.tree-item.is-active{
  border-color: rgba(0,0,0,.38);
  background: var(--accentSoft);
  box-shadow: inset 4px 0 0 0 var(--accent);
}
.tree-item.is-path:not(.is-active){
  border-color: rgba(0,0,0,.18);
  background: rgba(0,0,0,.03);
  box-shadow: inset 2px 0 0 0 rgba(0,0,0,.30);
}
.tree-item:focus-visible{
  box-shadow: 0 0 0 2px rgba(0,0,0,.30), inset 4px 0 0 0 var(--accent);
  border-color: rgba(0,0,0,.50);
  background: var(--accentSoft2);
}
.tree-tgl{
      width: 22px;
      height: 22px;
      display: grid;
      place-items: center;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.9);
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      padding: 0;
      border-radius: 0;
      appearance: none;
      -webkit-appearance: none;
      font-family: inherit;
      color: inherit;
    }
    .tree-tgl:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }

    .tree-name{
      font-size: 12px;
      letter-spacing: 1px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .tree-count{
      font-size: 10px;
      color: rgba(0,0,0,.55);
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 0 6px;
    }

    /* Make category vs subcategory visually distinct */
    .tree-item[data-depth="0"]{
      background: rgba(255,255,255,.86);
      border-color: rgba(0,0,0,.18);
      border-left: 4px solid rgba(0,0,0,.35);
      padding-left: 10px;
    }
    .tree-item[data-depth="0"] .tree-name{
      font-weight: 750;
      font-size: 13px;
      letter-spacing: 1.2px;
    }
    .tree-item[data-depth="0"] .tree-name::after{
      content: "категория";
      margin-left: 8px;
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      opacity: .38;
    }
.tree-item[data-depth="0"] .tree-name{
  font-weight: 750;
}
.tree-item[data-depth="0"] .tree-name::after{
  padding: 2px 6px;
  border: 1px solid rgba(0,0,0,.18);
  background: rgba(0,0,0,.04);
  border-radius: 999px;
}
.tree-item[data-depth]:not([data-depth="0"]) .tree-name{
  font-weight: 650;
}


    .tree-item[data-depth]:not([data-depth="0"]){
      background: rgba(255,255,255,.62);
      border-style: dashed;
      border-color: rgba(0,0,0,.14);
    }
    .tree-item[data-depth]:not([data-depth="0"]) .tree-name{
      font-weight: 560;
      font-size: 12px;
      letter-spacing: 1px;
      opacity: .92;
    }
    .tree-item[data-depth]:not([data-depth="0"]) .tree-name::before{
      content: "↳ ";
      opacity: .65;
    }


    .indent{ margin-left: 34px; padding-left: 18px; border-left: 2px dashed rgba(0,0,0,.18); }
    .indent > li{ position: relative; }
    .indent > li > .tree-item{ position: relative; }
    .indent > li > .tree-item::before{ content:''; position:absolute; left:-13px; top:50%; width:10px; border-top:1px dashed rgba(0,0,0,.18); }
    .indent .tree-item{ background: rgba(255,255,255,.62); } /* (kept for legacy) */

    /* Notes list */
    .list{
      display: grid;
      gap: 8px;
      min-width: 0;
    }
    .list-head{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      margin-bottom: 4px;
    }
    
    
    .list-actions{
      display: inline-flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: nowrap;
    }
    /* В остальном проекте .n-btn.is-primary растягивается на всю ширину.
       В шапке списка заметок нам нужен нормальный "inline" размер. */
    .list-actions .n-btn.is-primary{ width: auto; }
    @media (max-width: 520px){
      .list-head{ grid-template-columns: 1fr; gap: 8px; }
      .list-actions{ justify-content: flex-start; }
    }
.list-meta{
      font-size: 11px;
      color: rgba(0,0,0,.68);
      line-height: 1.45;
      margin: 0;
    }
    .note-row{
      display: grid;
      gap: 6px;
      padding: 10px 10px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.70);
      cursor: pointer;
      min-width: 0;
    }
    .note-row:hover{ border-color: rgba(0,0,0,.22); }
    .note-row.is-active{
      border-color: rgba(0,0,0,.34);
      background: rgba(255,255,255,.90);
    }
    .note-title{
      margin: 0;
      font-size: 12px;
      letter-spacing: 2px;
      text-transform: uppercase;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .note-snippet{
      margin: 0;
      font-size: 11px;
      line-height: 1.4;
      color: rgba(0,0,0,.72);
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      word-break: break-word;
    }

    /* Editor */
    .editor-head{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
.editor-head-right{
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      min-width: 0;
    }
    .editor-head-right .crumbs{
      flex: 1 1 auto;
      min-width: 0;
    }
    .crumbs{
      font-size: 10px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .toolbar{
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-bottom: 10px;
    }
    .toolbar-row{
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .tool, .toolsel{
      border: 1px solid var(--bd);
      background: rgba(255,255,255,.92);
      height: 38px;
      padding: 0 10px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      letter-spacing: 1px;
    }
    .tool:hover, .toolsel:hover{ border-color: rgba(0,0,0,.30); }
    .tool:focus-visible, .toolsel:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }
    .toolsel{ cursor: default; }
    .tool.is-primary{ font-weight: 700; letter-spacing: 3px; text-transform: uppercase; }
    .swatch{
      width: 14px; height: 14px; border: 1px solid rgba(0,0,0,.22);
      background: #000;
      display: inline-block;
    }

    .editor-title{
      width: 100%;
      border: 1px solid var(--bd);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .editor{
      border: 1px solid var(--bd);
      background: rgba(255,255,255,.92);
      padding: 14px 14px;
      min-height: 420px;
      outline: none;
      border-radius: 0;
      font-size: var(--fs-note);
      line-height: var(--lh-note);
      font-family: var(--font-note);
      word-break: break-word;
    }
    .editor:focus{ border-color: rgba(0,0,0,.34); }

    .editor img{
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.70);
    }
    .editor blockquote{
      margin: 10px 0;
      padding: 10px 12px;
      border-left: 3px solid rgba(0,0,0,.25);
      background: rgba(255,255,255,.70);
    }
    .editor pre{
      background: rgba(0,0,0,.04);
      border: 1px solid rgba(0,0,0,.10);
      padding: 10px 12px;
      overflow: auto;
    }

    .hint{
      margin: 0;
      font-size: 11px;
      line-height: 1.45;
      color: rgba(0,0,0,.72);
    }

    /* Modal */
    .modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.25);
      display: none;
      z-index: 99999;
      padding: 16px;
    }
    .modal.is-open{ display: grid; place-items: center; }
    .modal-card{
      width: min(860px, calc(100% - 8px));
      max-height: calc(100vh - 40px);
      overflow: auto;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.96);
      padding: 14px 14px 12px;
      border-radius: 0;
    }
    .modal-head{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .modal-title{
      margin: 0;
      font-size: 12px;
      letter-spacing: 4px;
      text-transform: uppercase;
    }
    .modal-grid{
      display: grid;
      gap: 12px;
    }
    .grid2{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .field{
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .field label{
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.62);
    }
    .field input, .field select{
      width: 100%;
      border: 1px solid var(--bd);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
    }
    .field input[type="color"]{ padding: 0; height: 40px; }
    .modal-actions{
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 8px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .warnbox{
      border: 1px dashed rgba(0,0,0,.22);
      background: rgba(255,255,255,.78);
      padding: 10px 12px;
      font-size: 11px;
      line-height: 1.45;
      color: rgba(0,0,0,.72);
    }
    code.k{ background: rgba(0,0,0,.06); padding: 1px 4px; }

    /* Responsive */
    @media (max-width: 1060px){
      :root{ --topbarOffset: 66px; }
      .notes-wrap{ padding: 10px 14px 18px; }
      .n-shell{ grid-template-columns: 1fr; }
      .editor{ min-height: 360px; }
      .grid2{ grid-template-columns: 1fr; }
      .modal-actions{ grid-template-columns: 1fr; }
      .tree-actions{ grid-template-columns: 1fr; }
      .n-topbar{ grid-template-columns: 1fr; }
    }
  
    /* =========================================================
       Mobile-first improvements (phone UX)
       - Sidebar becomes off-canvas drawer
       - Larger touch targets + horizontal scrolling toolbar
       - Hide rails on small screens to maximize editor space
       ========================================================= */

    .drawer-overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.35);
      display: none;
      z-index: 9997;
      touch-action: none;
    }
    body.drawer-open .drawer-overlay{ display: block; }

    .drawer-head{
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 8px 10px 10px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.92);
    }
    .drawer-title{
      font-size: 11px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.70);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    @media (max-width: 900px){
      /* maximize content area */
      :root{
        --topbarOffset: 60px;
        --footerH: 58px;
        --fs-ui: 13px;
      }

      /* hide global rails on phones */
      .rail{ display: none !important; }

      .notes-wrap{ padding: 10px 10px 18px; }
      .n-title h1{ letter-spacing: 5px; }
      .n-title .sub{ letter-spacing: 2.5px; }

      /* Keep editor as primary: sidebar becomes a drawer */
      .n-shell{ grid-template-columns: 1fr; }
      .v-splitter{ display: none !important; }

      .n-col-left{
        position: fixed;
        left: 0;
        top: var(--topbarOffset);
        bottom: calc(var(--footerH) + env(safe-area-inset-bottom));
        width: min(420px, 92vw);
        max-width: 92vw;
        overflow: auto;
        z-index: 9998;
        transform: translateX(-110%);
        transition: transform .18s ease;
        box-shadow: 10px 0 40px rgba(0,0,0,.18);
        background: transparent; /* cards inside have their own bg */
        padding: 10px;
      }
      body.drawer-open .n-col-left{ transform: translateX(0); }

      .drawer-head{ display: flex; position: sticky; top: 0; z-index: 1; }

      /* Make the topbar wrap nicely on small screens */
      .n-topbar{
        grid-template-columns: 1fr auto;
        gap: 8px;
      }
.n-pill{ grid-column: 1 / -1; justify-content: flex-start; }

      /* Buttons and fields: better touch targets */
      .n-btn{ min-height: 44px; padding: 12px 12px; letter-spacing: 2px; }
      .n-search{ height: 44px; font-size: 13px; }
      .editor-title{ height: 44px; font-size: 12px; }

      /* Toolbar: single-row horizontal scrolling */
      .toolbar-row{
        flex-wrap: nowrap;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
        padding-bottom: 4px;
      }
      .toolbar-row::-webkit-scrollbar{ height: 8px; }
      .tool, .toolsel{
        flex: 0 0 auto;
        height: 42px;
        font-size: 13px;
      }
      .tool.is-primary{ letter-spacing: 3px; }

      /* Editor: comfortable height on phones */
      .editor{
        min-height: 55vh;
        padding: 14px 12px;
      }

      /* Modal: full height comfort */
      .modal{ padding: 10px; }
      .modal-card{ width: 100%; max-height: calc(100vh - 20px); }
    }

    @media (max-width: 520px){
      .n-title h1{ letter-spacing: 4px; }
      .n-title .sub{ font-size: 10px; }
      .editor-head{
        grid-template-columns: 1fr;
        gap: 8px;
      }
      .editor-head-right{
        justify-content: space-between;
      }
      .crumbs{ max-width: 62vw; }
      .n-btn.is-primary{ width: 100%; }
    }

    @media (prefers-reduced-motion: reduce){
      .n-btn, .n-col-left{ transition: none !important; }
    }


    /* =========================================================
       UX polish (no-tooltips, clearer structure) - 2026-01
       - No rounded corners preserved
       - Stronger contrast + clearer selected states
       ========================================================= */

    :root{
      --bgCard: rgba(255,255,255,.90);
      --bd: rgba(0,0,0,.18);
      --bd2: rgba(0,0,0,.34);
      --muted: rgba(0,0,0,.66);
      --fs-ui: 13px;
      --fs-note: 17px;
      --lh-note: 1.75;
    }

    /* Desktop: keep sidebar usable (sticky + scroll) */
    @media (min-width: 901px){
      .n-col-left{
        position: sticky;
        top: calc(var(--topbarOffset) + 12px);
        max-height: calc(100vh - var(--topbarOffset) - var(--footerH) - 26px);
        overflow: auto;
        padding-right: 6px;
        scrollbar-width: thin;
      }
      .n-col-left::-webkit-scrollbar{ width: 10px; }
      .n-col-left::-webkit-scrollbar-thumb{ background: rgba(0,0,0,.15); border: 2px solid transparent; background-clip: content-box; }
    }

    /* Clearer button affordance (still sharp + gothic) */
    .n-btn{
      border-color: rgba(0,0,0,.22);
      background: rgba(255,255,255,.94);
    }
    .n-btn:hover{
      background: rgba(255,255,255,.98);
      border-color: rgba(0,0,0,.40);
    }
    .n-btn.is-primary{
      border-color: rgba(0,0,0,.50);
      background: rgba(0,0,0,.03);
    }

    /* Inputs: stronger focus ring */
    .n-search:focus-visible,
    .editor-title:focus-visible,
    .field input:focus-visible,
    .field select:focus-visible,
    .editor:focus-visible{
      outline: 2px solid rgba(0,0,0,.55);
      outline-offset: 2px;
      border-color: rgba(0,0,0,.45);
    }

    /* Notes rows: more readable */
    .note-row{
      padding: 11px 10px;
      border-color: rgba(0,0,0,.14);
    }
    .note-row:hover{ border-color: rgba(0,0,0,.30); }
    .note-row.is-active{
      border-color: rgba(0,0,0,.42);
      box-shadow: inset 4px 0 0 0 rgba(0,0,0,.86);
    }
    .note-snippet{ color: rgba(0,0,0,.76); }

    /* Editor: comfortable reading area */
    .editor{
      padding: 16px 16px;
      background: rgba(255,255,255,.94);
      border-color: rgba(0,0,0,.18);
    }

    /* Reduce visual noise: keep labels, hide "hint" class if any remain */
    p.hint{ display: none !important; }

/* =========================================================
   UX additions: toast + empty states + dialogs (sharp gothic)
   ========================================================= */
.toast-wrap{
  position: fixed;
  right: 14px;
  bottom: calc(var(--footerH) + 14px + env(safe-area-inset-bottom));
  display: grid;
  gap: 10px;
  z-index: 100000;
  pointer-events: none;
}
.toast{
  pointer-events: auto;
  border: 1px solid rgba(0,0,0,.22);
  background: rgba(255,255,255,.96);
  padding: 10px 12px;
  border-radius: 0;
  min-width: min(420px, calc(100vw - 28px));
  max-width: min(520px, calc(100vw - 28px));
  box-shadow: 0 12px 30px rgba(0,0,0,.18);
  display: grid;
  gap: 6px;
}
.toast-title{
  font-size: 11px;
  letter-spacing: 4px;
  text-transform: uppercase;
  margin: 0;
}
.toast-body{
  margin: 0;
  font-size: 12px;
  color: rgba(0,0,0,.72);
  line-height: 1.5;
}
.toast-actions{
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  flex-wrap: wrap;
}

.empty{
  border: 1px dashed rgba(0,0,0,.22);
  background: rgba(255,255,255,.70);
  padding: 12px;
  border-radius: 0;
  display: grid;
  gap: 10px;
}
.empty h3{
  margin: 0;
  font-size: 12px;
  letter-spacing: 3px;
  text-transform: uppercase;
}
.empty p{
  margin: 0;
  font-size: 12px;
  color: rgba(0,0,0,.72);
  line-height: 1.5;
}

/* Dialog modal - reuse modal shell */
.dialog-msg{
  font-size: 12px;
  color: rgba(0,0,0,.74);
  line-height: 1.55;
  margin: 0;
  white-space: pre-wrap;
}
.dialog-input{
  width: 100%;
  border: 1px solid var(--bd);
  background: rgba(255,255,255,.92);
  padding: 10px 12px;
  font-size: 12px;
  outline: none;
  border-radius: 0;
  height: 40px;
  min-width: 0;
}
.dialog-input:focus-visible{
  outline: 2px solid rgba(0,0,0,.55);
  outline-offset: 2px;
  border-color: rgba(0,0,0,.45);
}

</style>
</head>

<body class="page page-crate">
  <!-- фон/рамки - как в item-key -->
  <div class="outer-frame" aria-hidden="true"></div>
  <div class="rays" aria-hidden="true"></div>
  <div class="veil" aria-hidden="true"></div>

  <!-- верхний “герб” -->
  <header class="topbar topbar--edge">
    <a class="toplink" href="../../item-user.html?returnTo=crate/onoi_notes/onoi_notes.html" aria-label="Item User">
      <span class="tag">item-user</span>
    </a>
  </header>

  <!-- левый rail -->
  <aside class="rail rail--left" aria-label="Левое меню">
    <a class="rail-link" href="../../index.html">
      <span class="rail-link__title">item-key</span>
      <span class="rail-link__meta">главное меню</span>
    </a>
    <a class="rail-link" href="../../item-crate.html">
      <span class="rail-link__title">item-crate</span>
      <span class="rail-link__meta">назад в хаб</span>
    </a>
  </aside>

  <!-- правый rail -->
  <aside class="rail rail--right" aria-label="Правое меню">
    <a class="rail-link" href="../../item-soft.html">
      <span class="rail-link__title">item-soft</span>
      <span class="rail-link__meta">инструменты / редакторы</span>
    </a>
    <a class="rail-link" href="../../item-security.html">
      <span class="rail-link__title">item-security</span>
      <span class="rail-link__meta">доступ / защита</span>
    </a>
  </aside>

  <main class="center-stage" aria-label="onoi_notes center">
    <section class="notes-wrap" aria-label="onoi_notes app">
      <div class="n-title">
        <h1>onoi_notes</h1>
        <div class="sub">категории · подкатегории · редактор · whisperer</div>
      </div>

      <div class="n-card">
        <div class="n-topbar" aria-label="Панель поиска и действий">
          <input class="n-search" id="searchInput" placeholder="Поиск по заметкам…" />
                    <button class="n-btn" id="openDrawerBtn" type="button">Меню</button>
<div class="n-pill" aria-label="Статус синхронизации">
            <span class="dot" id="syncDot"></span>
            <span id="syncText">local</span>
          </div>
        </div>
<div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px">
<button class="n-btn" id="settingsBtn" type="button">Настройки</button>
          <button class="n-btn" id="exportBtn" type="button">Экспорт JSON</button>
          <button class="n-btn" id="importBtn" type="button">Импорт JSON</button>
          <input id="importFile" type="file" accept="application/json" hidden />
</div>
      </div>

            <div class="drawer-overlay" id="drawerOverlay" aria-hidden="true"></div>

      <div class="n-shell" aria-label="Основной интерфейс">
        <!-- Categories -->
        <div class="n-col-left" id="sidebarCol" aria-label="Боковая панель">
<div class="drawer-head" aria-label="Мобильное меню">
  <div class="drawer-title">Меню</div>
  <button class="n-btn" id="closeDrawerBtn" type="button">Закрыть</button>
</div>
<div class="n-card" aria-label="Категории">
          <div class="n-label">categories</div>

          <div class="tree-actions">
            <button class="n-btn" id="addCatBtn" type="button">+ Категория</button>
            <button class="n-btn" id="addSubCatBtn" type="button">+ Подкатегория</button>
          </div>

          <div class="tree-breadcrumb" id="catBreadcrumb" aria-label="Текущая категория">Не выбрано</div>

          <div class="tree" id="catTree" aria-label="Дерево категорий"></div>

          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px">
            <button class="n-btn" id="renameCatBtn" type="button">Переименовать</button>
            <button class="n-btn" id="deleteCatBtn" type="button">Удалить</button>
          </div>
</div>

        <!-- Notes list -->
<div class="n-card" aria-label="Список заметок">
          <div class="n-label">notes</div>

          <div class="list-head">
            <p class="list-meta" id="listMeta">-</p>
            <div class="list-actions" aria-label="Действия с заметками">
              <button class="n-btn is-primary" id="newNoteBtn" type="button">Новая заметка</button>
              <button class="n-btn" id="deleteNoteBtn" type="button">Удалить</button>
            </div>
          </div>

          <div class="list" id="notesList" aria-label="Список заметок"></div>
</div>

        <!-- Editor -->
        </div>

        <div class="v-splitter" id="splitter" role="separator" aria-label="Изменение ширины боковой панели" tabindex="0"></div>

        <div class="n-col-right" aria-label="Редактор">
<div class="n-card" aria-label="Редактор заметки">
          <div class="n-label">editor</div>

          <div class="editor-head">
            <input class="editor-title" id="noteTitle" placeholder="Название заметки…" />
            <div class="editor-head-right">
              <div class="crumbs" id="crumbs">-</div>
              <button class="n-btn is-primary" id="whisperBtn" type="button">Прошептать</button>
            </div>
          </div>

          <div class="toolbar" aria-label="Панель форматирования">
            <div class="toolbar-row">
              <button class="tool" type="button" data-cmd="bold"><b>B</b></button>
              <button class="tool" type="button" data-cmd="italic"><i>I</i></button>
              <button class="tool" type="button" data-cmd="underline"><u>U</u></button>
              <button class="tool" type="button" data-cmd="strikeThrough"><s>S</s></button>

              <button class="tool" type="button" data-cmd="insertUnorderedList">• list</button>
              <button class="tool" type="button" data-cmd="insertOrderedList">1. list</button>
              <button class="tool" type="button" data-cmd="formatBlock" data-arg="blockquote">quote</button>
              <button class="tool" type="button" data-cmd="formatBlock" data-arg="pre">code</button>

              <button class="tool" type="button" id="linkBtn">link</button>
              <button class="tool" type="button" id="imgBtn">image</button>
              <input id="imgFile" type="file" accept="image/*" hidden />
            </div>

            <div class="toolbar-row">
              <button class="tool" type="button" data-cmd="undo">undo</button>
              <button class="tool" type="button" data-cmd="redo">redo</button>
              <button class="tool" type="button" id="clearFmtBtn">clear</button>

              <select class="toolsel" id="blockSelect" aria-label="Стиль блока">
                <option value="p" selected>P</option>
                <option value="h1">H1</option>
                <option value="h2">H2</option>
                <option value="h3">H3</option>
                <option value="h4">H4</option>
                <option value="blockquote">quote</option>
                <option value="pre">code</option>
              </select>

              <button class="tool" type="button" id="customSizeBtn">size…</button>
              <select class="toolsel" id="fontSelect">
                <option value="ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, \"Noto Sans\", sans-serif">Default</option>
                <option value="\"Times New Roman\", Times, serif">Serif</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="\"Courier New\", Courier, monospace">Mono</option>
                <option value="\"Trebuchet MS\", Trebuchet, sans-serif">Trebuchet</option>
                <option value="\"Comic Sans MS\", \"Comic Sans\", cursive">Comic</option>
              </select>

              <select class="toolsel" id="sizeSelect">
                <option value="14">14px</option>
                <option value="16" selected>16px</option>
                <option value="18">18px</option>
                <option value="20">20px</option>
                <option value="24">24px</option>
                <option value="28">28px</option>
                <option value="32">32px</option>
              </select>

              <label class="toolsel" style="gap:10px">
                <span class="swatch" id="colorSwatch"></span>
                <input id="colorPick" type="color" value="#000000" aria-label="Цвет текста" />
              </label>

              <label class="toolsel" style="gap:10px">
                <span class="swatch" id="hlSwatch" style="background:#fff59d"></span>
                <input id="hlPick" type="color" value="#fff59d" aria-label="Подсветка" />
              </label>

              <button class="tool" type="button" data-cmd="justifyLeft">left</button>
              <button class="tool" type="button" data-cmd="justifyCenter">center</button>
              <button class="tool" type="button" data-cmd="justifyRight">right</button>

              <button class="tool" type="button" id="toggleSidebarBtn">sidebar</button>
              <button class="tool is-primary" type="button" id="focusBtn">focus</button>
            </div>
          </div>

          <div class="editor" id="editor" contenteditable="true" spellcheck="true" aria-label="Текст заметки"></div>

          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px">
            <div class="n-pill" aria-label="Автосохранение">
              <span class="dot ok" id="saveDot"></span>
              <span id="saveText">saved</span>
            </div>
            <div class="n-pill">
              <span id="updatedText">-</span>
            </div>
          </div>
</div>
        </div>
      </div>
    </section>
  </main>

  <footer class="bottombar bottombar--edge">
    <span class="hint">onoi_notes</span>
    <span class="sep">•</span>
    <span class="hint">autosave · categories · whisperer</span>
  </footer>

<!-- UI modal (prompt/confirm/alert replacement) -->
<div class="modal" id="uiModal" role="dialog" aria-modal="true" aria-label="Диалог" style="z-index: 100000;">
  <div class="modal-card">
    <div class="modal-head">
      <h2 class="modal-title" id="uiModalTitle">dialog</h2>
      <button class="n-btn" id="uiModalClose" type="button">Закрыть</button>
    </div>
    <div class="modal-grid">
      <p class="dialog-msg" id="uiModalMsg"></p>
      <div class="field" id="uiModalField" style="display:none">
        <label id="uiModalLabel">value</label>
        <input class="dialog-input mono" id="uiModalInput" autocomplete="off" />
      </div>
      <div class="modal-actions" id="uiModalActions" style="grid-template-columns: 1fr 1fr 1fr;">
        <button class="n-btn" id="uiModalCancel" type="button">Отмена</button>
        <button class="n-btn" id="uiModalOk" type="button">Ок</button>
        <button class="n-btn" id="uiModalAlt" type="button" style="display:none">-</button>
      </div>
    </div>
  </div>
</div>

<!-- Toasts -->
<div class="toast-wrap" id="toastWrap" aria-live="polite" aria-atomic="true"></div>

  <!-- Settings modal -->
  <div class="modal" id="settingsModal" role="dialog" aria-modal="true" aria-label="Настройки">
    <div class="modal-card">
      <div class="modal-head">
        <h2 class="modal-title">settings</h2>
        <button class="n-btn" id="closeSettings" type="button">Закрыть</button>
      </div>

      <div class="modal-grid">
<div class="grid2">
          <div class="field">
            <label>cloud mode</label>
            <select id="cloudMode">
              <option value="off" selected>Off (local only)</option>
              <option value="repo">GitHub Repo file (Contents API)</option>
              <option value="gist">GitHub Gist (single file)</option>
            </select>
          </div>
          <div class="field">
            <label>poll</label>
            <select id="pollEvery">
              <option value="0">No polling</option>
              <option value="15">15s</option>
              <option value="30" selected>30s</option>
              <option value="60">60s</option>
            </select>
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <label>token (PAT)</label>
            <input id="ghToken" class="mono" placeholder="github_pat_..." autocomplete="off" />
          </div>
          <div class="field">
            <label>owner / user</label>
            <input id="ghOwner" class="mono" placeholder="your-username" />
          </div>
        </div>

        <div class="grid2" id="repoFields">
          <div class="field">
            <label>repo</label>
            <input id="ghRepo" class="mono" placeholder="item-key" />
          </div>
          <div class="field">
            <label>branch</label>
            <input id="ghBranch" class="mono" placeholder="main" value="main" />
          </div>
          <div class="field" style="grid-column: 1 / -1;">
            <label>path (json file)</label>
            <input id="ghPath" class="mono" placeholder="crate/onoi_notes/db.json" value="crate/onoi_notes/db.json" />
          </div>
        </div>

        <div class="grid2" id="gistFields" style="display:none">
          <div class="field">
            <label>gist id</label>
            <input id="ghGistId" class="mono" placeholder="xxxxxxxxxxxxxxxxxxxx" />
          </div>
          <div class="field">
            <label>filename</label>
            <input id="ghGistFile" class="mono" placeholder="onoi_notes_db.json" value="onoi_notes_db.json" />
          </div>
        </div>

        <div class="modal-actions">
          <button class="n-btn" id="testCloud" type="button">Проверить</button>
          <button class="n-btn" id="pullCloud" type="button">Pull</button>
          <button class="n-btn" id="pushCloud" type="button">Push</button>
        </div>
</div>
    </div>
  </div>

  <script src="../../assets/js/main.js"></script>

  <script>
  (function(){
    // ========= utils =========
    const $ = (id) => document.getElementById(id);
    const now = () => Date.now();
    const uid = () => (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('id-' + Math.random().toString(16).slice(2) + '-' + Date.now());
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    function htmlToText(html){
      const d = document.createElement('div');
      d.innerHTML = html || '';
      const t = (d.textContent || '').replace(/\s+/g,' ').trim();
      return t;
    }
    function firstLine(html){
      const t = htmlToText(html);
      if(!t) return '';
      return t.split(/\n|\r/)[0].slice(0, 90);
    }
    function fmtTime(ts){
      if(!ts) return '-';
      const d = new Date(ts);
      const z = (n) => String(n).padStart(2,'0');
      return z(d.getDate())+'.'+z(d.getMonth()+1)+'.'+d.getFullYear()+' '+z(d.getHours())+':'+z(d.getMinutes());
    }


    // ========= UI state (sidebar + tree collapse) =========
    const LS_UI = {
      sidebarW: 'onoi_notes_sidebar_w_v1',
      sidebarCollapsed: 'onoi_notes_sidebar_collapsed_v1',
      catCollapsed: 'onoi_notes_cat_collapsed_v1'
    };

    function lsGet(key){
      try{ return localStorage.getItem(key); }catch(e){ return null; }
    }
    function lsSet(key, val){
      try{ localStorage.setItem(key, val); }catch(e){}
    }
    function loadCollapsedCats(){
      try{
        const raw = lsGet(LS_UI.catCollapsed);
        const arr = raw ? JSON.parse(raw) : [];
        return new Set(Array.isArray(arr) ? arr.map(String) : []);
      }catch(e){
        return new Set();
      }
    }
    function saveCollapsedCats(set){
      try{ lsSet(LS_UI.catCollapsed, JSON.stringify(Array.from(set || []))); }catch(e){}
    }

    function applySidebarUI(){
      const collapsed = !!state.ui.sidebarCollapsed;
      document.body.classList.toggle('is-sidebar-collapsed', collapsed);
      if(!collapsed){
        document.documentElement.style.setProperty('--sidebarW', state.ui.sidebarW + 'px');
      }
    }
    // ========= IndexedDB =========
    const DB_NAME = 'itemkey_onoi_notes_db_v1';
    const DB_VER = 1;
    const STORE = { meta:'meta', cats:'cats', notes:'notes' };

    function idbOpen(){
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(STORE.meta)) db.createObjectStore(STORE.meta, { keyPath: 'key' });
          if(!db.objectStoreNames.contains(STORE.cats)) db.createObjectStore(STORE.cats, { keyPath: 'id' });
          if(!db.objectStoreNames.contains(STORE.notes)) db.createObjectStore(STORE.notes, { keyPath: 'id' });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    async function idbTx(mode, stores, fn){
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(stores, mode);
        const st = {};
        stores.forEach(s => st[s] = tx.objectStore(s));
        const res = fn(st);
        tx.oncomplete = () => { db.close(); resolve(res); };
        tx.onerror = () => { db.close(); reject(tx.error); };
        tx.onabort = () => { db.close(); reject(tx.error); };
      });
    }
    const idb = {
      get: (store, key) => idbTx('readonly',[store], st => new Promise((res, rej)=>{ const r=st[store].get(key); r.onsuccess=()=>res(r.result||null); r.onerror=()=>rej(r.error); })),
      put: (store, val) => idbTx('readwrite',[store], st => new Promise((res, rej)=>{ const r=st[store].put(val); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); })),
      del: (store, key) => idbTx('readwrite',[store], st => new Promise((res, rej)=>{ const r=st[store].delete(key); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); })),
      all: (store) => idbTx('readonly',[store], st => new Promise((res, rej)=>{ const r=st[store].getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error); })),
      clear: (store) => idbTx('readwrite',[store], st => new Promise((res, rej)=>{ const r=st[store].clear(); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error); })),
    };

    // ========= state =========
    const state = {
      cats: [],
      notes: [],
      activeCatId: null,
      activeNoteId: null,
      search: '',
      dirty: false,
      ui: { sidebarW: 320, sidebarCollapsed: false, collapsedCats: new Set() },
      saving: false,
      saveTimer: null,
      lastSavedAt: 0,

      cloud: {
        mode: 'off', // off | repo | gist
        token: '',
        owner: '',
        repo: '',
        branch: 'main',
        path: 'crate/onoi_notes/db.json',
        gistId: '',
        gistFile: 'onoi_notes_db.json',
        pollEvery: 30,
        pollTimer: null,
        lastPullAt: 0,
        lastPushAt: 0,
        lastSha: null, // for repo
        lastGistETag: null
      }
    };

    const LS_KEY = 'onoi_notes_cloud_settings_v1';

    function loadCloudSettings(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return;
        const v = JSON.parse(raw);
        if(v && typeof v === 'object'){
          Object.assign(state.cloud, v);
        }
      }catch(e){}
    }
    function saveCloudSettings(){
      try{
        localStorage.setItem(LS_KEY, JSON.stringify(state.cloud));
      }catch(e){}
    }

    // ========= UI refs =========
    const searchInput = $('searchInput');
    const newNoteBtn = $('newNoteBtn');
    const settingsBtn = $('settingsBtn');
    const exportBtn = $('exportBtn');
    const importBtn = $('importBtn');
    const importFile = $('importFile');
    const whisperBtn = $('whisperBtn');

    const syncDot = $('syncDot');
    const syncText = $('syncText');

    const addCatBtn = $('addCatBtn');
    const addSubCatBtn = $('addSubCatBtn');
    const renameCatBtn = $('renameCatBtn');
    const deleteCatBtn = $('deleteCatBtn');
    const catTree = $('catTree');
    const catBreadcrumb = $('catBreadcrumb');

    const notesList = $('notesList');
    const listMeta = $('listMeta');
    const deleteNoteBtn = $('deleteNoteBtn');

    const noteTitle = $('noteTitle');
    const editor = $('editor');
    const crumbs = $('crumbs');

    const saveDot = $('saveDot');
    const saveText = $('saveText');
    const updatedText = $('updatedText');

    const fontSelect = $('fontSelect');
    const sizeSelect = $('sizeSelect');
    const colorPick = $('colorPick');
    const hlPick = $('hlPick');
    const colorSwatch = $('colorSwatch');
    const hlSwatch = $('hlSwatch');
    const toggleSidebarBtn = $('toggleSidebarBtn');
    const splitter = $('splitter');
    const sidebarCol = $('sidebarCol');

    const focusBtn = $('focusBtn');

    const clearFmtBtn = $('clearFmtBtn');
    const blockSelect = $('blockSelect');
    const customSizeBtn = $('customSizeBtn');
    const linkBtn = $('linkBtn');
    const imgBtn = $('imgBtn');
    const imgFile = $('imgFile');

    const settingsModal = $('settingsModal');
    const closeSettings = $('closeSettings');
    const cloudMode = $('cloudMode');
    const pollEvery = $('pollEvery');
    const ghToken = $('ghToken');
    const ghOwner = $('ghOwner');
    const ghRepo = $('ghRepo');
    const ghBranch = $('ghBranch');
    const ghPath = $('ghPath');
    const ghGistId = $('ghGistId');
    const ghGistFile = $('ghGistFile');
    const repoFields = $('repoFields');
    const gistFields = $('gistFields');
    const testCloud = $('testCloud');
    const pullCloud = $('pullCloud');
    const pushCloud = $('pushCloud');

    function setSync(status, kind){
      // status: 'local'|'syncing'|'ok'|'warn'|'bad'
      syncText.textContent = kind || 'local';
      syncDot.className = 'dot';
      if(status === 'ok') syncDot.classList.add('ok');
      if(status === 'warn') syncDot.classList.add('warn');
      if(status === 'bad') syncDot.classList.add('bad');
    }
    function setSaveStatus(mode){
      // 'saved'|'saving'|'dirty'
      if(mode === 'saving'){
        saveDot.className = 'dot warn';
        saveText.textContent = 'saving…';
      } else if(mode === 'dirty'){
        saveDot.className = 'dot warn';
        saveText.textContent = 'editing…';
      } else {
        saveDot.className = 'dot ok';
        saveText.textContent = 'saved';
      }
    }


// ========= dialog + toast (replaces alert/prompt/confirm) =========
const uiModal = $('uiModal');
const uiModalTitle = $('uiModalTitle');
const uiModalMsg = $('uiModalMsg');
const uiModalField = $('uiModalField');
const uiModalLabel = $('uiModalLabel');
const uiModalInput = $('uiModalInput');
const uiModalClose = $('uiModalClose');
const uiModalCancel = $('uiModalCancel');
const uiModalOk = $('uiModalOk');
const uiModalAlt = $('uiModalAlt');

const toastWrap = $('toastWrap');

function toast(title, body, opts={}){
  try{
    const t = document.createElement('div');
    t.className = 'toast';
    const h = document.createElement('p');
    h.className = 'toast-title';
    h.textContent = String(title || 'info');
    const b = document.createElement('p');
    b.className = 'toast-body';
    b.textContent = String(body || '');
    t.appendChild(h);
    t.appendChild(b);

    if(opts.actionText && typeof opts.onAction === 'function'){
      const a = document.createElement('div');
      a.className = 'toast-actions';
      const btn = document.createElement('button');
      btn.className = 'n-btn';
      btn.type = 'button';
      btn.textContent = String(opts.actionText);
      btn.addEventListener('click', () => { try{ opts.onAction(); }catch(e){}; t.remove(); });
      a.appendChild(btn);
      t.appendChild(a);
    }

    toastWrap.appendChild(t);
    const ttl = Number(opts.ttl || 3200);
    window.setTimeout(() => { try{ t.remove(); }catch(e){} }, ttl);
  }catch(e){}
}

let uiModalResolve = null;
let uiModalMode = 'alert'; // alert|confirm|prompt
let uiModalLastFocus = null;

function openUIModal({title='dialog', message='', mode='alert', label='value', value='', placeholder=''} = {}){
  return new Promise((resolve) => {
    uiModalResolve = resolve;
    uiModalMode = mode;
    uiModalLastFocus = document.activeElement;

    uiModalTitle.textContent = String(title);
    uiModalMsg.textContent = String(message || '');

    const isPrompt = mode === 'prompt';
    uiModalField.style.display = isPrompt ? 'grid' : 'none';
    uiModalLabel.textContent = String(label || 'value');
    uiModalInput.value = String(value || '');
    uiModalInput.placeholder = String(placeholder || '');

    uiModalCancel.style.display = (mode === 'alert') ? 'none' : 'inline-flex';
    uiModalOk.textContent = (mode === 'prompt') ? 'Сохранить' : 'Ок';

    uiModal.classList.add('is-open');
    document.body.classList.add('modal-open');
    window.setTimeout(() => {
      if(isPrompt) uiModalInput.focus();
      else uiModalOk.focus();
    }, 0);
  });
}

function closeUIModal(result){
  if(!uiModal.classList.contains('is-open')) return;
  uiModal.classList.remove('is-open');
  document.body.classList.remove('modal-open');
  const r = uiModalResolve;
  uiModalResolve = null;
  try{
    if(uiModalLastFocus && uiModalLastFocus.focus) uiModalLastFocus.focus();
  }catch(e){}
  if(r) r(result);
}

uiModalClose.addEventListener('click', () => closeUIModal(uiModalMode === 'alert' ? true : null));
uiModalCancel.addEventListener('click', () => closeUIModal(null));
uiModalOk.addEventListener('click', () => {
  if(uiModalMode === 'prompt') closeUIModal(String(uiModalInput.value || '').trim());
  else closeUIModal(true);
});
uiModal.addEventListener('click', (e) => {
  if(e.target === uiModal) closeUIModal(uiModalMode === 'alert' ? true : null);
});
window.addEventListener('keydown', (e) => {
  if(!uiModal.classList.contains('is-open')) return;
  if(e.key === 'Escape'){
    e.preventDefault();
    closeUIModal(uiModalMode === 'alert' ? true : null);
  }
  if(uiModalMode === 'prompt' && e.key === 'Enter' && (document.activeElement === uiModalInput)){
    e.preventDefault();
    closeUIModal(String(uiModalInput.value || '').trim());
  }
});

async function uiAlert(msg, title='info'){
  await openUIModal({title, message: msg, mode:'alert'});
  return true;
}
async function uiConfirm(msg, title='confirm'){
  const r = await openUIModal({title, message: msg, mode:'confirm'});
  return !!r;
}
async function uiPrompt(msg, opts={}){
  const r = await openUIModal({
    title: opts.title || 'input',
    message: msg,
    mode:'prompt',
    label: opts.label || 'value',
    value: opts.value || '',
    placeholder: opts.placeholder || ''
  });
  if(r === null) return null;
  const v = String(r || '').trim();
  return v ? v : null;
}


    // ========= data helpers =========
    
    function getOrCreateMainCat(){
      let c = state.cats.find(x => x.name === 'main');
      if(!c){
        c = { id: uid(), parentId: null, name: 'main', createdAt: now(), updatedAt: now() };
        state.cats.push(c);
      }
      state.activeCatId = c.id;
      return c;
    }

    function ensureDefaults(){
      // Ensure there is always a default root category: "main"
      const ensureMain = () => {
        let main = state.cats.find(c => (c.parentId === null || c.parentId === undefined) && String(c.name||'').trim().toLowerCase() === 'main');
        if(!main){
          main = { id: uid(), parentId: null, name: 'main', createdAt: now(), updatedAt: now() };
          state.cats.push(main);
        }
        return main.id;
      };

      // If db is empty - create "main"
      if(state.cats.length === 0){
        state.activeCatId = ensureMain();
      }else{
        // If active cat is missing - point to "main" (create if needed)
        if(!state.activeCatId || !catById(state.activeCatId)){
          state.activeCatId = ensureMain();
        }
      }

      // If there are no notes yet - start with an empty sheet (no welcome text)
      if(state.notes.length === 0){
        const n = {
          id: uid(),
          catId: state.activeCatId || ensureMain(),
          title: '',
          html: '',
          createdAt: now(),
          updatedAt: now()
        };
        state.notes.push(n);
        state.activeNoteId = n.id;
      }


      if(!state.activeNoteId){
        const nn = state.notes.find(x => x.catId === state.activeCatId) || state.notes[0];
        state.activeNoteId = nn ? nn.id : null;
      }
    }

    function getOrCreateMainCatId(){
      // Find root "main" (case-insensitive). Create if missing.
      let main = state.cats.find(c => (c.parentId === null || c.parentId === undefined) && String(c.name||'').trim().toLowerCase() === 'main');
      if(!main){
        main = { id: uid(), parentId: null, name: 'main', createdAt: now(), updatedAt: now() };
        state.cats.push(main);
      }
      return main.id;
    }

    function catById(id){ return state.cats.find(c => c.id === id) || null; }
    function noteById(id){ return state.notes.find(n => n.id === id) || null; }

    function catPath(catId){
      const path = [];
      let cur = catById(catId);
      let guard = 0;
      while(cur && guard++ < 30){
        path.unshift(cur.name);
        cur = cur.parentId ? catById(cur.parentId) : null;
      }
      return path.length ? path.join(' / ') : '-';
    }

    function noteMatchesSearch(note){
      if(!state.search) return true;
      const s = state.search.toLowerCase();
      const t = (note.title || '').toLowerCase();
      const body = htmlToText(note.html).toLowerCase();
      return t.includes(s) || body.includes(s);
    }

    function countNotesInCat(catId, includeChildren=true){
      let ids = new Set([catId]);
      if(includeChildren){
        let changed = true;
        while(changed){
          changed = false;
          for(const c of state.cats){
            if(c.parentId && ids.has(c.parentId) && !ids.has(c.id)){
              ids.add(c.id); changed = true;
            }
          }
        }
      }
      return state.notes.filter(n => ids.has(n.catId)).length;
    }

    // ========= render =========
    function renderTree(){
      const rootCats = state.cats.filter(c => !c.parentId);
      const byParent = new Map();
      for(const c of state.cats){
        const k = c.parentId || '__root__';
        if(!byParent.has(k)) byParent.set(k, []);
        byParent.get(k).push(c);
      }
      for(const [k, arr] of byParent.entries()){
        arr.sort((a,b) => (a.name||'').localeCompare(b.name||''));
      }

      catTree.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'tree';

      function getCatPathIds(activeId){
        const out = [];
        const byId = new Map(state.cats.map(c => [String(c.id), c]));
        let cur = activeId ? byId.get(String(activeId)) : null;
        while(cur){
          out.push(String(cur.id));
          cur = cur.parentId ? byId.get(String(cur.parentId)) : null;
        }
        return out.reverse();
      }

      const pathArr = getCatPathIds(state.activeCatId);
      const pathIds = new Set(pathArr);
      if(catBreadcrumb){
        if(!pathArr.length) catBreadcrumb.textContent = 'Не выбрано';
        else {
          const byId = new Map(state.cats.map(c => [String(c.id), c]));
          const names = pathArr.map(id => (byId.get(String(id))?.name || '-'));
          catBreadcrumb.textContent = names.join(' › ');
        }
      }

      function buildList(parentId, depth){
        const ul = document.createElement('ul');
        const key = parentId || '__root__';
        const kids = byParent.get(key) || [];
        kids.forEach(cat => {
          const li = document.createElement('li');

          const row = document.createElement('div');
          row.className = 'tree-item' + (cat.id === state.activeCatId ? ' is-active' : '') + (pathIds.has(String(cat.id)) ? ' is-path' : '');
          row.dataset.id = cat.id;
          row.tabIndex = 0;
          row.setAttribute('role','treeitem');

          row.dataset.depth = String(depth);
const hasChildren = (byParent.get(cat.id) || []).length > 0;
          const isCollapsed = hasChildren && state.ui.collapsedCats.has(String(cat.id));

          const tgl = document.createElement('button');
          tgl.type = 'button';
          tgl.className = 'tree-tgl';
          tgl.textContent = hasChildren ? (isCollapsed ? '▸' : '▾') : '•';
          if(hasChildren){
tgl.addEventListener('click', (e) => {
              e.stopPropagation();
              const id = String(cat.id);
              if(state.ui.collapsedCats.has(id)) state.ui.collapsedCats.delete(id);
              else state.ui.collapsedCats.add(id);
              saveCollapsedCats(state.ui.collapsedCats);
              renderTree();
            });
          }

          const name = document.createElement('div');
          name.className = 'tree-name';
          name.textContent = cat.name || '-';

          const cnt = document.createElement('div');
          cnt.className = 'tree-count';
          cnt.textContent = String(countNotesInCat(cat.id, false));

          row.appendChild(tgl);
          row.appendChild(name);
          row.appendChild(cnt);

          row.addEventListener('click', (e) => {
            state.activeCatId = cat.id;
            // pick first note in cat
            const list = getVisibleNotes();
            if(list.length){
              state.activeNoteId = list[0].id;
            } else {
              state.activeNoteId = null;
            }
            renderAll();
            setTimeout(() => { try{ editor.focus(); }catch(e){} }, 0);
            closeDrawerSoon && closeDrawerSoon();
          });

          row.addEventListener('keydown', (e) => {
            if(e.key === 'Enter' || e.key === ' '){
              e.preventDefault();
              row.click();
            }
            if(e.key === 'ArrowLeft'){
              if(hasChildren && !isCollapsed){
                e.preventDefault();
                const id = String(cat.id);
                state.ui.collapsedCats.add(id);
                saveCollapsedCats(state.ui.collapsedCats);
                renderTree();
              }
            }
            if(e.key === 'ArrowRight'){
              if(hasChildren && isCollapsed){
                e.preventDefault();
                const id = String(cat.id);
                state.ui.collapsedCats.delete(id);
                saveCollapsedCats(state.ui.collapsedCats);
                renderTree();
              }
            }
          });

          li.appendChild(row);

           if(hasChildren && !isCollapsed){
             const sub = buildList(cat.id, depth+1);
             sub.classList.add('indent');
             li.appendChild(sub);
           }

          ul.appendChild(li);
        });
        return ul;
      }

      wrap.appendChild(buildList(null, 0));
      catTree.appendChild(wrap);
    }

    function getVisibleNotes(){
      const catId = state.activeCatId;
      const notes = state.notes
        .filter(n => (catId ? n.catId === catId : true))
        .filter(noteMatchesSearch)
        .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0));
      return notes;
    }

    function renderNotesList(){
      notesList.innerHTML = '';
      const notes = getVisibleNotes();
      listMeta.textContent = state.activeCatId ? ('Категория: ' + (catById(state.activeCatId)?.name || '-') + ' · ' + notes.length + ' заметок') : (notes.length + ' заметок');

      if(notes.length === 0){
  const box = document.createElement('div');
  box.className = 'empty';
  const h = document.createElement('h3');
  h.textContent = 'пусто';
  const p = document.createElement('p');
  p.textContent = state.search ? 'По запросу ничего не найдено. Попробуй другой поиск.' : 'В этой категории пока нет заметок. Создай первую - и она появится здесь.';
  const act = document.createElement('div');
  act.style.display = 'flex';
  act.style.gap = '10px';
  act.style.flexWrap = 'wrap';

  const btn = document.createElement('button');
  btn.className = 'n-btn is-primary';
  btn.type = 'button';
  btn.textContent = 'Новая заметка';
  btn.addEventListener('click', createNote);

  const btn2 = document.createElement('button');
  btn2.className = 'n-btn';
  btn2.type = 'button';
  btn2.textContent = 'Сбросить поиск';
  btn2.disabled = !state.search;
  btn2.addEventListener('click', () => {
    state.search = '';
    searchInput.value = '';
    renderNotesList();
    searchInput.focus();
  });

  act.appendChild(btn);
  act.appendChild(btn2);

  box.appendChild(h);
  box.appendChild(p);
  box.appendChild(act);
  notesList.appendChild(box);
  return;
}

      notes.forEach(n => {
        const row = document.createElement('div');
        row.className = 'note-row' + (n.id === state.activeNoteId ? ' is-active' : '');
        row.dataset.id = n.id;
        row.tabIndex = 0;
        row.setAttribute('role','button');

        const h = document.createElement('h3');
        h.className = 'note-title';
        h.textContent = (n.title && n.title.trim() ? n.title : 'noname').slice(0, 80);

        const sn = document.createElement('p');
        sn.className = 'note-snippet';
        sn.textContent = firstLine(n.html || '') || '…';

        row.appendChild(h);
        row.appendChild(sn);

        const openNote = () => {
          state.activeNoteId = n.id;
          renderEditor();
          renderNotesList();
          closeDrawerSoon && closeDrawerSoon();
        };
        row.addEventListener('click', openNote);
        row.addEventListener('keydown', (e) => {
          if(e.key === 'Enter' || e.key === ' '){
            e.preventDefault();
            openNote();
          }
        });

        notesList.appendChild(row);
      });
    }

    function renderEditor(){
      const note = state.activeNoteId ? noteById(state.activeNoteId) : null;
      const cat = state.activeCatId ? catById(state.activeCatId) : null;

      crumbs.textContent = state.activeCatId ? catPath(state.activeCatId) : '-';

      if(!note){
        noteTitle.value = '';
        // Можно начинать печатать сразу - при первом вводе заметка и категория создадутся автоматически
        noteTitle.disabled = false;
        // Не блокируем редактор: пусть пользователь сразу пишет, даже если нет ни одной категории/заметки
        if(!editor.innerHTML.trim()) editor.innerHTML = '<p></p>';
        editor.setAttribute('contenteditable', 'true');
        updatedText.textContent = '-';
        return;
      }


      noteTitle.disabled = false;
      editor.setAttribute('contenteditable','true');

      // avoid resetting cursor if already on same note and active element is editor
      if(noteTitle.value !== (note.title || '')) noteTitle.value = note.title || '';
      if(editor.dataset.noteId !== note.id){
        editor.innerHTML = note.html || '';
        editor.dataset.noteId = note.id;
      }

      updatedText.textContent = 'updated: ' + fmtTime(note.updatedAt);
    }

    function renderAll(){
      renderTree();
      renderNotesList();
      renderEditor();
    }

    // ========= autosave =========
    async function persistAll(){
      state.saving = true;
      setSaveStatus('saving');
      try{
        // write cats and notes
        await idbTx('readwrite',[STORE.cats, STORE.notes], st => {
          state.cats.forEach(c => st[STORE.cats].put(c));
          state.notes.forEach(n => st[STORE.notes].put(n));
        });
        state.lastSavedAt = now();
        state.dirty = false;
        setSaveStatus('saved');
      }catch(e){
        setSaveStatus('dirty');
      }finally{
        state.saving = false;
      }
    }

    function schedulePersist(delay=450){
      state.dirty = true;
      setSaveStatus('dirty');
      if(state.saveTimer) clearTimeout(state.saveTimer);
      state.saveTimer = setTimeout(async () => {
        await persistAll();
        // push cloud after local save
        if(state.cloud.mode !== 'off'){
          scheduleCloudPush();
        }
      }, delay);
    }

    // ========= editor commands =========
    function exec(cmd, arg=null){
      editor.focus();
      try{
        document.execCommand(cmd, false, arg);
      }catch(e){}
      schedulePersist();
    }

    
    // ========= editor selection-based formatting (2026-01) =========
    function getSelRange(){
      const sel = window.getSelection ? window.getSelection() : null;
      if(!sel || sel.rangeCount === 0) return null;
      const r = sel.getRangeAt(0);
      // Ensure selection is inside editor
      const common = r.commonAncestorContainer;
      const node = (common.nodeType === 1) ? common : common.parentNode;
      if(!node || !editor.contains(node)) return null;
      return r;
    }

    function cssTextFromObj(obj){
      return Object.entries(obj || {})
        .filter(([k,v]) => v !== null && v !== undefined && String(v).trim() !== '')
        .map(([k,v]) => `${k}:${String(v).trim()}`)
        .join(';');
    }

    function insertStyledCaretSpan(styles){
      const r = getSelRange();
      if(!r) return false;

      // create <span style="...">\u200B</span> and place caret after the ZWSP
      const span = document.createElement('span');
      span.setAttribute('style', cssTextFromObj(styles));
      span.textContent = '\u200B';
      r.deleteContents();
      r.insertNode(span);

      const sel = window.getSelection();
      const nr = document.createRange();
      nr.setStart(span.firstChild, 1);
      nr.collapse(true);
      sel.removeAllRanges();
      sel.addRange(nr);
      return true;
    }

    function wrapRangeWithSpan(range, styles){
      const span = document.createElement('span');
      span.setAttribute('style', cssTextFromObj(styles));

      // Extract selected contents, wrap, then insert back
      const frag = range.extractContents();
      span.appendChild(frag);
      range.insertNode(span);

      // Reselect wrapped contents
      const sel = window.getSelection();
      const nr = document.createRange();
      nr.selectNodeContents(span);
      sel.removeAllRanges();
      sel.addRange(nr);
      return span;
    }

    function applyStyleToSelection(styles, opts={}){
      editor.focus();
      const r = getSelRange();
      if(!r){
        // selection outside editor: just set defaults if requested
        if(opts.alsoSetDefault){
          if(styles['font-family']) setFontFamily(styles['font-family']);
          if(styles['font-size']) setFontSize(styles['font-size'].replace('px',''));
        }
        return;
      }

      if(r.collapsed){
        insertStyledCaretSpan(styles);
      } else {
        wrapRangeWithSpan(r, styles);
      }

      // Optionally set defaults for overall editor (so new text feels consistent)
      if(opts.alsoSetDefault){
        if(styles['font-family']) setFontFamily(styles['font-family']);
        if(styles['font-size']) setFontSize(String(styles['font-size']).replace('px',''));
      }

      schedulePersist();
    }

    function applyFontSizeToSelection(px, opts={}){
      const v = clamp(Number(px)||16, 10, 96);
      applyStyleToSelection({ 'font-size': v + 'px' }, opts);
    }

    // Normalize: remove leftover <font> tags (from execCommand), and cleanup ZWSP spans if possible
    function sanitizeEditorHTML(){
      try{
        // Replace <font> tags with spans while preserving color/face/size attributes
        editor.querySelectorAll('font').forEach(f => {
          const s = document.createElement('span');
          const styles = [];
          const color = f.getAttribute('color');
          const face = f.getAttribute('face');
          const size = f.getAttribute('size');
          if(color) styles.push('color:' + color);
          if(face) styles.push('font-family:' + face);
          // size is 1-7 (legacy) - ignore; user uses px controls
          if(styles.length) s.setAttribute('style', styles.join(';'));
          s.innerHTML = f.innerHTML;
          f.replaceWith(s);
        });

        // Remove spans that contain only ZWSP and no other text, after user typed
        editor.querySelectorAll('span').forEach(sp => {
          if(sp.textContent === '\u200B'){
            // keep if it's the caret carrier currently selected
            const sel = window.getSelection();
            const node = sel && sel.anchorNode;
            if(node && sp.contains(node)) return;
            sp.remove();
          }
        });
      }catch(e){}
    }
function setFontFamily(ff){
      document.documentElement.style.setProperty('--font-note', ff);
      try{ localStorage.setItem('onoi_font_note', ff); }catch(e){}
    }
    function setFontSize(px){
      const v = clamp(Number(px)||16, 12, 40);
      document.documentElement.style.setProperty('--fs-note', v + 'px');
      try{ localStorage.setItem('onoi_fs_note', String(v)); }catch(e){}
    }
    function applySavedTypography(){
      try{
        const ff = localStorage.getItem('onoi_font_note');
        const fs = localStorage.getItem('onoi_fs_note');
        if(ff){ setFontFamily(ff); fontSelect.value = ff; }
        if(fs){ setFontSize(fs); sizeSelect.value = fs; }
      }catch(e){}
    }

    // ========= image handling =========
    async function fileToDataURL(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(fr.error);
        fr.readAsDataURL(file);
      });
    }

    async function insertImageFromFile(file){
      if(!file) return;
      const dataUrl = await fileToDataURL(file);
      editor.focus();
      // insert at cursor
      const img = document.createElement('img');
      img.src = dataUrl;
      img.alt = file.name || 'image';
      // Try to insert as HTML
      const html = '<img src="' + dataUrl.replace(/"/g,'&quot;') + '" alt="' + (img.alt||'image').replace(/"/g,'&quot;') + '" />';
      document.execCommand('insertHTML', false, html);
      schedulePersist();
    }

    editor.addEventListener('paste', async (e) => {
      // If image in clipboard, insert as data URL
      const items = e.clipboardData && e.clipboardData.items ? [...e.clipboardData.items] : [];
      const imgItem = items.find(it => it.type && it.type.startsWith('image/'));
      if(imgItem){
        e.preventDefault();
        const file = imgItem.getAsFile();
        await insertImageFromFile(file);
      }
    });

    // ========= note operations =========
    

function ensureCategoryForNewNote(){
  // Notes must always belong to a real category.
  // If there are no categories at all - recreate root "main".
  // If active category is missing (deleted) - fallback to "main".
  const hadNoCats = state.cats.length === 0;
  const activeMissing = !state.activeCatId || !catById(state.activeCatId);
  if(hadNoCats || activeMissing){
    const mainId = getOrCreateMainCatId();
    state.activeCatId = mainId;
    // If we created categories implicitly - update tree + breadcrumbs immediately
    renderTree();
    crumbs.textContent = catPath(state.activeCatId);
  }
  return state.activeCatId;
}
async function createNote(){
      ensureCategoryForNewNote();

      const n = { id: uid(), catId: state.activeCatId, title: '', html: '<p></p>', createdAt: now(), updatedAt: now() };
      state.notes.unshift(n);
      state.activeNoteId = n.id;
      renderNotesList();
      renderEditor();
      editor.focus();
      schedulePersist();
    }

    function ensureActiveNoteFromDraft(){
      if(state.activeNoteId) return noteById(state.activeNoteId);

      ensureCategoryForNewNote();

const draftTitle = (noteTitle.value || '').trim();
      const draftHtml = (editor.innerHTML && editor.innerHTML.trim()) ? editor.innerHTML : '<p></p>';
      const n = { id: uid(), catId: state.activeCatId, title: draftTitle, html: draftHtml, createdAt: now(), updatedAt: now() };
      state.notes.unshift(n);
      state.activeNoteId = n.id;
      renderNotesList();
      schedulePersist();
      return n;
    }

	async function deleteActiveNote(){
      const note = state.activeNoteId ? noteById(state.activeNoteId) : null;
      if(!note) return;
      if(!(await uiConfirm('Удалить заметку?', 'onoi_notes'))) return;

      state.notes = state.notes.filter(n => n.id !== note.id);
      await idb.del(STORE.notes, note.id);

      const vis = getVisibleNotes();
      state.activeNoteId = vis[0]?.id || null;
      renderAll();
      schedulePersist(50);
    }

    async function createCategory(parentId=null){
      const name = await uiPrompt(parentId ? 'Название подкатегории:' : 'Название категории:', {title:'onoi_notes', label:'Название'});
      if(!name) return;
      const c = { id: uid(), parentId: parentId, name: name.trim(), createdAt: now(), updatedAt: now() };
      state.cats.push(c);
      state.activeCatId = c.id;
      renderAll();
      schedulePersist();
    }

    async function renameActiveCategory(){
      const c = state.activeCatId ? catById(state.activeCatId) : null;
      if(!c) return;
      const name = await uiPrompt('Новое имя:', c.name || '', {title:'onoi_notes', label:'Название'});
      if(!name) return;
      c.name = name.trim();
      c.updatedAt = now();
      renderTree();
      crumbs.textContent = catPath(state.activeCatId);
      schedulePersist();
    }

    async function deleteActiveCategory(){
      const c = state.activeCatId ? catById(state.activeCatId) : null;
      if(!c) return;
      const count = countNotesInCat(c.id, true);
      if(!(await uiConfirm('Удалить категорию и всё внутри?\nЗаметок затронется: ' + count, 'onoi_notes'))) return;

      // collect cat ids to delete
      const toDel = new Set([c.id]);
      let changed = true;
      while(changed){
        changed = false;
        for(const cc of state.cats){
          if(cc.parentId && toDel.has(cc.parentId) && !toDel.has(cc.id)){
            toDel.add(cc.id); changed = true;
          }
        }
      }
      state.cats = state.cats.filter(x => !toDel.has(x.id));
      state.notes = state.notes.filter(n => !toDel.has(n.catId));

      await idbTx('readwrite',[STORE.cats, STORE.notes], st => {
        toDel.forEach(id => st[STORE.cats].delete(id));
        // delete notes in those cats
        // brute force: clear all notes store then re-put current (simple + safe)
      });

      // re-sync stores (simple strategy)
      await idb.clear(STORE.cats);
      await idb.clear(STORE.notes);
      await idbTx('readwrite',[STORE.cats, STORE.notes], st => {
        state.cats.forEach(ca => st[STORE.cats].put(ca));
        state.notes.forEach(no => st[STORE.notes].put(no));
      });

      state.activeCatId = state.cats[0]?.id || null;
      const vis = getVisibleNotes();
      state.activeNoteId = vis[0]?.id || null;
      renderAll();
      schedulePersist(50);
    }

    // ========= export/import =========
    function currentDBSnapshot(){
      return {
        version: 1,
        exportedAt: new Date().toISOString(),
        cats: state.cats,
        notes: state.notes
      };
    }

    function downloadJSON(obj, filename){
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function importJSON(obj){
      if(!obj || typeof obj !== 'object') throw new Error('Bad JSON');
      if(!Array.isArray(obj.cats) || !Array.isArray(obj.notes)) throw new Error('No cats/notes arrays');

      // very light validation
      const cats = obj.cats.map(c => ({
        id: String(c.id || uid()),
        parentId: c.parentId ? String(c.parentId) : null,
        name: String(c.name || '-'),
        createdAt: Number(c.createdAt || now()),
        updatedAt: Number(c.updatedAt || now())
      }));
      const catIds = new Set(cats.map(c => c.id));
      const notes = obj.notes.map(n => ({
        id: String(n.id || uid()),
        catId: catIds.has(String(n.catId)) ? String(n.catId) : (cats[0]?.id || null),
        title: String(n.title || '-'),
        html: String(n.html || ''),
        createdAt: Number(n.createdAt || now()),
        updatedAt: Number(n.updatedAt || now())
      }));

      state.cats = cats;
      state.notes = notes;
      ensureDefaults();

      await idb.clear(STORE.cats);
      await idb.clear(STORE.notes);
      await idbTx('readwrite',[STORE.cats, STORE.notes], st => {
        state.cats.forEach(c => st[STORE.cats].put(c));
        state.notes.forEach(n => st[STORE.notes].put(n));
      });

      renderAll();
      schedulePersist(50);
    }

    // ========= whisperer transport =========
    function whisperSelectedOrActive(){
      const note = state.activeNoteId ? noteById(state.activeNoteId) : null;
      if(!note) return;
      const text = htmlToText(note.html);

      // Store payload for whisperer (primary transport)
      const payload = { mode:'single', noteIds:[note.id], text:text, createdAt: now() };
      try{ localStorage.setItem('onoi_whisper_payload_v1', JSON.stringify(payload)); }catch(e){}

      // Navigate (secondary transport via URL for short texts)
      try{
        const u = new URL('../whisperer/whisperer.html', window.location.href);
        u.searchParams.set('from','onoi_notes');
        if((text || '').length <= 2000){
          u.searchParams.set('text', text);
        }
        window.location.href = u.toString();
      }catch(e){
        window.location.href = '../whisperer/whisperer.html?from=onoi_notes';
      }
    }

    // ========= cloud sync =========
    function cloudHeaders(){
      const h = { 'Accept': 'application/vnd.github+json' };
      if(state.cloud.token) h['Authorization'] = 'Bearer ' + state.cloud.token;
      return h;
    }

    function setCloudUI(){
      cloudMode.value = state.cloud.mode;
      pollEvery.value = String(state.cloud.pollEvery || 0);
      ghToken.value = state.cloud.token || '';
      ghOwner.value = state.cloud.owner || '';
      ghRepo.value = state.cloud.repo || '';
      ghBranch.value = state.cloud.branch || 'main';
      ghPath.value = state.cloud.path || 'crate/onoi_notes/db.json';
      ghGistId.value = state.cloud.gistId || '';
      ghGistFile.value = state.cloud.gistFile || 'onoi_notes_db.json';

      repoFields.style.display = (state.cloud.mode === 'repo') ? '' : 'none';
      gistFields.style.display = (state.cloud.mode === 'gist') ? '' : 'none';
    }

    async function ghRepoGet(){
      const url = `https://api.github.com/repos/${encodeURIComponent(state.cloud.owner)}/${encodeURIComponent(state.cloud.repo)}/contents/${state.cloud.path}?ref=${encodeURIComponent(state.cloud.branch||'main')}`;
      const r = await fetch(url, { headers: cloudHeaders() });
      if(r.status === 404){
        return { exists:false, sha:null, json:null };
      }
      if(!r.ok){
        const t = await r.text();
        throw new Error('Repo GET failed: ' + r.status + ' ' + t.slice(0,200));
      }
      const data = await r.json();
      const content = (data && data.content) ? atob(data.content.replace(/\n/g,'')) : '';
      const json = content ? JSON.parse(content) : null;
      return { exists:true, sha:data.sha || null, json };
    }

    async function ghRepoPut(obj, sha){
      const url = `https://api.github.com/repos/${encodeURIComponent(state.cloud.owner)}/${encodeURIComponent(state.cloud.repo)}/contents/${state.cloud.path}`;
      const body = {
        message: 'onoi_notes autosync',
        content: btoa(unescape(encodeURIComponent(JSON.stringify(obj)))),
        branch: state.cloud.branch || 'main'
      };
      if(sha) body.sha = sha;
      const r = await fetch(url, { method:'PUT', headers: { ...cloudHeaders(), 'Content-Type':'application/json' }, body: JSON.stringify(body) });
      const t = await r.text();
      if(!r.ok){
        throw new Error('Repo PUT failed: ' + r.status + ' ' + t.slice(0,200));
      }
      const data = JSON.parse(t);
      return { sha: data.content && data.content.sha ? data.content.sha : null };
    }

    async function ghGistGet(){
      const url = `https://api.github.com/gists/${encodeURIComponent(state.cloud.gistId)}`;
      const r = await fetch(url, { headers: cloudHeaders() });
      if(!r.ok){
        const t = await r.text();
        throw new Error('Gist GET failed: ' + r.status + ' ' + t.slice(0,200));
      }
      const data = await r.json();
      const files = data.files || {};
      const file = files[state.cloud.gistFile] || Object.values(files)[0];
      if(!file) return { json:null };
      const content = file.content || '';
      const json = content ? JSON.parse(content) : null;
      return { json };
    }

    async function ghGistPatch(obj){
      const url = `https://api.github.com/gists/${encodeURIComponent(state.cloud.gistId)}`;
      const body = {
        files: {
          [state.cloud.gistFile]: { content: JSON.stringify(obj, null, 2) }
        }
      };
      const r = await fetch(url, { method:'PATCH', headers:{ ...cloudHeaders(), 'Content-Type':'application/json' }, body: JSON.stringify(body) });
      const t = await r.text();
      if(!r.ok){
        throw new Error('Gist PATCH failed: ' + r.status + ' ' + t.slice(0,200));
      }
      return true;
    }

    function mergeSnapshots(localSnap, remoteSnap){
      // Merge by ids and updatedAt (last-write-wins per entity).
      const out = currentDBSnapshot();
      const mapCats = new Map();
      const mapNotes = new Map();

      function upsertCat(c){
        const cur = mapCats.get(c.id);
        if(!cur || (Number(c.updatedAt||0) > Number(cur.updatedAt||0))) mapCats.set(c.id, c);
      }
      function upsertNote(n){
        const cur = mapNotes.get(n.id);
        if(!cur || (Number(n.updatedAt||0) > Number(cur.updatedAt||0))) mapNotes.set(n.id, n);
      }

      (localSnap?.cats || []).forEach(upsertCat);
      (remoteSnap?.cats || []).forEach(upsertCat);
      (localSnap?.notes || []).forEach(upsertNote);
      (remoteSnap?.notes || []).forEach(upsertNote);

      out.cats = [...mapCats.values()];
      out.notes = [...mapNotes.values()];

      // basic orphan fix
      const catIds = new Set(out.cats.map(c => c.id));
      const fallbackCat = out.cats[0]?.id || null;
      out.notes = out.notes.map(n => catIds.has(n.catId) ? n : ({...n, catId: fallbackCat}));

      return out;
    }

    let cloudPushTimer = null;
    function scheduleCloudPush(){
      if(state.cloud.mode === 'off') return;
      if(cloudPushTimer) clearTimeout(cloudPushTimer);
      cloudPushTimer = setTimeout(async () => {
        try{
          setSync('warn', 'syncing');
          const snap = currentDBSnapshot();

          if(state.cloud.mode === 'repo'){
            const cur = await ghRepoGet();
            const merged = cur.json ? mergeSnapshots(snap, cur.json) : snap;
            const res = await ghRepoPut(merged, cur.sha);
            state.cloud.lastSha = res.sha;
          } else if(state.cloud.mode === 'gist'){
            let remote = null;
            try{ remote = (await ghGistGet()).json; }catch(e){ remote = null; }
            const merged = remote ? mergeSnapshots(snap, remote) : snap;
            await ghGistPatch(merged);
          }

          state.cloud.lastPushAt = now();
          saveCloudSettings();
          setSync('ok', 'cloud');
        }catch(e){
          setSync('bad', 'cloud err');
        }
      }, 1200);
    }

    async function cloudPull(){
      if(state.cloud.mode === 'off') return;
      setSync('warn', 'pulling');
      const local = currentDBSnapshot();
      if(state.cloud.mode === 'repo'){
        const cur = await ghRepoGet();
        const merged = cur.json ? mergeSnapshots(local, cur.json) : local;
        state.cloud.lastSha = cur.sha;
        await importJSON(merged);
      } else if(state.cloud.mode === 'gist'){
        const cur = await ghGistGet();
        const merged = cur.json ? mergeSnapshots(local, cur.json) : local;
        await importJSON(merged);
      }
      state.cloud.lastPullAt = now();
      saveCloudSettings();
      setSync('ok', 'cloud');
    }

    function startPolling(){
      if(state.cloud.pollTimer){
        clearInterval(state.cloud.pollTimer);
        state.cloud.pollTimer = null;
      }
      const sec = Number(state.cloud.pollEvery||0);
      if(state.cloud.mode === 'off' || !sec || sec <= 0) return;
      state.cloud.pollTimer = setInterval(async () => {
        try{
          await cloudPull();
        }catch(e){
          setSync('bad', 'cloud err');
        }
      }, sec * 1000);
    }

    async function testCloudConn(){
      if(state.cloud.mode === 'off'){
        toast('cloud', 'Cloud mode выключен.', {ttl: 3000});
        return;
      }
      setSync('warn', 'testing');
      try{
        if(state.cloud.mode === 'repo'){
          await ghRepoGet();
        } else {
          await ghGistGet();
        }
        setSync('ok', 'cloud');
        toast('cloud', 'OK: доступ есть.', {ttl: 2600});
      }catch(e){
        setSync('bad', 'cloud err');
        toast('error', String(e.message || e), {ttl: 5200});
      }
    }

    // ========= events =========
    searchInput.addEventListener('input', () => {
      state.search = (searchInput.value || '').trim();
      renderNotesList();
    });

    if(newNoteBtn) newNoteBtn.addEventListener('click', createNote);
    deleteNoteBtn.addEventListener('click', deleteActiveNote);

    addCatBtn.addEventListener('click', () => createCategory(null));
    addSubCatBtn.addEventListener('click', () => {
      if(!state.activeCatId){ createCategory(null); return; }
      createCategory(state.activeCatId);
    });
    renameCatBtn.addEventListener('click', renameActiveCategory);
    deleteCatBtn.addEventListener('click', deleteActiveCategory);

    noteTitle.addEventListener('input', () => {
      const note = ensureActiveNoteFromDraft();
      if(!note) return;
      note.title = (noteTitle.value || '').trim();
      note.updatedAt = now();
      updatedText.textContent = 'updated: ' + fmtTime(note.updatedAt);
      renderNotesList();
      schedulePersist();
    });

    editor.addEventListener('input', () => {
      const note = ensureActiveNoteFromDraft();
      if(!note) return;
      note.html = editor.innerHTML;
      note.updatedAt = now();
      updatedText.textContent = 'updated: ' + fmtTime(note.updatedAt);
      renderNotesList();
      schedulePersist();
    });

    document.querySelectorAll('.tool[data-cmd]').forEach(btn => {
      btn.addEventListener('click', () => {
        const cmd = btn.dataset.cmd;
        const arg = btn.dataset.arg || null;
        if(cmd === 'formatBlock' && arg){
          exec('formatBlock', '<' + arg + '>');
        } else {
          exec(cmd, arg);
        }
      });
    });

    
    
    // Extra editor tools
    if(clearFmtBtn){
      clearFmtBtn.addEventListener('click', () => {
        editor.focus();
        try{ document.execCommand('removeFormat', false, null); }catch(e){}
        try{ document.execCommand('unlink', false, null); }catch(e){}
        sanitizeEditorHTML();
        schedulePersist();
      });
    }

    if(blockSelect){
      blockSelect.addEventListener('change', () => {
        const v = blockSelect.value || 'p';
        if(v === 'p') exec('formatBlock', '<p>');
        else if(v === 'pre') exec('formatBlock', '<pre>');
        else if(v === 'blockquote') exec('formatBlock', '<blockquote>');
        else exec('formatBlock', '<' + v + '>');
        schedulePersist();
      });
    }

    if(customSizeBtn){
      customSizeBtn.addEventListener('click', async () => {
        const v = await uiPrompt('Размер шрифта в px (например: 15, 17, 22)', { title: 'Размер текста', label: 'px', value: String(sizeSelect.value || 16) });
        if(!v) return;
        const n = Number(String(v).replace(',', '.'));
        if(!Number.isFinite(n)) return;
        const px = clamp(n, 8, 160);
        applyFontSizeToSelection(px, { alsoSetDefault: false });
      });
    }

    // Smarter paste: default to plain text (Shift+Paste keeps formatting)
    editor.addEventListener('paste', (e) => {
      if(e.shiftKey) return; // keep rich paste
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text/plain') || '';
      const lines = text.replace(/\r/g,'').split('\n');
      const html = lines.map(line => line
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#039;') || '<br>').join('<br>');
      const r = getSelRange();
      if(r){
        r.deleteContents();
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        const frag = document.createDocumentFragment();
        while(tmp.firstChild) frag.appendChild(tmp.firstChild);
        r.insertNode(frag);
        // move caret to end
        const sel = window.getSelection();
        sel.removeAllRanges();
        const nr = document.createRange();
        nr.selectNodeContents(editor);
        nr.collapse(false);
        sel.addRange(nr);
      }else{
        try{ document.execCommand('insertHTML', false, html); }catch(err){}
      }
      sanitizeEditorHTML();
      schedulePersist();
    });

    // Keep HTML tidy
    editor.addEventListener('input', () => {
      sanitizeEditorHTML();
    });

fontSelect.addEventListener('change', () => {
      applyStyleToSelection({ 'font-family': fontSelect.value }, { alsoSetDefault: true });
    });
    sizeSelect.addEventListener('change', () => {
      const px = clamp(Number(sizeSelect.value)||16, 10, 96);
      applyFontSizeToSelection(px, { alsoSetDefault: true });
    });

function applyColorSwatches(){
      colorSwatch.style.background = colorPick.value;
      hlSwatch.style.background = hlPick.value;
    }
    applyColorSwatches();
    colorPick.addEventListener('input', () => {
      applyColorSwatches();
      applyStyleToSelection({ color: colorPick.value });
    });
    hlPick.addEventListener('input', () => {
      applyColorSwatches();
      applyStyleToSelection({ 'background-color': hlPick.value });
    });
    linkBtn.addEventListener('click', async () => {
      const url = await uiPrompt('Ссылка (URL):', {title:'link', label:'URL', placeholder:'https://...'});
      if(!url) return;
      exec('createLink', url.trim());
    });

    imgBtn.addEventListener('click', () => imgFile.click());
    imgFile.addEventListener('change', async () => {
      const f = imgFile.files && imgFile.files[0];
      imgFile.value = '';
      if(!f) return;
      await insertImageFromFile(f);
    });

    focusBtn.addEventListener('click', () => {
      // simple focus mode: hide left/right rails by toggling body class
      document.body.classList.toggle('focus-mode');
      const on = document.body.classList.contains('focus-mode');
      focusBtn.textContent = on ? 'unfocus' : 'focus';
    });


    // Sidebar toggle + splitter
    function setSidebarCollapsed(v){
      state.ui.sidebarCollapsed = !!v;
      lsSet(LS_UI.sidebarCollapsed, state.ui.sidebarCollapsed ? '1' : '0');
      applySidebarUI();
    }

    if(toggleSidebarBtn){
      toggleSidebarBtn.addEventListener('click', () => {
        setSidebarCollapsed(!state.ui.sidebarCollapsed);
      });
    }

    function setSidebarWidth(px){
      const v = clamp(Number(px) || 320, 220, 520);
      state.ui.sidebarW = v;
      lsSet(LS_UI.sidebarW, String(v));
      document.documentElement.style.setProperty('--sidebarW', v + 'px');
    }

    if(splitter){
      let drag = false;

      splitter.addEventListener('mousedown', (ev) => {
        ev.preventDefault();
        drag = true;
        if(state.ui.sidebarCollapsed) setSidebarCollapsed(false);
        document.body.classList.add('is-dragging');
      });

      window.addEventListener('mousemove', (ev) => {
        if(!drag) return;
        const shell = document.querySelector('.n-shell');
        if(!shell) return;
        const r = shell.getBoundingClientRect();
        const w = ev.clientX - r.left;
        setSidebarWidth(w);
      });

      window.addEventListener('mouseup', () => {
        if(!drag) return;
        drag = false;
        document.body.classList.remove('is-dragging');
      });
    }

    // Keyboard: Ctrl+\ - toggle sidebar
    window.addEventListener('keydown', (e) => {
      if(e.ctrlKey && (e.key === '\\' || e.code === 'Backslash')){
        e.preventDefault();
        setSidebarCollapsed(!state.ui.sidebarCollapsed);
      }
    });


    settingsBtn.addEventListener('click', () => {
      settingsModal.classList.add('is-open');
      setCloudUI();
      ghToken.focus();
    });
    closeSettings.addEventListener('click', () => settingsModal.classList.remove('is-open'));
    settingsModal.addEventListener('click', (e) => {
      if(e.target === settingsModal) settingsModal.classList.remove('is-open');
    });

    cloudMode.addEventListener('change', () => {
      state.cloud.mode = cloudMode.value;
      setCloudUI();
      saveCloudSettings();
      if(state.cloud.mode === 'off'){ setSync('ok','local'); }
      startPolling();
    });
    pollEvery.addEventListener('change', () => {
      state.cloud.pollEvery = Number(pollEvery.value||0);
      saveCloudSettings();
      startPolling();
    });

    function syncCloudFieldsFromInputs(){
      state.cloud.token = ghToken.value.trim();
      state.cloud.owner = ghOwner.value.trim();
      state.cloud.repo = ghRepo.value.trim();
      state.cloud.branch = (ghBranch.value.trim() || 'main');
      state.cloud.path = (ghPath.value.trim() || 'crate/onoi_notes/db.json');
      state.cloud.gistId = ghGistId.value.trim();
      state.cloud.gistFile = (ghGistFile.value.trim() || 'onoi_notes_db.json');
      saveCloudSettings();
    }
    [ghToken, ghOwner, ghRepo, ghBranch, ghPath, ghGistId, ghGistFile].forEach(el => {
      el.addEventListener('input', () => { syncCloudFieldsFromInputs(); });
    });

    testCloud.addEventListener('click', async () => {
      try{
        syncCloudFieldsFromInputs();
        await testCloudConn();
      }catch(e){}
    });
    pullCloud.addEventListener('click', async () => {
      try{
        syncCloudFieldsFromInputs();
        await cloudPull();
        toast('cloud', 'Pull: готово.', {ttl: 2600});
      }catch(e){
        toast('error', String(e.message || e), {ttl: 5200});
      }
    });
    pushCloud.addEventListener('click', async () => {
      try{
        syncCloudFieldsFromInputs();
        setSync('warn','pushing');
        scheduleCloudPush();
        toast('cloud', 'Push: отправка запланирована (авто).', {ttl: 3000});
      }catch(e){
        toast('error', String(e.message || e), {ttl: 5200});
      }
    });

    exportBtn.addEventListener('click', () => {
      downloadJSON(currentDBSnapshot(), 'onoi_notes_export.json');
    });
    importBtn.addEventListener('click', () => importFile.click());
    importFile.addEventListener('change', async () => {
      const f = importFile.files && importFile.files[0];
      importFile.value = '';
      if(!f) return;
      try{
        const txt = await f.text();
        const obj = JSON.parse(txt);
        await importJSON(obj);
        toast('import', 'Импорт: готово.', {ttl: 2600});
      }catch(e){
        toast('import', 'Ошибка импорта: ' + String(e.message || e), {ttl: 5200});
      }
    });

    whisperBtn.addEventListener('click', whisperSelectedOrActive);

    // ========= keyboard shortcuts =========
    window.addEventListener('keydown', (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      const inEditor = (e.target === editor || tag === 'input' || tag === 'textarea' || tag === 'select' || e.target.isContentEditable);

      if(e.ctrlKey && (e.key.toLowerCase() === 'k')){
        e.preventDefault();
        searchInput.focus();
        searchInput.select();
        return;
      }
      if(e.ctrlKey && (e.key.toLowerCase() === 'n')){
        e.preventDefault();
        createNote();
        return;
      }
      if(e.ctrlKey && (e.key.toLowerCase() === 'f')){
        e.preventDefault();
        searchInput.focus();
        searchInput.select();
        return;
      }
      if(e.key === 'Delete' && !inEditor){
        deleteActiveCategory();
        return;
      }
      if(e.key === 'Enter' && !inEditor){
        renameActiveCategory();
        return;
      }
    });

    // ========= init =========
    async function boot(){
      // UI init
      const sw = Number(lsGet(LS_UI.sidebarW) || 320);
      state.ui.sidebarW = clamp(sw, 220, 520);
      state.ui.sidebarCollapsed = (lsGet(LS_UI.sidebarCollapsed) === '1');
      state.ui.collapsedCats = loadCollapsedCats();
      applySidebarUI();

      loadCloudSettings();
      applySavedTypography();

      // load all from idb
      state.cats = await idb.all(STORE.cats);
      state.notes = await idb.all(STORE.notes);

      ensureDefaults();

      // persist defaults if needed
      await persistAll();

      // render
      renderAll();

      // set sync indicator
      if(state.cloud.mode === 'off') setSync('ok', 'local');
      else setSync('warn', 'cloud');

      // start polling and initial pull (optional)
      setCloudUI();
      startPolling();

      // If cloud enabled, try pull once at start (best-effort)
      if(state.cloud.mode !== 'off'){
        try{
          await cloudPull();
        }catch(e){
          setSync('bad','cloud err');
        }
      }
    }

    boot();
  })();
  </script>

  <style>
    /* focus mode: hide rails + reduce distractions */
    body.focus-mode .rail{ display:none !important; }
    body.focus-mode .notes-wrap{ max-width: 940px; }
  </style>
</body>
</html>
