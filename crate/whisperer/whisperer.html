<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Item Key — whisperer</title>

  <!-- глобальный стиль сайта -->
  <link rel="stylesheet" href="../../assets/css/styles.css" />

  <!-- локальные стили ТОЛЬКО для whisperer -->
  <style>.whisperer-wrap, .whisperer-wrap * { box-sizing: border-box; }

    :root{
      --footerH: 56px;      /* measured in JS */
      --floatH: 60px;       /* measured in JS */
      --topbarOffset: 74px; /* safety spacing under header */

      /* typography */
      --w-font-size: 16px;  /* controlled by slider */
      --w-line-height: 1.75;
    }

    /* Keep content clear of fixed header and fixed bottom UI */
    .center-stage{
      padding-top: calc(var(--topbarOffset) + var(--floatH) + 18px);
      padding-bottom: calc(var(--footerH) + 28px + env(safe-area-inset-bottom));
      overflow-x: hidden;
    }

    .whisperer-wrap{
      width: 100%;
      max-width: 1040px;
      margin: 0 auto;
      display: grid;
      gap: 16px;
      padding: 12px 24px 22px;
      min-width: 0;
    }

    .w-title{
      padding: 6px 0 0;
      text-align: center;
      display: grid;
      gap: 8px;
    }
    .w-title h1{
      margin: 0;
      font-size: 14px;
      letter-spacing: 6px;
      text-transform: uppercase;
    }
    .w-title .sub{
      font-size: 11px;
      letter-spacing: 3.5px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
    }

    .w-grid{
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 0.8fr);
      gap: 16px;
      align-items: start;
    }

    .w-card, .w-reader, .w-warning{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.86);
      padding: 16px;
      border-radius: 0;
      box-shadow: none;
      min-width: 0;
    }

    .w-label{
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
    }

    textarea.w-text{
      width: 100%;
      min-height: 260px;
      resize: vertical;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 12px 12px;
      font-size: var(--w-font-size);
      line-height: var(--w-line-height);
      outline: none;
      border-radius: 0;
    }
    textarea.w-text:focus{ border-color: rgba(0,0,0,.34); }

    .w-controls{ display: grid; gap: 14px; }
    .w-row{ display: grid; gap: 8px; }

    .w-field{ display: grid; gap: 8px; min-width: 0; }

    input[type="range"], select{
      width: 100%;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
    }
    input[type="range"]{ padding: 0 8px; }
    select{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .w-hint{
      font-size: 11px;
      line-height: 1.45;
      color: rgba(0,0,0,.70);
      margin: 0;
    }

    .w-actions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .w-btn{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.90);
      padding: 12px 10px;
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform .18s ease, border-color .18s ease, opacity .18s ease;
      border-radius: 0;
      min-height: 44px;
      line-height: 1.2;
      white-space: normal;
      text-align: center;
    }
    .w-btn:hover{ transform: translateY(-1px); border-color: rgba(0,0,0,.30); opacity: .98; }
    .w-btn:disabled{ opacity: .5; cursor: not-allowed; transform: none; }
    .w-btn:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }

    .w-status{
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 11px;
      color: rgba(0,0,0,.72);
      margin-top: 2px;
    }
    .w-pill{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.82);
      padding: 5px 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 10px;
      color: rgba(0,0,0,.62);
      border-radius: 0;
    }

    details.w-adv{
      border: 1px dashed rgba(0,0,0,.14);
      padding: 10px;
      background: rgba(255,255,255,.70);
    }
    details.w-adv summary{
      cursor: pointer;
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.62);
      user-select: none;
      outline: none;
    }
    details.w-adv[open] summary{ margin-bottom: 10px; }

    .w-reader{
      display: grid;
      gap: 10px;
    }

    .w-display{
      font-size: var(--w-font-size);
      line-height: var(--w-line-height);
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 0;
      padding: 10px 10px;
      border-radius: 0;
      border: 1px dashed rgba(0,0,0,.14);
      background: rgba(255,255,255,.65);
      min-width: 0;
    }

    .w-word{ padding: 0 2px; cursor: pointer; }
    .w-word:hover{ background: rgba(0,0,0,.06); }
    .w-word.is-active{
      text-decoration: underline;
      text-underline-offset: 3px;
      background: rgba(0,0,0,.08);
    }

    .w-warning{
      font-size: 12px;
      line-height: 1.45;
      color: rgba(0,0,0,.72);
    }

    /* Floating transport: ALWAYS visible */
    .w-floatbar{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: calc(var(--topbarOffset) + 8px);
      z-index: 99999; /* must stay above footer + overlays */
      display: flex;
      gap: 10px;
      align-items: stretch;
      justify-content: center;
      padding: 10px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(6px);
      min-width: min(720px, calc(100% - 24px));
      pointer-events: auto;
    }
    .w-floatbar .w-btn{
      flex: 1 1 0;
      min-width: 0;
      min-height: 46px;
    }
    .w-btn--primary{
      border-color: rgba(0,0,0,.28);
      font-weight: 700;
      letter-spacing: 4px;
    }

    @media (max-width: 980px){
      :root{ --topbarOffset: 66px; }
      .whisperer-wrap{ padding: 10px 14px 18px; }
      .w-grid{ grid-template-columns: 1fr; }
      textarea.w-text{ min-height: 220px; }
    }
    @media (max-width: 520px){
      .w-floatbar{
        left: 12px;
        right: 12px;
        transform: none;
        min-width: auto;
      }
    }

    /* =========================
       Mobile-first responsiveness
       ========================= */

    /* Better tap behavior on touch devices */
    button, a, input, select, textarea{
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* Hide side rails on small screens to maximize usable space */
    @media (max-width: 980px){
      .rail{ display: none !important; }
      .center-stage{ padding-left: 0 !important; padding-right: 0 !important; }
    }

    /* Phone layout: single-column, larger touch targets, no iOS zoom-on-focus */
    @media (max-width: 520px){
      :root{
        --topbarOffset: 58px; /* tighter top spacing on phones */
      }

      .whisperer-wrap{
        padding: 10px 12px 16px;
        gap: 12px;
      }

      .w-title h1{
        letter-spacing: 5px;
      }
      .w-title .sub{
        letter-spacing: 2.5px;
      }

      textarea.w-text{
        min-height: 200px;
        resize: vertical;
      }

      /* Prevent iOS Safari from zooming when focusing inputs (<16px triggers zoom) */
      input[type="range"], select, .modal-input{
        font-size: 16px;
      }

      .w-actions{
        grid-template-columns: 1fr;
      }

      /* Floating control bar: stack buttons vertically on phones */
      .w-floatbar{
        left: 12px;
        right: 12px;
        transform: none;
        min-width: auto;
        flex-direction: column;
        gap: 8px;
        padding: 10px;
        top: calc(var(--topbarOffset) + 8px);
      }
      .w-floatbar .w-btn{
        min-height: 48px;
      }

      /* Modal: full-screen sheet on phones */
      .modal{
        padding: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
      }
      .modal-card{
        width: 100%;
        max-height: calc(100dvh - 20px);
      }
      .modal-list{
        max-height: 48dvh;
      }
      .modal-head{
        grid-template-columns: 1fr;
        gap: 10px;
      }
      #closeNotesModal{
        width: 100%;
      }
    }

    /* Short screens (landscape phones): reduce vertical waste */
    @media (max-height: 700px) and (max-width: 980px){
      textarea.w-text{ min-height: 160px; }
      .modal-list{ max-height: 38vh; }
    }

  
    
    
    /* restore icon when expanded */
    .w-winbtn.is-on .ico::after{
      content: "";
      position: absolute;
      left: 3px;
      top: -3px;
      width: 14px;
      height: 12px;
      border: 1px solid rgba(0,0,0,.78);
      background: transparent;
    }

    .follow-scrim{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.25);
      z-index: 89999;
      display: none;
    }
    .follow-scrim.is-on{ display: block; }

    .w-reader.is-full{
      position: fixed;
      left: 12px;
      right: 12px;
      top: calc(var(--topbarOffset) + var(--floatH) + 18px);
      bottom: calc(var(--footerH) + 16px + env(safe-area-inset-bottom));
      z-index: 90000;
      width: auto;
      max-width: none;
      margin: 0;
      background: rgba(255,255,255,.98);
      box-shadow: 0 14px 34px rgba(0,0,0,.12);
      overflow: hidden;
    }
    .w-reader.is-full .w-reader-head{
      position: sticky;
      top: 0;
      z-index: 2;
      background: rgba(255,255,255,.98);
      padding-bottom: 10px;
      margin-bottom: 6px;
      border-bottom: 1px dashed rgba(0,0,0,.14);
    }
    .w-reader.is-full .w-display{
      height: 100%;
      max-height: none;
      overflow: auto;
    }

    @media (max-width: 520px){
      .w-reader.is-full{
        left: 10px;
        right: 10px;
        top: calc(var(--topbarOffset) + 4px);
      }
    }

    /* FOLLOW fullscreen (clean, "window" style) */
    .w-reader-head{
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .w-reader-head .w-label{
      margin: 0;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Caption-style button (Windows-like) */
    .w-winbtn{
      width: 44px;
      height: 32px;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.92);
      cursor: pointer;
      display: grid;
      place-items: center;
      padding: 0;
      border-radius: 0;
      transition: background .15s ease, border-color .15s ease, transform .10s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      flex: none;
    }
    .w-winbtn:hover{ background: rgba(0,0,0,.06); border-color: rgba(0,0,0,.28); }
    .w-winbtn:active{ transform: translateY(1px); }
    .w-winbtn:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }

    .w-winbtn .ico{
      position: relative;
      width: 14px;
      height: 12px;
    }
    .w-winbtn .ico::before{
      content: "";
      position: absolute;
      inset: 0;
      border: 1px solid rgba(0,0,0,.78);
      background: transparent;
    }
    .w-winbtn.is-on .ico::after{
      content: "";
      position: absolute;
      left: 3px;
      top: -3px;
      width: 14px;
      height: 12px;
      border: 1px solid rgba(0,0,0,.78);
      background: transparent;
    }

    /* Scrim behind the fullscreen window */
    .follow-scrim{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.30);
      z-index: 89999;
      display: none;
    }
    .follow-scrim.is-on{ display: block; }

    /* Fullscreen "window" itself */
    .w-reader.is-full{
      position: fixed;
      left: 12px;
      right: 12px;
      top: calc(var(--topbarOffset) + var(--floatH) + 18px);
      bottom: calc(var(--footerH) + 12px + env(safe-area-inset-bottom));
      z-index: 90000;

      margin: 0;
      padding: 0;
      border: 1px solid rgba(0,0,0,.20);
      background: rgba(255,255,255,.98);
      box-shadow: 0 16px 44px rgba(0,0,0,.18);
      overflow: hidden;

      display: flex;
      flex-direction: column;
      gap: 0;
    }

    /* Title bar */
    .w-reader.is-full .w-reader-head{
      position: sticky;
      top: 0;
      z-index: 2;
      padding: 10px 12px;
      background: rgba(255,255,255,.98);
      border-bottom: 1px solid rgba(0,0,0,.14);
    }

    /* Content area */
    .w-reader.is-full .w-display{
      flex: 1;
      overflow: auto;
      border: none;
      background: transparent;
      padding: 14px 16px;
    }

    @media (max-width: 520px){
      .w-reader.is-full{
        left: 10px;
        right: 10px;
        top: 10px;
        bottom: calc(var(--footerH) + 10px + env(safe-area-inset-bottom));
      }
      .w-reader.is-full .w-display{ padding: 12px 12px; }
    }

</style>
</head>

<body class="page page-crate">
  <!-- фон/рамки — как в item-key -->
  <div class="outer-frame" aria-hidden="true"></div>
  <div class="rays" aria-hidden="true"></div>
  <div class="veil" aria-hidden="true"></div>

  <!-- верхний “герб” -->
  <header class="topbar topbar--edge">
    <a class="toplink" href="../../item-user.html?returnTo=crate/whisperer/whisperer.html" aria-label="Item User">
      <span class="tag">item-user</span>
    </a>
  </header>

  <!-- левый rail -->
  <aside class="rail rail--left" aria-label="Левое меню">
    <a class="rail-link" href="../../index.html">
      <span class="rail-link__title">item-key</span>
      <span class="rail-link__meta">главное меню</span>
    </a>
    <a class="rail-link" href="../../item-crate.html">
      <span class="rail-link__title">item-crate</span>
      <span class="rail-link__meta">назад в хаб</span>
    </a>
  </aside>

  <!-- правый rail -->
  <aside class="rail rail--right" aria-label="Правое меню">
    <a class="rail-link" href="../../item-soft.html">
      <span class="rail-link__title">item-soft</span>
      <span class="rail-link__meta">инструменты / редакторы</span>
    </a>
    <a class="rail-link" href="../../item-security.html">
      <span class="rail-link__title">item-security</span>
      <span class="rail-link__meta">доступ / защита</span>
    </a>
  </aside>

  <main class="center-stage" aria-label="whisperer center">
    <section class="whisperer-wrap" aria-label="whisperer app">
      <div class="w-title">
        <h1>whisperer</h1>
        <div class="sub">прошепчи моё имя, пожалуйста</div>
      </div>

      <div class="w-warning" id="supportBox" hidden>
        Ваш браузер не поддерживает Web Speech API (SpeechSynthesis). Попробуйте Chrome / Edge или обновите браузер.
      </div>

      <div class="w-grid">
        <div class="w-card" aria-label="Ввод текста">
          <div class="w-label">text</div>
          <textarea class="w-text" id="textInput" placeholder="Вставь сюда текст…"></textarea>
          <p class="w-hint">
            Клик по слову в FOLLOW — начать чтение с него. Панель «Озвучить / Пауза / Стоп» всегда видна сверху.
          </p>
        </div>

        <div class="w-card w-controls" aria-label="Настройки">
          <div class="w-label">settings</div>

          <div class="w-row">
            <div class="w-field">
              <div class="w-label">text size</div>
              <input id="fontRange" type="range" min="12" max="30" step="1" value="16" />
              <div class="w-status">
                <span class="w-pill" id="fontVal">16px</span>
                <span class="w-pill" id="langPill">lang: auto</span>
              </div>
            </div>
          </div>

          <div class="w-actions" aria-label="Инструменты">
            <button class="w-btn" id="prepBtn" type="button">Подготовить</button>
            <button class="w-btn" id="clearBtn" type="button">Очистить</button>
          </div>

          <button class="w-btn" id="fromNotesBtn" type="button">Из заметок</button>

          <details class="w-adv" id="narratorAdv">
            <summary>narrator</summary>
            <div class="w-row">
              <div class="w-field">
                <div class="w-label">rate</div>
                <input id="rateRange" type="range" min="0.10" max="3.00" step="0.01" value="1.00" />
                <div class="w-status">
                  <span class="w-pill" id="rateVal">1.00×</span>
                  <span class="w-pill" id="chunkVal">chunk: auto</span>
                </div>
              </div>

              <div class="w-field">
                <div class="w-label">slow factor</div>
                <input id="delayScaleRange" type="range" min="1" max="12" step="0.1" value="1" />
                <div class="w-status">
                  <span class="w-pill" id="delayScaleVal">slow: 1.0×</span>
                  <span class="w-pill">gaps × slow</span>
                </div>
              </div>


              <div class="w-field">
                <div class="w-label">pitch</div>
                <input id="pitchRange" type="range" min="0" max="2" step="0.05" value="1" />
                <div class="w-status">
                  <span class="w-pill" id="pitchVal">1.00</span>
                  <span class="w-pill" id="volPill">vol: 1.00</span>
                </div>
              </div>

              <div class="w-field">
                <div class="w-label">volume</div>
                <input id="volRange" type="range" min="0" max="1" step="0.05" value="1" />
              </div>

              <div class="w-field">
                <div class="w-label">word gap</div>
                <input id="wordGapRange" type="range" min="0" max="4000" step="50" value="0" />
                <div class="w-status">
                  <span class="w-pill" id="wordGapVal">0ms</span>
                  <span class="w-pill" id="sentGapPill">sentence: 250ms</span>
                </div>
              </div>

              <div class="w-field">
                <div class="w-label">sentence gap</div>
                <input id="sentGapRange" type="range" min="0" max="20000" step="100" value="250" />
              </div>

              <div class="w-field">
                <div class="w-label">paragraph gap</div>
                <input id="paraGapRange" type="range" min="0" max="60000" step="250" value="600" />
                <div class="w-status">
                  <span class="w-pill" id="paraGapVal">600ms</span>
                  <span class="w-pill" id="punctPill">punct: on</span>
                </div>
              </div>

              <div class="w-field">
                <div class="w-label">chunking</div>
                <select id="chunkMode" aria-label="Chunking mode">
                  <option value="auto">Auto (smooth)</option>
                  <option value="phrase">Phrase (punctuation)</option>
                  <option value="word">Word (precise gaps)</option>
                </select>
              </div>

              <div class="w-field">
                <label class="w-hint" style="display:flex; gap:10px; align-items:center; margin:0;">
                  <input id="punctPause" type="checkbox" checked style="width:18px; height:18px;">
                  Add extra pauses after punctuation (., !, ?, …)
                </label>
              </div>

              <p class="w-hint">
                Подсказка: Word-режим даёт точный интервал между словами, но может звучать более «рублено». Auto — максимально плавно.
              </p>
            </div>
          </details>

          <details class="w-adv" id="voicesAdv">
            <summary>voices</summary>
            <div class="w-row">
              <div class="w-field">
                <div class="w-label">EN voice (optional)</div>
                <select id="voiceEnSelect" aria-label="English voice">
                  <option value="__auto__">Auto</option>
                </select>
              </div>
              <div class="w-field">
                <div class="w-label">RU voice (optional)</div>
                <select id="voiceRuSelect" aria-label="Russian voice">
                  <option value="__auto__">Auto</option>
                </select>
              </div>
              <p class="w-hint">
                Авто-режим сам выбирает язык (EN/RU) по тексту и переключает озвучку. Эти списки — только если хочешь жёстко закрепить голоса.
              </p>
            </div>
          </details>

          <div class="w-status" aria-label="Статус">
            <span class="w-pill" id="modePill">mode: idle</span>
            <span class="w-pill" id="posPill">word: —</span>
          </div>

          <p class="w-hint">
            Горячие клавиши: Ctrl+Enter — озвучить, Space — пауза/продолжить, Esc — стоп.
          </p>
        </div>
      </div>

      <div class="w-reader" id="followCard" aria-label="Текст с подсветкой">
        <div class="w-reader-head">
          <div class="w-label">follow</div>
          <button class="w-winbtn" id="followFullBtn" type="button" aria-label="Развернуть FOLLOW" aria-pressed="false" title="Развернуть FOLLOW">
            <span class="ico" aria-hidden="true"></span>
          </button>
        </div>
        <p class="w-display" id="display"></p>
      </div>
    </section>
  </main>

  <!-- Follow fullscreen scrim -->
  <div class="follow-scrim" id="followScrim" hidden aria-hidden="true"></div>

  <!-- Floating transport bar (ALWAYS visible) -->
  <div class="w-floatbar" id="floatbar" aria-label="Управление озвучкой">
    <button class="w-btn w-btn--primary" id="speakBtn" type="button">Озвучить</button>
    <button class="w-btn" id="pauseBtn" type="button" disabled>Пауза</button>
    <button class="w-btn" id="stopBtn" type="button" disabled>Стоп</button>
  </div>

  <footer class="bottombar bottombar--edge">
    <span class="hint">whisperer</span>
    <span class="sep">•</span>
    <span class="hint">speech · follow</span>
  </footer>


  <!-- Notes picker modal -->
  <div class="modal" id="notesModal" role="dialog" aria-modal="true" aria-label="Заметки">
    <div class="modal-card">
      <div class="modal-head">
        <div>
          <div class="w-label">notes</div>
          <div style="font-size:11px; color: rgba(0,0,0,.72); line-height:1.45">
            Выбери заметки — я вставлю их в поле текста. Можно сразу «Озвучить».
          </div>
        </div>
        <button class="w-btn" id="closeNotesModal" type="button">Закрыть</button>
      </div>

      <div class="modal-grid">
        <input id="notesSearch" class="modal-input" placeholder="Поиск заметок…" />
        <div class="modal-list" id="notesList"></div>

        <div class="modal-actions">
          <button class="w-btn" id="insertNotesBtn" type="button">Вставить</button>
          <button class="w-btn w-btn--primary" id="speakNotesBtn" type="button">Вставить и озвучить</button>
        </div>

        <div class="w-hint" style="margin-top:8px">
          Важно: заметки берутся из onoi_notes (IndexedDB). Если ты включил Cloud Sync в заметках, тут тоже будет доступна та же база (на этом же домене).
        </div>
      </div>
    </div>
  </div>

  <style>
    /* modal styles for whisperer */
    .modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.25);
      display: none;
      z-index: 999999;
      padding: 16px;
    }
    .modal.is-open{ display: grid; place-items: center; }
    .modal-card{
      width: min(860px, calc(100% - 8px));
      max-height: calc(100vh - 40px);
      overflow: auto;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.96);
      padding: 14px;
      border-radius: 0;
    }
    .modal-head{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: start;
      margin-bottom: 10px;
    }
    .modal-grid{ display: grid; gap: 10px; }
    .modal-input{
      width: 100%;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
    }
    .modal-list{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.90);
      padding: 8px;
      display: grid;
      gap: 8px;
      max-height: 46vh;
      overflow: auto;
    }
    .m-row{
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.80);
      padding: 10px;
      display: grid;
      gap: 6px;
      cursor: pointer;
    }
    .m-row:hover{ border-color: rgba(0,0,0,.26); }
    .m-row__top{
      display: grid;
      grid-template-columns: 18px 1fr auto;
      gap: 8px;
      align-items: center;
      min-width: 0;
    }
    .m-title{
      margin: 0;
      font-size: 11px;
      letter-spacing: 2px;
      text-transform: uppercase;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .m-meta{
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: rgba(0,0,0,.55);
      white-space: nowrap;
    }
    .m-snippet{
      margin: 0;
      font-size: 11px;
      line-height: 1.4;
      color: rgba(0,0,0,.72);
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      word-break: break-word;
    }
    .modal-actions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 520px){
      .modal-actions{ grid-template-columns: 1fr; }
    }
  
    
    /* FOLLOW: Windows-style maximize/restore button + fullscreen mode */
    .w-reader-head{
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .w-reader-head .w-label{
      margin: 0;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .w-winbtn{
      width: 38px;
      height: 28px;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.90);
      cursor: pointer;
      display: grid;
      place-items: center;
      padding: 0;
      border-radius: 0;
      transition: transform .12s ease, border-color .18s ease, opacity .18s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      flex: none;
    }
    .w-winbtn:hover{ transform: translateY(-1px); border-color: rgba(0,0,0,.30); opacity: .98; }
    .w-winbtn:active{ transform: translateY(0); }
    .w-winbtn:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }

    .w-winbtn .ico{
      position: relative;
      width: 14px;
      height: 12px;
    }
    .w-winbtn .ico::before{
      content: "";
      position: absolute;
      inset: 0;
      border: 1px solid rgba(0,0,0,.78);
      background: transparent;
    }
    /* restore icon when expanded */
    .w-winbtn.is-on .ico::after{
      content: "";
      position: absolute;
      left: 3px;
      top: -3px;
      width: 14px;
      height: 12px;
      border: 1px solid rgba(0,0,0,.78);
      background: transparent;
    }

    .follow-scrim{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.25);
      z-index: 89999;
      display: none;
    }
    .follow-scrim.is-on{ display: block; }

    .w-reader.is-full{
      position: fixed;
      left: 12px;
      right: 12px;
      top: calc(var(--topbarOffset) + var(--floatH) + 18px);
      bottom: calc(var(--footerH) + 16px + env(safe-area-inset-bottom));
      z-index: 90000;
      width: auto;
      max-width: none;
      margin: 0;
      background: rgba(255,255,255,.98);
      box-shadow: 0 14px 34px rgba(0,0,0,.12);
      overflow: hidden;
    }
    .w-reader.is-full .w-reader-head{
      position: sticky;
      top: 0;
      z-index: 2;
      background: rgba(255,255,255,.98);
      padding-bottom: 10px;
      margin-bottom: 6px;
      border-bottom: 1px dashed rgba(0,0,0,.14);
    }
    .w-reader.is-full .w-display{
      height: 100%;
      max-height: none;
      overflow: auto;
    }

    @media (max-width: 520px){
      .w-reader.is-full{
        left: 10px;
        right: 10px;
        top: calc(var(--topbarOffset) + 4px);
      }
    }

</style>

  <script src="../../assets/js/main.js"></script>

  <script>
    (function(){
      const hasSpeech = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
      const supportBox = document.getElementById('supportBox');
      if(!hasSpeech){
        supportBox.hidden = false;
        return;
      }

      // Elements
      const textInput = document.getElementById('textInput');
      const display = document.getElementById('display');

      const fontRange = document.getElementById('fontRange');
      const fontVal = document.getElementById('fontVal');
      const langPill = document.getElementById('langPill');

      const prepBtn = document.getElementById('prepBtn');
      const clearBtn = document.getElementById('clearBtn');

      // Notes bridge
      const fromNotesBtn = document.getElementById('fromNotesBtn');

      const notesModal = document.getElementById('notesModal');
      const closeNotesModal = document.getElementById('closeNotesModal');
      const notesSearch = document.getElementById('notesSearch');
      const notesListEl = document.getElementById('notesList');
      const insertNotesBtn = document.getElementById('insertNotesBtn');
      const speakNotesBtn = document.getElementById('speakNotesBtn');

      const NOTES_DB = 'itemkey_onoi_notes_db_v1'; // must match onoi_notes
      const NOTES_STORE = 'notes';
      const CATS_STORE = 'cats';

      function openModal(){
        notesModal.classList.add('is-open');
        notesSearch.value = '';
        renderNotesPicker('');
        notesSearch.focus();
      }
      function closeModal(){
        notesModal.classList.remove('is-open');
      }

      function htmlToText(html){
        const d = document.createElement('div');
        d.innerHTML = html || '';
        return (d.textContent || '').replace(/\s+/g,' ').trim();
      }

      function fmtTime(ts){
        if(!ts) return '—';
        const d = new Date(ts);
        const z = (n) => String(n).padStart(2,'0');
        return z(d.getDate())+'.'+z(d.getMonth()+1)+'.'+d.getFullYear()+' '+z(d.getHours())+':'+z(d.getMinutes());
      }

      function idbOpenNotes(){
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(NOTES_DB);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      function idbGetAll(db, storeName){
        return new Promise((resolve, reject) => {
          const tx = db.transaction([storeName], 'readonly');
          const st = tx.objectStore(storeName);
          const r = st.getAll();
          r.onsuccess = () => resolve(r.result || []);
          r.onerror = () => reject(r.error);
        });
      }

      let pickerCache = { notes: [], cats: [] };

      async function loadNotesCache(){
        try{
          const db = await idbOpenNotes();
          const [notes, cats] = await Promise.all([
            idbGetAll(db, NOTES_STORE),
            idbGetAll(db, CATS_STORE).catch(()=>[])
          ]);
          db.close();
          pickerCache.notes = Array.isArray(notes) ? notes : [];
          pickerCache.cats = Array.isArray(cats) ? cats : [];
        }catch(e){
          pickerCache.notes = [];
          pickerCache.cats = [];
        }
      }

      function catName(id){
        const c = (pickerCache.cats || []).find(x => x.id === id);
        return c ? (c.name || '—') : '—';
      }

      function renderNotesPicker(q){
        const query = (q || '').trim().toLowerCase();
        const notes = (pickerCache.notes || [])
          .slice()
          .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0))
          .filter(n => {
            if(!query) return true;
            const t = (n.title || '').toLowerCase();
            const b = htmlToText(n.html || '').toLowerCase();
            return t.includes(query) || b.includes(query);
          });

        notesListEl.innerHTML = '';

        if(!notes.length){
          const p = document.createElement('div');
          p.className = 'w-hint';
          p.textContent = 'Заметок не найдено. Открой onoi_notes и создай заметки.';
          notesListEl.appendChild(p);
          return;
        }

        notes.forEach(n => {
          const row = document.createElement('div');
          row.className = 'm-row';
          row.dataset.id = n.id;

          const top = document.createElement('div');
          top.className = 'm-row__top';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.style.width = '16px';
          cb.style.height = '16px';

          const title = document.createElement('p');
          title.className = 'm-title';
          title.textContent = (n.title || 'без названия');

          const meta = document.createElement('div');
          meta.className = 'm-meta';
          meta.textContent = catName(n.catId) + ' · ' + fmtTime(n.updatedAt);

          const sn = document.createElement('p');
          sn.className = 'm-snippet';
          sn.textContent = htmlToText(n.html || '') || '…';

          top.appendChild(cb);
          top.appendChild(title);
          top.appendChild(meta);

          row.appendChild(top);
          row.appendChild(sn);

          row.addEventListener('click', (e) => {
            if(e.target && e.target.tagName && e.target.tagName.toLowerCase() === 'input') return;
            cb.checked = !cb.checked;
          });

          notesListEl.appendChild(row);
        });
      }

      function selectedNoteIds(){
        const ids = [];
        notesListEl.querySelectorAll('.m-row').forEach(row => {
          const cb = row.querySelector('input[type="checkbox"]');
          if(cb && cb.checked) ids.push(row.dataset.id);
        });
        return ids;
      }

      function buildTextFromSelected(){
        const ids = new Set(selectedNoteIds());
        const selected = (pickerCache.notes || []).filter(n => ids.has(n.id))
          .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0));

        const parts = selected.map(n => {
          const title = (n.title || '').trim();
          const body = htmlToText(n.html || '');
          return (title ? (title + '\n') : '') + body;
        });

        return parts.join('\n\n———\n\n').trim();
      }

      async function openNotesPicker(){
        await loadNotesCache();
        openModal();
      }


      const speakBtn = document.getElementById('speakBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stopBtn = document.getElementById('stopBtn');

      const voiceEnSelect = document.getElementById('voiceEnSelect');
      const voiceRuSelect = document.getElementById('voiceRuSelect');
      // Narrator (TTS) controls
      const rateRange = document.getElementById('rateRange');
      const pitchRange = document.getElementById('pitchRange');
      const volRange = document.getElementById('volRange');
      const wordGapRange = document.getElementById('wordGapRange');
      const sentGapRange = document.getElementById('sentGapRange');
      const paraGapRange = document.getElementById('paraGapRange');
      const chunkMode = document.getElementById('chunkMode');
      const punctPause = document.getElementById('punctPause');
      const delayScaleRange = document.getElementById('delayScaleRange');

      const rateVal = document.getElementById('rateVal');
      const pitchVal = document.getElementById('pitchVal');
      const volPill = document.getElementById('volPill');
      const wordGapVal = document.getElementById('wordGapVal');
      const sentGapPill = document.getElementById('sentGapPill');
      const paraGapVal = document.getElementById('paraGapVal');
      const delayScaleVal = document.getElementById('delayScaleVal');
      const chunkVal = document.getElementById('chunkVal');
      const punctPill = document.getElementById('punctPill');


      const modePill = document.getElementById('modePill');
      const posPill = document.getElementById('posPill');

      const footer = document.querySelector('.bottombar');
      const floatbar = document.getElementById('floatbar');

      // Follow fullscreen (maximize/restore)
      const followCard = document.getElementById('followCard');
      const followFullBtn = document.getElementById('followFullBtn');
      const followScrim = document.getElementById('followScrim');

      function setFollowFull(on){
        if(!followCard || !followFullBtn) return;
        const next = !!on;

        followCard.classList.toggle('is-full', next);
        followFullBtn.classList.toggle('is-on', next);
        followFullBtn.setAttribute('aria-pressed', next ? 'true' : 'false');
        followFullBtn.setAttribute('aria-label', next ? 'Свернуть FOLLOW' : 'Развернуть FOLLOW');
        followFullBtn.title = next ? 'Свернуть FOLLOW' : 'Развернуть FOLLOW';

        if(followScrim){
          followScrim.classList.toggle('is-on', next);
          followScrim.hidden = !next;
        }

        // Ensure bottom spacing stays correct (layout changes in fullscreen mode)
        if(typeof measureBottom === 'function') measureBottom();
      }

      function toggleFollowFull(){
        if(!followCard) return;
        setFollowFull(!followCard.classList.contains('is-full'));
      }

      if(followFullBtn){
        followFullBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleFollowFull();
        }, {capture:true});
      }
      if(followScrim){
        followScrim.addEventListener('click', () => setFollowFull(false));
      }

      // Persisted settings
      const LS = {
        fontSize: 'whisperer_font_size_v2',
        voiceEn: 'whisperer_voice_en_v2',
        voiceRu: 'whisperer_voice_ru_v2',

        // Narrator (TTS)
        rate: 'whisperer_rate_v1',
        pitch: 'whisperer_pitch_v1',
        volume: 'whisperer_volume_v1',
        wordGap: 'whisperer_word_gap_v1',
        sentGap: 'whisperer_sentence_gap_v1',
        paraGap: 'whisperer_paragraph_gap_v1',
        delayScale: 'whisperer_delay_scale_v1',
        chunkMode: 'whisperer_chunk_mode_v1',
        punctPause: 'whisperer_punct_pause_v1'
      };

      function saveSetting(key, value){
        try{ localStorage.setItem(key, value); } catch(e){}
      }
      function loadSetting(key){
        try{ return localStorage.getItem(key); } catch(e){ return null; }
      }

      // Layout: measure footer + floatbar height to prevent overlap
      function measureBottom(){
        const fh = footer ? footer.getBoundingClientRect().height : 56;
        const bh = floatbar ? floatbar.getBoundingClientRect().height : 60;
        document.documentElement.style.setProperty('--footerH', Math.ceil(fh) + 'px');
        document.documentElement.style.setProperty('--floatH', Math.ceil(bh) + 'px');
      }
      measureBottom();
      window.addEventListener('resize', measureBottom);

      // Typography
      function applyFontSize(px){
        const v = Math.min(30, Math.max(12, Number(px) || 16));
        document.documentElement.style.setProperty('--w-font-size', v + 'px');
        fontVal.textContent = v + 'px';
        fontRange.value = String(v);
        saveSetting(LS.fontSize, String(v));
        // Re-measure (font size can change footer wrapping on some screens)
        measureBottom();
      }
      const savedFont = loadSetting(LS.fontSize);
      applyFontSize(savedFont ? Number(savedFont) : Number(fontRange.value));
      fontRange.addEventListener('input', () => applyFontSize(fontRange.value));

      // ==========================
      // Narrator (TTS) preferences
      // ==========================
      const TTS_DEFAULTS = {
        rate: 1.0,
        pitch: 1.0,
        volume: 1.0,
        wordGap: 0,     // ms
        sentGap: 250,   // ms
        paraGap: 600,   // ms
        delayScale: 1.0, // multiplier for all gaps (for ultra-slow playback)
        chunkMode: 'auto',   // auto | phrase | word
        punctPause: true
      };

      const tts = { ...TTS_DEFAULTS };

      function clamp(n, a, b){
        n = Number(n);
        if(Number.isNaN(n)) return a;
        return Math.min(b, Math.max(a, n));
      }

      function fmt2(n){ return (Math.round(n*100)/100).toFixed(2); }

      function updateTtsUI(){
        if(rateVal) rateVal.textContent = fmt2(tts.rate) + '×';
        if(pitchVal) pitchVal.textContent = fmt2(tts.pitch);
        if(volPill) volPill.textContent = 'vol: ' + fmt2(tts.volume);

        if(wordGapVal) wordGapVal.textContent = String(Math.round(tts.wordGap)) + 'ms';
        if(sentGapPill) sentGapPill.textContent = 'sentence: ' + String(Math.round(tts.sentGap)) + 'ms';
        if(paraGapVal) paraGapVal.textContent = String(Math.round(tts.paraGap)) + 'ms';
        if(delayScaleVal) delayScaleVal.textContent = 'slow: ' + (Math.round(tts.delayScale*10)/10).toFixed(1) + '×';

        // Effective mode (auto can resolve to segment/phrase)
        const effective = getEffectiveChunkMode();
        if(chunkVal) chunkVal.textContent = 'chunk: ' + effective;

        if(punctPill) punctPill.textContent = 'punct: ' + (tts.punctPause ? 'on' : 'off');
      }

      function saveTts(){
        saveSetting(LS.rate, String(tts.rate));
        saveSetting(LS.pitch, String(tts.pitch));
        saveSetting(LS.volume, String(tts.volume));
        saveSetting(LS.wordGap, String(tts.wordGap));
        saveSetting(LS.sentGap, String(tts.sentGap));
        saveSetting(LS.paraGap, String(tts.paraGap));
        saveSetting(LS.delayScale, String(tts.delayScale));
        saveSetting(LS.chunkMode, String(tts.chunkMode));
        saveSetting(LS.punctPause, tts.punctPause ? '1' : '0');
      }

      function loadTts(){
        const r = loadSetting(LS.rate);
        const p = loadSetting(LS.pitch);
        const v = loadSetting(LS.volume);
        const wg = loadSetting(LS.wordGap);
        const sg = loadSetting(LS.sentGap);
        const pg = loadSetting(LS.paraGap);
        const cm = loadSetting(LS.chunkMode);
        const ds = loadSetting(LS.delayScale);
        const pp = loadSetting(LS.punctPause);

        tts.rate = clamp(r != null ? r : TTS_DEFAULTS.rate, 0.10, 3.00);
        tts.pitch = clamp(p != null ? p : TTS_DEFAULTS.pitch, 0.0, 2.0);
        tts.volume = clamp(v != null ? v : TTS_DEFAULTS.volume, 0.0, 1.0);

        tts.wordGap = clamp(wg != null ? wg : TTS_DEFAULTS.wordGap, 0, 4000);
        tts.sentGap = clamp(sg != null ? sg : TTS_DEFAULTS.sentGap, 0, 20000);
        tts.paraGap = clamp(pg != null ? pg : TTS_DEFAULTS.paraGap, 0, 60000);
        tts.delayScale = clamp(ds != null ? ds : TTS_DEFAULTS.delayScale, 1.0, 12.0);

        tts.chunkMode = (cm === 'word' || cm === 'phrase' || cm === 'auto') ? cm : TTS_DEFAULTS.chunkMode;
        tts.punctPause = (pp == null) ? TTS_DEFAULTS.punctPause : (String(pp) !== '0');

        // reflect in controls
        if(rateRange) rateRange.value = String(tts.rate);
        if(pitchRange) pitchRange.value = String(tts.pitch);
        if(volRange) volRange.value = String(tts.volume);
        if(wordGapRange) wordGapRange.value = String(tts.wordGap);
        if(sentGapRange) sentGapRange.value = String(tts.sentGap);
        if(paraGapRange) paraGapRange.value = String(tts.paraGap);
        if(delayScaleRange) delayScaleRange.value = String(tts.delayScale);
        if(chunkMode) chunkMode.value = String(tts.chunkMode);
        if(punctPause) punctPause.checked = !!tts.punctPause;

        updateTtsUI();
      }

      function getEffectiveChunkMode(){
        // "auto": smooth segments if gaps are 0; otherwise phrase mode.
        if(tts.chunkMode === 'word') return 'word';
        if(tts.chunkMode === 'phrase') return 'phrase';
        const hasAnyGaps = (tts.wordGap > 0) || (tts.sentGap > 0) || (tts.paraGap > 0);
        return hasAnyGaps ? 'phrase' : 'auto';
      }

      function onTtsChanged(){
        // Clamp and persist
        tts.rate = clamp(rateRange ? rateRange.value : tts.rate, 0.10, 3.00);
        tts.pitch = clamp(pitchRange ? pitchRange.value : tts.pitch, 0.0, 2.0);
        tts.volume = clamp(volRange ? volRange.value : tts.volume, 0.0, 1.0);

        tts.wordGap = clamp(wordGapRange ? wordGapRange.value : tts.wordGap, 0, 4000);
        tts.sentGap = clamp(sentGapRange ? sentGapRange.value : tts.sentGap, 0, 20000);
        tts.paraGap = clamp(paraGapRange ? paraGapRange.value : tts.paraGap, 0, 60000);
        tts.delayScale = clamp(delayScaleRange ? delayScaleRange.value : tts.delayScale, 1.0, 12.0);

        tts.chunkMode = chunkMode ? chunkMode.value : tts.chunkMode;
        tts.punctPause = punctPause ? !!punctPause.checked : tts.punctPause;

        saveTts();
        updateTtsUI();
      }

      // Wire controls
      [rateRange, pitchRange, volRange, wordGapRange, sentGapRange, paraGapRange, delayScaleRange].forEach(el => {
        if(!el) return;
        el.addEventListener('input', onTtsChanged);
        el.addEventListener('change', onTtsChanged);
      });
      if(chunkMode){
        chunkMode.addEventListener('change', onTtsChanged);
      }
      if(punctPause){
        punctPause.addEventListener('change', onTtsChanged);
      }

      loadTts();


      // Text parsing / display
      let words = [];         // word tokens only
      let trails = [];        // trailing whitespace after each word
      let wordSpans = [];
      let wordLang = [];      // "en" | "ru"
      let activeWordIndex = -1;
      let preparedText = '';

      function normalizeText(t){
        return (t || '')
          .replace(/\r\n/g, '\n')
          .replace(/\r/g, '\n')
          .replace(/\u00A0/g, ' ');
      }

      function preprocessForSpeech(raw){
        let t = normalizeText(raw);

        // Fix glued punctuation: add a space after punctuation when followed immediately by a LETTER (RU/EN).
        // This keeps decimals/version numbers intact (e.g., 3.14, v2.0).
        t = t.replace(/([.!?…]+["'”’»)\]\}]+)(?=[A-Za-zА-Яа-яЁё])/g, '$1 ');
        t = t.replace(/([.!?…]+)(?=[A-Za-zА-Яа-яЁё])/g, '$1 ');
        t = t.replace(/([,;:]+["'”’»)\]\}]+)(?=[A-Za-zА-Яа-яЁё])/g, '$1 ');
        t = t.replace(/([,;:]+)(?=[A-Za-zА-Яа-яЁё])/g, '$1 ');
        t = t.replace(/([—–])(?=[A-Za-zА-Яа-яЁё])/g, '$1 ');

        return t;
      }

      function detectLangForWord(w, fallback){
        // If contains Cyrillic => ru, if contains Latin => en, else fallback
        const hasCyr = /[\u0400-\u04FF]/.test(w);
        const hasLat = /[A-Za-z]/.test(w);
        if(hasCyr && !hasLat) return 'ru';
        if(hasLat && !hasCyr) return 'en';
        if(hasCyr && hasLat) return 'en'; // mixed token: treat as EN by default
        return fallback || 'en';
      }

      function setWordIndex(i){
        activeWordIndex = i;
        posPill.textContent = (i >= 0) ? ('word: ' + (i+1) + '/' + words.length) : 'word: —';
        for(let k=0;k<wordSpans.length;k++){
          wordSpans[k].classList.toggle('is-active', k === i);
        }
        const sp = wordSpans[i];
        if(sp){
          sp.scrollIntoView({block: 'center', inline: 'nearest', behavior: 'smooth'});
        }
      }

      function buildDisplay(){
        preparedText = preprocessForSpeech(textInput.value);
        const text = preparedText;
        display.innerHTML = '';
        words = [];
        trails = [];
        wordSpans = [];
        wordLang = [];
        setWordIndex(-1);

        if(!text.trim()){
          langPill.textContent = 'lang: auto';
          return;
        }

        const tokens = text.match(/\S+|\s+/g) || [];
        // First pass: create spans for words, preserve whitespace as text nodes
        for(let i=0;i<tokens.length;i++){
          const tok = tokens[i];
          if(/^\s+$/.test(tok)){
            display.appendChild(document.createTextNode(tok));
          } else {
            const span = document.createElement('span');
            span.className = 'w-word';
            span.textContent = tok;
            span.dataset.index = String(words.length);
            display.appendChild(span);

            wordSpans.push(span);
            words.push(tok);

            // trailing whitespace (if any)
            const next = tokens[i+1];
            trails.push((next && /^\s+$/.test(next)) ? next : '');
          }
        }

        // Language per word (script-based, with fallback chaining)
        let prev = 'en';
        for(let i=0;i<words.length;i++){
          const l = detectLangForWord(words[i], prev);
          wordLang.push(l);
          prev = l;
        }

        // Update language pill summary
        const hasRu = wordLang.includes('ru');
        const hasEn = wordLang.includes('en');
        langPill.textContent = hasRu && hasEn ? 'lang: auto (EN+RU)' : (hasRu ? 'lang: auto (RU)' : 'lang: auto (EN)');
      }

      // Build display live (debounced)
      let buildTimer = null;
      function scheduleBuild(){
        if(buildTimer) clearTimeout(buildTimer);
        buildTimer = setTimeout(() => { buildDisplay(); }, 120);
      }
      textInput.addEventListener('input', scheduleBuild);
      prepBtn.addEventListener('click', buildDisplay);

      // Voices
      let voices = [];
      function getVoices(){
        voices = window.speechSynthesis.getVoices() || [];
        return voices;
      }

      function populateVoiceSelect(selectEl, langPrefix){
        const saved = loadSetting(selectEl === voiceEnSelect ? LS.voiceEn : LS.voiceRu);
        const previous = selectEl.value;

        // Keep the first "Auto" option
        const autoOpt = selectEl.querySelector('option[value="__auto__"]');
        selectEl.innerHTML = '';
        const first = document.createElement('option');
        first.value = '__auto__';
        first.textContent = 'Auto';
        selectEl.appendChild(first);

        const list = (voices || []).filter(v => (v.lang || '').toLowerCase().startsWith(langPrefix));
        list.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.name;
          opt.textContent = v.name + (v.default ? ' (default)' : '');
          selectEl.appendChild(opt);
        });

        // restore selection
        if(saved && [...selectEl.options].some(o => o.value === saved)){
          selectEl.value = saved;
        } else if(previous && [...selectEl.options].some(o => o.value === previous)){
          selectEl.value = previous;
        } else {
          selectEl.value = '__auto__';
        }
      }

      function bestVoiceFor(lang){
        const prefix = lang === 'ru' ? 'ru' : 'en';
        const selectEl = lang === 'ru' ? voiceRuSelect : voiceEnSelect;
        const forced = selectEl.value;
        if(forced && forced !== '__auto__'){
          return (voices || []).find(v => v.name === forced) || null;
        }

        // Auto: prefer default voice in that language; otherwise first match.
        const list = (voices || []).filter(v => (v.lang || '').toLowerCase().startsWith(prefix));
        const def = list.find(v => v.default);
        return def || list[0] || null;
      }

      function onVoicesChanged(){
        getVoices();
        populateVoiceSelect(voiceEnSelect, 'en');
        populateVoiceSelect(voiceRuSelect, 'ru');
      }

      window.speechSynthesis.onvoiceschanged = onVoicesChanged;
      onVoicesChanged();

      voiceEnSelect.addEventListener('change', () => saveSetting(LS.voiceEn, voiceEnSelect.value));
      voiceRuSelect.addEventListener('change', () => saveSetting(LS.voiceRu, voiceRuSelect.value));

      // Speech queue (supports mixed EN/RU)
      let mode = 'idle'; // idle | speaking | paused
      let cancelled = false;

      // Unified queue of utterances (segments / phrases / words)
      let queue = []; // [{text, lang, wordIndices, wordStarts, delayAfter}]
      let qIdx = 0;

      let betweenTimer = null;
      let betweenDueAt = 0;
      let waitingBetween = false;
      let waitingDelay = 0;

      function clearBetween(){
        if(betweenTimer){
          try{ clearTimeout(betweenTimer); } catch(e){}
          betweenTimer = null;
        }
        betweenDueAt = 0;
        waitingBetween = false;
        waitingDelay = 0;
      }

      function setMode(next){
        mode = next;
        modePill.textContent = 'mode: ' + mode;

        const idle = (mode === 'idle');
        const paused = (mode === 'paused');

        speakBtn.disabled = !idle;
        pauseBtn.disabled = idle;
        stopBtn.disabled = idle;

        pauseBtn.textContent = paused ? 'Продолжить' : 'Пауза';
      }

      function stopAll(){
        cancelled = true;
        queue = [];
        qIdx = 0;
        clearBetween();
        try{ window.speechSynthesis.cancel(); } catch(e){}
        setMode('idle');
        setWordIndex(-1);
      }

      // --------------------------
      // Queue builders
      // --------------------------
      function stripTrailingClosers(word){
        const w = String(word || '').trim();
        // Remove trailing closing quotes/brackets so we can correctly detect punctuation like: "."" or ".»"
        return w.replace(/[\)\]\}"'»”’]+$/g, '');
      }

      function countNewlines(trail){
        const t = String(trail || '');
        const m = t.match(/\n/g);
        return m ? m.length : 0;
      }

      function isParagraphBreak(trail){
        return countNewlines(trail) >= 2;
      }

      function isLineBreak(trail){
        return countNewlines(trail) >= 1;
      }

      const ABBR_SET = new Set([
        'т.д.','т.п.','т.е.','т.к.','г.','ул.','д.','стр.','рис.','см.','др.','им.',
        'etc.','e.g.','i.e.','mr.','mrs.','ms.','dr.','prof.','sr.','jr.'
      ]);

      function isAbbrev(token){
        const lc = String(token || '').toLowerCase();
        if(ABBR_SET.has(lc)) return true;
        // Patterns like "т.д." or "U.S." or "U.S.A."
        if(/^(?:[a-zа-яё]\.){1,6}$/i.test(lc)) return true;
        if(/^(?:[a-z]\.){2,6}$/i.test(lc)) return true;
        return false;
      }

      function sentenceStrength(word, nextWord){
        const cleaned = stripTrailingClosers(word);
        if(!cleaned) return 'none';

        // Hard sentence end: ?, !, … (incl. combos like "?!")
        if(/[!?…]+$/.test(cleaned)) return 'hard';

        // Period end:
        if(/[.]+$/.test(cleaned)){
          // Ellipsis "..." treated as hard.
          if(/\.\.\.$/.test(cleaned)) return 'hard';

          if(isAbbrev(cleaned)){
            // If next token starts with a lowercase letter, assume abbreviation inside sentence.
            const nw = String(nextWord || '').trim();
            if(nw && /^[A-Za-zА-Яа-яЁё]/.test(nw)){
              const ch = nw[0];
              if(ch === ch.toLowerCase()) return 'soft';
            }
          }
          return 'hard';
        }

        return 'none';
      }

      function hasSoftPunct(word){
        const cleaned = stripTrailingClosers(word);
        if(!cleaned) return false;
        return /[,;:]+$/.test(cleaned) || /[—–]+$/.test(cleaned);
      }

      function softGapMs(){
        const base = Math.round((Number(tts.sentGap) || 0) * 0.35);
        return Math.min(450, Math.max(80, base));
      }

      function buildSegments(fromIndex){
        const start = Math.max(0, Math.min(Number(fromIndex) || 0, Math.max(0, words.length - 1)));
        const maxWords = 18;
        const maxChars = 220;

        const out = [];
        let cur = null;

        function pushCur(){
          if(cur && cur.text.trim()){
            cur.delayAfter = 0;
            out.push(cur);
          }
          cur = null;
        }

        for(let i=start;i<words.length;i++){
          const wl = wordLang[i] || 'en';
          const w = words[i];
          const t = trails[i] || '';
          const nextW = words[i+1] || '';

          if(!cur){
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          const nextText = cur.text + w + t;
          const wouldExceed = (cur.wordIndices.length >= maxWords) || (nextText.length > maxChars);
          const langSplit = (wl !== cur.lang);

          if(langSplit || wouldExceed){
            pushCur();
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          cur.wordStarts.push(cur.text.length);
          cur.wordIndices.push(i);
          cur.text += w + t;

          const nl = countNewlines(t);
          const para = nl >= 2;
          const line = nl >= 1;
          const strength = sentenceStrength(w, nextW);

          // Even in "smooth" mode, split on real boundaries so engines don't smear punctuation.
          if(para || line || strength === 'hard'){
            pushCur();
          }
        }

        pushCur();
        return out;
      }

      function buildPhrases(fromIndex){
        const start = Math.max(0, Math.min(Number(fromIndex) || 0, Math.max(0, words.length - 1)));
        const maxWords = 14;
        const maxChars = 260;

        const out = [];
        let cur = null;

        function pushCur(delayAfter){
          if(cur && cur.text.trim()){
            cur.delayAfter = Math.max(0, Number(delayAfter) || 0);
            out.push(cur);
          }
          cur = null;
        }

        for(let i=start;i<words.length;i++){
          const wl = wordLang[i] || 'en';
          const w = words[i];
          const t = trails[i] || '';
          const nextW = words[i+1] || '';

          if(!cur){
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          // split by language to keep voices consistent
          const wouldExceed = (cur.wordIndices.length >= maxWords) || ((cur.text + w + t).length > maxChars);
          const langSplit = (wl !== cur.lang);

          if(langSplit || wouldExceed){
            pushCur(0);
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          cur.wordStarts.push(cur.text.length);
          cur.wordIndices.push(i);
          cur.text += w + t;

          const nl = countNewlines(t);
          const para = nl >= 2;
          const line = nl >= 1;
          const strength = sentenceStrength(w, nextW);

          // Optional: split on commas/colons/dashes if the phrase becomes too long.
          const allowSoftSplit = tts.punctPause && hasSoftPunct(w) && !para && !line && strength === 'none' &&
            ((cur.wordIndices.length >= 10) || (cur.text.length >= 180));

          let add = 0;
          if(para){
            add = tts.paraGap;
          } else if(line){
            // Line break without punctuation should still behave like a sentence boundary.
            add = tts.sentGap;
          } else if(strength === 'hard'){
            add = tts.punctPause ? tts.sentGap : 0;
          } else if(strength === 'soft'){
            add = tts.punctPause ? softGapMs() : 0;
          } else if(allowSoftSplit){
            add = softGapMs();
          }

          // Always split on sentence/line/paragraph boundaries (even if add=0)
          if(para || line || strength !== 'none' || allowSoftSplit){
            const delay = ((tts.wordGap || 0) + add) * (tts.delayScale || 1);
            pushCur(delay);
          }
        }

        // tail
        if(cur){
          pushCur(0);
        }
        return out;
      }

      function buildWordsQueue(fromIndex){
        const start = Math.max(0, Math.min(Number(fromIndex) || 0, Math.max(0, words.length - 1)));
        const out = [];

        for(let i=start;i<words.length;i++){
          const wl = wordLang[i] || 'en';
          const w = words[i];
          const t = trails[i] || '';
          const nextW = words[i+1] || '';

          const nl = countNewlines(t);
          const para = nl >= 2;
          const line = nl >= 1;
          const strength = sentenceStrength(w, nextW);

          let add = 0;
          if(para){
            add = tts.paraGap;
          } else if(line){
            add = tts.sentGap;
          } else if(strength === 'hard'){
            add = tts.punctPause ? tts.sentGap : 0;
          } else if(strength === 'soft'){
            add = tts.punctPause ? softGapMs() : 0;
          }

          const delayAfter = ((tts.wordGap || 0) + add) * (tts.delayScale || 1);

          out.push({
            text: w + t,
            lang: wl,
            wordIndices: [i],
            wordStarts: [0],
            delayAfter: delayAfter
          });
        }
        return out;
      }

      function buildQueue(fromIndex){
        const effective = getEffectiveChunkMode();

        // If the user wants any pauses, "auto" resolves to phrases for better control
        if(effective === 'word'){
          return buildWordsQueue(fromIndex);
        }
        if(effective === 'phrase'){
          return buildPhrases(fromIndex);
        }
        // Smooth mode: classic segments, minimal gaps
        return buildSegments(fromIndex);
      }

      // --------------------------
      // Playback engine
      // --------------------------
      function applyUtteranceSettings(u){
        u.rate = clamp(tts.rate, 0.10, 3.00);
        u.pitch = clamp(tts.pitch, 0.0, 2.0);
        u.volume = clamp(tts.volume, 0.0, 1.0);
      }

      function scheduleNextAfter(delay){
        clearBetween();
        const d = Math.max(0, Number(delay) || 0);

        if(d <= 0){
          // Microtask-like scheduling to avoid deep recursion
          setTimeout(() => { if(!cancelled) speakNext(); }, 0);
          return;
        }

        if(mode === 'paused'){
          waitingBetween = true;
          waitingDelay = d;
          return;
        }

        betweenDueAt = Date.now() + d;
        betweenTimer = setTimeout(() => {
          betweenTimer = null;
          betweenDueAt = 0;
          if(cancelled) return;
          speakNext();
        }, d);
      }

      function speakNext(){
        if(cancelled) return;

        if(qIdx >= queue.length){
          setMode('idle');
          setWordIndex(-1);
          return;
        }

        const unit = queue[qIdx];
        const u = new SpeechSynthesisUtterance(unit.text);

        u.lang = (unit.lang === 'ru') ? 'ru-RU' : 'en-US';
        const v = bestVoiceFor(unit.lang);
        if(v) u.voice = v;

        applyUtteranceSettings(u);

        // Set initial highlight
        const firstIdx = (unit.wordIndices && unit.wordIndices.length) ? unit.wordIndices[0] : -1;
        if(firstIdx >= 0) setWordIndex(firstIdx);

        // Boundary highlighting (best effort; varies by engine)
        if(unit.wordStarts && unit.wordStarts.length > 1){
          u.onboundary = function(ev){
            if(typeof ev.charIndex !== 'number') return;
            const ci = ev.charIndex;

            let local = -1;
            for(let j=0;j<unit.wordStarts.length;j++){
              if(unit.wordStarts[j] <= ci) local = j;
              else break;
            }
            if(local >= 0){
              const globalIndex = unit.wordIndices[local];
              setWordIndex(globalIndex);
            }
          };
        }

        u.onend = function(){
          if(cancelled) return;
          qIdx += 1;
          scheduleNextAfter(unit.delayAfter || 0);
        };

        u.onerror = function(){
          stopAll();
        };

        setMode('speaking');
        window.speechSynthesis.speak(u);
      }

      function speakFromWordIndex(i){
        buildDisplay(); // ensure words/lang lists exist
        const text = preparedText;
        if(!text.trim() || !words.length) return;

        stopAll();
        cancelled = false;

        queue = buildQueue(i);
        qIdx = 0;

        updateTtsUI();

        // Some engines need a short tick after cancel before speaking again
        setTimeout(() => {
          if(cancelled) return;
          speakNext();
        }, 0);
      }

      function pauseOrResume(){
        if(mode === 'idle') return;

        if(mode === 'speaking'){
          // If we are between units, pause the timer too
          if(betweenTimer){
            const remaining = Math.max(0, betweenDueAt - Date.now());
            clearBetween();
            waitingBetween = true;
            waitingDelay = remaining;
          }

          try{ window.speechSynthesis.pause(); } catch(e){}
          setMode('paused');
          return;
        }

        if(mode === 'paused'){
          try{ window.speechSynthesis.resume(); } catch(e){}
          setMode('speaking');

          if(waitingBetween){
            const d = waitingDelay;
            waitingBetween = false;
            waitingDelay = 0;
            scheduleNextAfter(d);
          }
        }
      }
      // Buttons
      speakBtn.addEventListener('click', () => speakFromWordIndex(0));
      pauseBtn.addEventListener('click', pauseOrResume);
      stopBtn.addEventListener('click', stopAll);

      // Click any word in FOLLOW to start from it
      display.addEventListener('click', (e) => {
        const t = e.target;
        const span = t && t.closest ? t.closest('.w-word') : null;
        if(!span) return;

        const idx = Number(span.dataset.index || 0);
        speakFromWordIndex(idx);
      });

      clearBtn.addEventListener('click', () => {
        stopAll();
        textInput.value = '';
        buildDisplay();
        textInput.focus();
      });

      // Notes picker handlers
      if(fromNotesBtn){
        fromNotesBtn.addEventListener('click', openNotesPicker);
      }
      if(closeNotesModal){
        closeNotesModal.addEventListener('click', closeModal);
      }
      if(notesModal){
        notesModal.addEventListener('click', (e) => { if(e.target === notesModal) closeModal(); });
      }
      if(notesSearch){
        notesSearch.addEventListener('input', () => renderNotesPicker(notesSearch.value));
      }
      if(insertNotesBtn){
        insertNotesBtn.addEventListener('click', () => {
          const t = buildTextFromSelected();
          if(!t){ closeModal(); return; }
          textInput.value = t;
          buildDisplay();
          closeModal();
        });
      }
      if(speakNotesBtn){
        speakNotesBtn.addEventListener('click', () => {
          const t = buildTextFromSelected();
          if(!t){ closeModal(); return; }
          textInput.value = t;
          buildDisplay();
          closeModal();
          speakFromWordIndex(0);
        });
      }

      // Incoming payload from onoi_notes
      // 1) URL param (for short texts)
      try{
        const sp = new URLSearchParams(window.location.search || '');
        const t = sp.get('text');
        if(t){
          textInput.value = String(t);
          buildDisplay();
        }
      }catch(e){}

      // 2) localStorage payload (primary transport)
      try{
        const raw = localStorage.getItem('onoi_whisper_payload_v1');
        if(raw){
          const payload = JSON.parse(raw);
          if(payload && payload.text){
            // Do not override URL param text if it already exists
            if(!textInput.value){
              textInput.value = String(payload.text);
              buildDisplay();
            }
          }
          localStorage.removeItem('onoi_whisper_payload_v1');
        }
      }catch(e){}

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        const inForm = (tag === 'textarea' || tag === 'input' || tag === 'select');

        if(e.key === 'Escape'){
          // First: exit FOLLOW fullscreen if open; second: stop speech.
          try{
            if(followCard && followCard.classList.contains('is-full')){
              setFollowFull(false);
              return;
            }
          }catch(_){}
          stopAll();
          return;
        }

        if(e.code === 'Space' && !inForm){
          if(mode !== 'idle'){
            e.preventDefault();
            pauseOrResume();
          }
          return;
        }

        if(e.ctrlKey && (e.key === 'Enter' || e.code === 'Enter')){
          e.preventDefault();
          if(mode === 'idle') speakFromWordIndex(0);
          return;
        }
      });

      // Init
      buildDisplay();
      setMode('idle');

      // Keep bottom measurements accurate even after fonts load
      window.addEventListener('load', () => {
        measureBottom();
      });

      window.addEventListener('beforeunload', () => {
        try{ window.speechSynthesis.cancel(); } catch(e){}
      });
    })();
  </script>
</body>
</html>
