<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Item Key — whisperer</title>

  <!-- глобальный стиль сайта -->
  <link rel="stylesheet" href="../../assets/css/styles.css" />

  <!-- локальные стили ТОЛЬКО для whisperer -->
  <style>
    .whisperer-wrap, .whisperer-wrap * { box-sizing: border-box; }

    :root{
      --footerH: 56px;      /* measured in JS */
      --floatH: 60px;       /* measured in JS */
      --topbarOffset: 74px; /* safety spacing under header */

      /* typography */
      --w-font-size: 16px;  /* controlled by slider */
      --w-line-height: 1.75;
    }

    /* Keep content clear of fixed header and fixed bottom UI */
    .center-stage{
      padding-top: var(--topbarOffset);
      padding-bottom: calc(var(--footerH) + var(--floatH) + 28px + env(safe-area-inset-bottom));
      overflow-x: hidden;
    }

    .whisperer-wrap{
      width: 100%;
      max-width: 1040px;
      margin: 0 auto;
      display: grid;
      gap: 16px;
      padding: 12px 24px 22px;
      min-width: 0;
    }

    .w-title{
      padding: 6px 0 0;
      text-align: center;
      display: grid;
      gap: 8px;
    }
    .w-title h1{
      margin: 0;
      font-size: 14px;
      letter-spacing: 6px;
      text-transform: uppercase;
    }
    .w-title .sub{
      font-size: 11px;
      letter-spacing: 3.5px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
    }

    .w-grid{
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 0.8fr);
      gap: 16px;
      align-items: start;
    }

    .w-card, .w-reader, .w-warning{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.86);
      padding: 16px;
      border-radius: 0;
      box-shadow: none;
      min-width: 0;
    }

    .w-label{
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
    }

    textarea.w-text{
      width: 100%;
      min-height: 260px;
      resize: vertical;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 12px 12px;
      font-size: var(--w-font-size);
      line-height: var(--w-line-height);
      outline: none;
      border-radius: 0;
    }
    textarea.w-text:focus{ border-color: rgba(0,0,0,.34); }

    .w-controls{ display: grid; gap: 14px; }
    .w-row{ display: grid; gap: 8px; }

    .w-field{ display: grid; gap: 8px; min-width: 0; }

    input[type="range"], select{
      width: 100%;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
    }
    input[type="range"]{ padding: 0 8px; }
    select{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .w-hint{
      font-size: 11px;
      line-height: 1.45;
      color: rgba(0,0,0,.70);
      margin: 0;
    }

    .w-actions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .w-btn{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.90);
      padding: 12px 10px;
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform .18s ease, border-color .18s ease, opacity .18s ease;
      border-radius: 0;
      min-height: 44px;
      line-height: 1.2;
      white-space: normal;
      text-align: center;
    }
    .w-btn:hover{ transform: translateY(-1px); border-color: rgba(0,0,0,.30); opacity: .98; }
    .w-btn:disabled{ opacity: .5; cursor: not-allowed; transform: none; }
    .w-btn:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }

    .w-status{
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 11px;
      color: rgba(0,0,0,.72);
      margin-top: 2px;
    }
    .w-pill{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.82);
      padding: 5px 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 10px;
      color: rgba(0,0,0,.62);
      border-radius: 0;
    }

    details.w-adv{
      border: 1px dashed rgba(0,0,0,.14);
      padding: 10px;
      background: rgba(255,255,255,.70);
    }
    details.w-adv summary{
      cursor: pointer;
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.62);
      user-select: none;
      outline: none;
    }
    details.w-adv[open] summary{ margin-bottom: 10px; }

    .w-reader{
      display: grid;
      gap: 10px;
    }

    .w-display{
      font-size: var(--w-font-size);
      line-height: var(--w-line-height);
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 0;
      padding: 10px 10px;
      border-radius: 0;
      border: 1px dashed rgba(0,0,0,.14);
      background: rgba(255,255,255,.65);
      min-width: 0;
    }

    .w-word{ padding: 0 2px; cursor: pointer; }
    .w-word:hover{ background: rgba(0,0,0,.06); }
    .w-word.is-active{
      text-decoration: underline;
      text-underline-offset: 3px;
      background: rgba(0,0,0,.08);
    }

    .w-warning{
      font-size: 12px;
      line-height: 1.45;
      color: rgba(0,0,0,.72);
    }

    /* Floating transport: ALWAYS visible */
    .w-floatbar{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(var(--footerH) + 10px + env(safe-area-inset-bottom));
      z-index: 99999; /* must stay above footer + overlays */
      display: flex;
      gap: 10px;
      align-items: stretch;
      justify-content: center;
      padding: 10px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(6px);
      min-width: min(720px, calc(100% - 24px));
      pointer-events: auto;
    }
    .w-floatbar .w-btn{
      flex: 1 1 0;
      min-width: 0;
      min-height: 46px;
    }
    .w-btn--primary{
      border-color: rgba(0,0,0,.28);
      font-weight: 700;
      letter-spacing: 4px;
    }

    @media (max-width: 980px){
      :root{ --topbarOffset: 66px; }
      .whisperer-wrap{ padding: 10px 14px 18px; }
      .w-grid{ grid-template-columns: 1fr; }
      textarea.w-text{ min-height: 220px; }
    }
    @media (max-width: 520px){
      .w-floatbar{
        left: 12px;
        right: 12px;
        transform: none;
        min-width: auto;
      }
    }
  </style>
</head>

<body class="page page-crate">
  <!-- фон/рамки — как в item-key -->
  <div class="outer-frame" aria-hidden="true"></div>
  <div class="rays" aria-hidden="true"></div>
  <div class="veil" aria-hidden="true"></div>

  <!-- верхний “герб” -->
  <header class="topbar topbar--edge">
    <a class="toplink" href="../../item-user.html?returnTo=crate/whisperer/whisperer.html" aria-label="Item User">
      <span class="tag">item-user</span>
    </a>
  </header>

  <!-- левый rail -->
  <aside class="rail rail--left" aria-label="Левое меню">
    <a class="rail-link" href="../../index.html">
      <span class="rail-link__title">item-key</span>
      <span class="rail-link__meta">главное меню</span>
    </a>
    <a class="rail-link" href="../../item-crate.html">
      <span class="rail-link__title">item-crate</span>
      <span class="rail-link__meta">назад в хаб</span>
    </a>
  </aside>

  <!-- правый rail -->
  <aside class="rail rail--right" aria-label="Правое меню">
    <a class="rail-link" href="../../item-soft.html">
      <span class="rail-link__title">item-soft</span>
      <span class="rail-link__meta">инструменты / редакторы</span>
    </a>
    <a class="rail-link" href="../../item-security.html">
      <span class="rail-link__title">item-security</span>
      <span class="rail-link__meta">доступ / защита</span>
    </a>
  </aside>

  <main class="center-stage" aria-label="whisperer center">
    <section class="whisperer-wrap" aria-label="whisperer app">
      <div class="w-title">
        <h1>whisperer</h1>
        <div class="sub">прошепчи моё имя, пожалуйста</div>
      </div>

      <div class="w-warning" id="supportBox" hidden>
        Ваш браузер не поддерживает Web Speech API (SpeechSynthesis). Попробуйте Chrome / Edge или обновите браузер.
      </div>

      <div class="w-grid">
        <div class="w-card" aria-label="Ввод текста">
          <div class="w-label">text</div>
          <textarea class="w-text" id="textInput" placeholder="Вставь сюда текст…"></textarea>
          <p class="w-hint">
            Клик по слову в FOLLOW — начать чтение с него. Панель «Озвучить / Пауза / Стоп» всегда видна снизу.
          </p>
        </div>

        <div class="w-card w-controls" aria-label="Настройки">
          <div class="w-label">settings</div>

          <div class="w-row">
            <div class="w-field">
              <div class="w-label">text size</div>
              <input id="fontRange" type="range" min="12" max="30" step="1" value="16" />
              <div class="w-status">
                <span class="w-pill" id="fontVal">16px</span>
                <span class="w-pill" id="langPill">lang: auto</span>
              </div>
            </div>
          </div>

          <div class="w-actions" aria-label="Инструменты">
            <button class="w-btn" id="prepBtn" type="button">Подготовить</button>
            <button class="w-btn" id="clearBtn" type="button">Очистить</button>
          </div>

          <details class="w-adv">
            <summary>advanced</summary>
            <div class="w-row">
              <div class="w-field">
                <div class="w-label">EN voice (optional)</div>
                <select id="voiceEnSelect" aria-label="English voice">
                  <option value="__auto__">Auto</option>
                </select>
              </div>
              <div class="w-field">
                <div class="w-label">RU voice (optional)</div>
                <select id="voiceRuSelect" aria-label="Russian voice">
                  <option value="__auto__">Auto</option>
                </select>
              </div>
              <p class="w-hint">
                Авто-режим сам выбирает язык (EN/RU) по тексту и переключает озвучку. Эти списки — только если хочешь жёстко закрепить голоса.
              </p>
            </div>
          </details>

          <div class="w-status" aria-label="Статус">
            <span class="w-pill" id="modePill">mode: idle</span>
            <span class="w-pill" id="posPill">word: —</span>
          </div>

          <p class="w-hint">
            Горячие клавиши: Ctrl+Enter — озвучить, Space — пауза/продолжить, Esc — стоп.
          </p>
        </div>
      </div>

      <div class="w-reader" aria-label="Текст с подсветкой">
        <div class="w-label">follow</div>
        <p class="w-display" id="display"></p>
      </div>
    </section>
  </main>

  <!-- Floating transport bar (ALWAYS visible) -->
  <div class="w-floatbar" id="floatbar" aria-label="Управление озвучкой">
    <button class="w-btn w-btn--primary" id="speakBtn" type="button">Озвучить</button>
    <button class="w-btn" id="pauseBtn" type="button" disabled>Пауза</button>
    <button class="w-btn" id="stopBtn" type="button" disabled>Стоп</button>
  </div>

  <footer class="bottombar bottombar--edge">
    <span class="hint">whisperer</span>
    <span class="sep">•</span>
    <span class="hint">speech · follow</span>
  </footer>

  <script src="../../assets/js/main.js"></script>

  <script>
    (function(){
      const hasSpeech = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
      const supportBox = document.getElementById('supportBox');
      if(!hasSpeech){
        supportBox.hidden = false;
        return;
      }

      // Elements
      const textInput = document.getElementById('textInput');
      const display = document.getElementById('display');

      const fontRange = document.getElementById('fontRange');
      const fontVal = document.getElementById('fontVal');
      const langPill = document.getElementById('langPill');

      const prepBtn = document.getElementById('prepBtn');
      const clearBtn = document.getElementById('clearBtn');

      const speakBtn = document.getElementById('speakBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stopBtn = document.getElementById('stopBtn');

      const voiceEnSelect = document.getElementById('voiceEnSelect');
      const voiceRuSelect = document.getElementById('voiceRuSelect');

      const modePill = document.getElementById('modePill');
      const posPill = document.getElementById('posPill');

      const footer = document.querySelector('.bottombar');
      const floatbar = document.getElementById('floatbar');

      // Persisted settings
      const LS = {
        fontSize: 'whisperer_font_size_v2',
        voiceEn: 'whisperer_voice_en_v2',
        voiceRu: 'whisperer_voice_ru_v2'
      };

      function saveSetting(key, value){
        try{ localStorage.setItem(key, value); } catch(e){}
      }
      function loadSetting(key){
        try{ return localStorage.getItem(key); } catch(e){ return null; }
      }

      // Layout: measure footer + floatbar height to prevent overlap
      function measureBottom(){
        const fh = footer ? footer.getBoundingClientRect().height : 56;
        const bh = floatbar ? floatbar.getBoundingClientRect().height : 60;
        document.documentElement.style.setProperty('--footerH', Math.ceil(fh) + 'px');
        document.documentElement.style.setProperty('--floatH', Math.ceil(bh) + 'px');
      }
      measureBottom();
      window.addEventListener('resize', measureBottom);

      // Typography
      function applyFontSize(px){
        const v = Math.min(30, Math.max(12, Number(px) || 16));
        document.documentElement.style.setProperty('--w-font-size', v + 'px');
        fontVal.textContent = v + 'px';
        fontRange.value = String(v);
        saveSetting(LS.fontSize, String(v));
        // Re-measure (font size can change footer wrapping on some screens)
        measureBottom();
      }
      const savedFont = loadSetting(LS.fontSize);
      applyFontSize(savedFont ? Number(savedFont) : Number(fontRange.value));
      fontRange.addEventListener('input', () => applyFontSize(fontRange.value));

      // Text parsing / display
      let words = [];         // word tokens only
      let trails = [];        // trailing whitespace after each word
      let wordSpans = [];
      let wordLang = [];      // "en" | "ru"
      let activeWordIndex = -1;

      function normalizeText(t){
        return (t || '').replace(/\r\n/g, '\n');
      }

      function detectLangForWord(w, fallback){
        // If contains Cyrillic => ru, if contains Latin => en, else fallback
        const hasCyr = /[\u0400-\u04FF]/.test(w);
        const hasLat = /[A-Za-z]/.test(w);
        if(hasCyr && !hasLat) return 'ru';
        if(hasLat && !hasCyr) return 'en';
        if(hasCyr && hasLat) return 'en'; // mixed token: treat as EN by default
        return fallback || 'en';
      }

      function setWordIndex(i){
        activeWordIndex = i;
        posPill.textContent = (i >= 0) ? ('word: ' + (i+1) + '/' + words.length) : 'word: —';
        for(let k=0;k<wordSpans.length;k++){
          wordSpans[k].classList.toggle('is-active', k === i);
        }
        const sp = wordSpans[i];
        if(sp){
          sp.scrollIntoView({block: 'center', inline: 'nearest', behavior: 'smooth'});
        }
      }

      function buildDisplay(){
        const text = normalizeText(textInput.value);
        display.innerHTML = '';
        words = [];
        trails = [];
        wordSpans = [];
        wordLang = [];
        setWordIndex(-1);

        if(!text.trim()){
          langPill.textContent = 'lang: auto';
          return;
        }

        const tokens = text.match(/\S+|\s+/g) || [];
        // First pass: create spans for words, preserve whitespace as text nodes
        for(let i=0;i<tokens.length;i++){
          const tok = tokens[i];
          if(/^\s+$/.test(tok)){
            display.appendChild(document.createTextNode(tok));
          } else {
            const span = document.createElement('span');
            span.className = 'w-word';
            span.textContent = tok;
            span.dataset.index = String(words.length);
            display.appendChild(span);

            wordSpans.push(span);
            words.push(tok);

            // trailing whitespace (if any)
            const next = tokens[i+1];
            trails.push((next && /^\s+$/.test(next)) ? next : '');
          }
        }

        // Language per word (script-based, with fallback chaining)
        let prev = 'en';
        for(let i=0;i<words.length;i++){
          const l = detectLangForWord(words[i], prev);
          wordLang.push(l);
          prev = l;
        }

        // Update language pill summary
        const hasRu = wordLang.includes('ru');
        const hasEn = wordLang.includes('en');
        langPill.textContent = hasRu && hasEn ? 'lang: auto (EN+RU)' : (hasRu ? 'lang: auto (RU)' : 'lang: auto (EN)');
      }

      // Build display live (debounced)
      let buildTimer = null;
      function scheduleBuild(){
        if(buildTimer) clearTimeout(buildTimer);
        buildTimer = setTimeout(() => { buildDisplay(); }, 120);
      }
      textInput.addEventListener('input', scheduleBuild);
      prepBtn.addEventListener('click', buildDisplay);

      // Voices
      let voices = [];
      function getVoices(){
        voices = window.speechSynthesis.getVoices() || [];
        return voices;
      }

      function populateVoiceSelect(selectEl, langPrefix){
        const saved = loadSetting(selectEl === voiceEnSelect ? LS.voiceEn : LS.voiceRu);
        const previous = selectEl.value;

        // Keep the first "Auto" option
        const autoOpt = selectEl.querySelector('option[value="__auto__"]');
        selectEl.innerHTML = '';
        const first = document.createElement('option');
        first.value = '__auto__';
        first.textContent = 'Auto';
        selectEl.appendChild(first);

        const list = (voices || []).filter(v => (v.lang || '').toLowerCase().startsWith(langPrefix));
        list.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.name;
          opt.textContent = v.name + (v.default ? ' (default)' : '');
          selectEl.appendChild(opt);
        });

        // restore selection
        if(saved && [...selectEl.options].some(o => o.value === saved)){
          selectEl.value = saved;
        } else if(previous && [...selectEl.options].some(o => o.value === previous)){
          selectEl.value = previous;
        } else {
          selectEl.value = '__auto__';
        }
      }

      function bestVoiceFor(lang){
        const prefix = lang === 'ru' ? 'ru' : 'en';
        const selectEl = lang === 'ru' ? voiceRuSelect : voiceEnSelect;
        const forced = selectEl.value;
        if(forced && forced !== '__auto__'){
          return (voices || []).find(v => v.name === forced) || null;
        }

        // Auto: prefer default voice in that language; otherwise first match.
        const list = (voices || []).filter(v => (v.lang || '').toLowerCase().startsWith(prefix));
        const def = list.find(v => v.default);
        return def || list[0] || null;
      }

      function onVoicesChanged(){
        getVoices();
        populateVoiceSelect(voiceEnSelect, 'en');
        populateVoiceSelect(voiceRuSelect, 'ru');
      }

      window.speechSynthesis.onvoiceschanged = onVoicesChanged;
      onVoicesChanged();

      voiceEnSelect.addEventListener('change', () => saveSetting(LS.voiceEn, voiceEnSelect.value));
      voiceRuSelect.addEventListener('change', () => saveSetting(LS.voiceRu, voiceRuSelect.value));

      // Speech queue (supports mixed EN/RU)
      let mode = 'idle'; // idle | speaking | paused
      let segments = []; // [{text, lang, wordIndices, wordStarts}]
      let segIdx = 0;
      let cancelled = false;

      function setMode(next){
        mode = next;
        modePill.textContent = 'mode: ' + mode;

        const idle = (mode === 'idle');
        const paused = (mode === 'paused');

        speakBtn.disabled = !idle;
        pauseBtn.disabled = idle;
        stopBtn.disabled = idle;

        pauseBtn.textContent = paused ? 'Продолжить' : 'Пауза';
      }

      function stopAll(){
        cancelled = true;
        segments = [];
        segIdx = 0;
        try{ window.speechSynthesis.cancel(); } catch(e){}
        setMode('idle');
        setWordIndex(-1);
      }

      function buildSegments(fromIndex){
        const start = Math.max(0, Math.min(Number(fromIndex) || 0, Math.max(0, words.length - 1)));
        const maxWords = 18;
        const maxChars = 220;

        const out = [];
        let cur = null;

        function pushCur(){
          if(cur && cur.text.trim()){
            out.push(cur);
          }
          cur = null;
        }

        for(let i=start;i<words.length;i++){
          const wl = wordLang[i] || 'en';
          const w = words[i];
          const t = trails[i] || '';

          if(!cur){
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          const nextText = cur.text + w + t;
          const needSplit = (wl !== cur.lang) || (cur.wordIndices.length >= maxWords) || (nextText.length > maxChars);

          if(needSplit){
            pushCur();
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          // record start offset for this word inside segment
          cur.wordStarts.push(cur.text.length);
          cur.wordIndices.push(i);
          cur.text += w + t;
        }

        pushCur();
        return out;
      }

      function speakNext(){
        if(cancelled) return;

        if(segIdx >= segments.length){
          setMode('idle');
          setWordIndex(-1);
          return;
        }

        const seg = segments[segIdx];
        const u = new SpeechSynthesisUtterance(seg.text);

        // auto language per segment
        u.lang = (seg.lang === 'ru') ? 'ru-RU' : 'en-US';
        const v = bestVoiceFor(seg.lang);
        if(v) u.voice = v;

        u.onboundary = function(ev){
          // Highlight the current word (best effort; boundary events vary by browser)
          if(typeof ev.charIndex !== 'number') return;

          const ci = ev.charIndex;
          let local = -1;
          for(let j=0;j<seg.wordStarts.length;j++){
            if(seg.wordStarts[j] <= ci) local = j;
            else break;
          }
          if(local >= 0){
            const globalIndex = seg.wordIndices[local];
            setWordIndex(globalIndex);
          }
        };

        u.onend = function(){
          if(cancelled) return;
          segIdx += 1;
          speakNext();
        };

        u.onerror = function(){
          stopAll();
        };

        setMode('speaking');
        window.speechSynthesis.speak(u);
      }

      function speakFromWordIndex(i){
        buildDisplay(); // ensure words/lang lists exist
        const text = normalizeText(textInput.value);
        if(!text.trim() || !words.length) return;

        stopAll();
        cancelled = false;

        segments = buildSegments(i);
        segIdx = 0;

        // Some engines need a short tick after cancel before speaking again
        setTimeout(() => {
          if(cancelled) return;
          speakNext();
        }, 0);
      }

      function pauseOrResume(){
        if(mode === 'idle') return;

        if(mode === 'speaking'){
          try{ window.speechSynthesis.pause(); } catch(e){}
          setMode('paused');
        } else if(mode === 'paused'){
          try{ window.speechSynthesis.resume(); } catch(e){}
          setMode('speaking');
        }
      }

      // Buttons
      speakBtn.addEventListener('click', () => speakFromWordIndex(0));
      pauseBtn.addEventListener('click', pauseOrResume);
      stopBtn.addEventListener('click', stopAll);

      // Click any word in FOLLOW to start from it
      display.addEventListener('click', (e) => {
        const t = e.target;
        const span = t && t.closest ? t.closest('.w-word') : null;
        if(!span) return;

        const idx = Number(span.dataset.index || 0);
        speakFromWordIndex(idx);
      });

      clearBtn.addEventListener('click', () => {
        stopAll();
        textInput.value = '';
        buildDisplay();
        textInput.focus();
      });

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        const inForm = (tag === 'textarea' || tag === 'input' || tag === 'select');

        if(e.key === 'Escape'){
          stopAll();
          return;
        }

        if(e.code === 'Space' && !inForm){
          if(mode !== 'idle'){
            e.preventDefault();
            pauseOrResume();
          }
          return;
        }

        if(e.ctrlKey && (e.key === 'Enter' || e.code === 'Enter')){
          e.preventDefault();
          if(mode === 'idle') speakFromWordIndex(0);
          return;
        }
      });

      // Init
      buildDisplay();
      setMode('idle');

      // Keep bottom measurements accurate even after fonts load
      window.addEventListener('load', () => {
        measureBottom();
      });

      window.addEventListener('beforeunload', () => {
        try{ window.speechSynthesis.cancel(); } catch(e){}
      });
    })();
  </script>
</body>
</html>
