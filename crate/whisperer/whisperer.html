<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Item Key — whisperer</title>

  <!-- глобальный стиль сайта -->
  <link rel="stylesheet" href="../../assets/css/styles.css" />

  <!-- локальные стили ТОЛЬКО для whisperer -->
  <style>
    .whisperer-wrap, .whisperer-wrap * { box-sizing: border-box; }

    :root{
      --footerH: 56px;      /* measured in JS */
      --floatH: 60px;       /* measured in JS */
      --topbarOffset: 74px; /* safety spacing under header */

      /* typography */
      --w-font-size: 16px;  /* controlled by slider */
      --w-line-height: 1.75;
    }

    /* Keep content clear of fixed header and fixed bottom UI */
    .center-stage{
      padding-top: var(--topbarOffset);
      padding-bottom: calc(var(--footerH) + var(--floatH) + 28px + env(safe-area-inset-bottom));
      overflow-x: hidden;
    }

    .whisperer-wrap{
      width: 100%;
      max-width: 1040px;
      margin: 0 auto;
      display: grid;
      gap: 16px;
      padding: 12px 24px 22px;
      min-width: 0;
    }

    .w-title{
      padding: 6px 0 0;
      text-align: center;
      display: grid;
      gap: 8px;
    }
    .w-title h1{
      margin: 0;
      font-size: 14px;
      letter-spacing: 6px;
      text-transform: uppercase;
    }
    .w-title .sub{
      font-size: 11px;
      letter-spacing: 3.5px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
    }

    .w-grid{
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 0.8fr);
      gap: 16px;
      align-items: start;
    }

    .w-card, .w-reader, .w-warning{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.86);
      padding: 16px;
      border-radius: 0;
      box-shadow: none;
      min-width: 0;
    }

    .w-label{
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.58);
    }

    textarea.w-text{
      width: 100%;
      min-height: 260px;
      resize: vertical;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 12px 12px;
      font-size: var(--w-font-size);
      line-height: var(--w-line-height);
      outline: none;
      border-radius: 0;
    }
    textarea.w-text:focus{ border-color: rgba(0,0,0,.34); }

    .w-controls{ display: grid; gap: 14px; }
    .w-row{ display: grid; gap: 8px; }

    .w-field{ display: grid; gap: 8px; min-width: 0; }

    input[type="range"], select{
      width: 100%;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
    }
    input[type="range"]{ padding: 0 8px; }
    select{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .w-hint{
      font-size: 11px;
      line-height: 1.45;
      color: rgba(0,0,0,.70);
      margin: 0;
    }

    .w-actions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .w-btn{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.90);
      padding: 12px 10px;
      font-size: 11px;
      letter-spacing: 3px;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform .18s ease, border-color .18s ease, opacity .18s ease;
      border-radius: 0;
      min-height: 44px;
      line-height: 1.2;
      white-space: normal;
      text-align: center;
    }
    .w-btn:hover{ transform: translateY(-1px); border-color: rgba(0,0,0,.30); opacity: .98; }
    .w-btn:disabled{ opacity: .5; cursor: not-allowed; transform: none; }
    .w-btn:focus-visible{ outline: 2px solid rgba(0,0,0,.55); outline-offset: 2px; }

    .w-status{
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 11px;
      color: rgba(0,0,0,.72);
      margin-top: 2px;
    }
    .w-pill{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.82);
      padding: 5px 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 10px;
      color: rgba(0,0,0,.62);
      border-radius: 0;
    }

    details.w-adv{
      border: 1px dashed rgba(0,0,0,.14);
      padding: 10px;
      background: rgba(255,255,255,.70);
    }
    details.w-adv summary{
      cursor: pointer;
      font-size: 10px;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(0,0,0,.62);
      user-select: none;
      outline: none;
    }
    details.w-adv[open] summary{ margin-bottom: 10px; }

    .w-reader{
      display: grid;
      gap: 10px;
    }

    .w-display{
      font-size: var(--w-font-size);
      line-height: var(--w-line-height);
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 0;
      padding: 10px 10px;
      border-radius: 0;
      border: 1px dashed rgba(0,0,0,.14);
      background: rgba(255,255,255,.65);
      min-width: 0;
    }

    .w-word{ padding: 0 2px; cursor: pointer; }
    .w-word:hover{ background: rgba(0,0,0,.06); }
    .w-word.is-active{
      text-decoration: underline;
      text-underline-offset: 3px;
      background: rgba(0,0,0,.08);
    }

    .w-warning{
      font-size: 12px;
      line-height: 1.45;
      color: rgba(0,0,0,.72);
    }

    /* Floating transport: ALWAYS visible */
    .w-floatbar{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(var(--footerH) + 10px + env(safe-area-inset-bottom));
      z-index: 99999; /* must stay above footer + overlays */
      display: flex;
      gap: 10px;
      align-items: stretch;
      justify-content: center;
      padding: 10px;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(6px);
      min-width: min(720px, calc(100% - 24px));
      pointer-events: auto;
    }
    .w-floatbar .w-btn{
      flex: 1 1 0;
      min-width: 0;
      min-height: 46px;
    }
    .w-btn--primary{
      border-color: rgba(0,0,0,.28);
      font-weight: 700;
      letter-spacing: 4px;
    }

    @media (max-width: 980px){
      :root{ --topbarOffset: 66px; }
      .whisperer-wrap{ padding: 10px 14px 18px; }
      .w-grid{ grid-template-columns: 1fr; }
      textarea.w-text{ min-height: 220px; }
    }
    @media (max-width: 520px){
      .w-floatbar{
        left: 12px;
        right: 12px;
        transform: none;
        min-width: auto;
      }
    }

    /* =========================
       Mobile-first responsiveness
       ========================= */

    /* Better tap behavior on touch devices */
    button, a, input, select, textarea{
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* Hide side rails on small screens to maximize usable space */
    @media (max-width: 980px){
      .rail{ display: none !important; }
      .center-stage{ padding-left: 0 !important; padding-right: 0 !important; }
    }

    /* Phone layout: single-column, larger touch targets, no iOS zoom-on-focus */
    @media (max-width: 520px){
      :root{
        --topbarOffset: 58px; /* tighter top spacing on phones */
      }

      .whisperer-wrap{
        padding: 10px 12px 16px;
        gap: 12px;
      }

      .w-title h1{
        letter-spacing: 5px;
      }
      .w-title .sub{
        letter-spacing: 2.5px;
      }

      textarea.w-text{
        min-height: 200px;
        resize: vertical;
      }

      /* Prevent iOS Safari from zooming when focusing inputs (<16px triggers zoom) */
      input[type="range"], select, .modal-input{
        font-size: 16px;
      }

      .w-actions{
        grid-template-columns: 1fr;
      }

      /* Floating control bar: stack buttons vertically on phones */
      .w-floatbar{
        left: 12px;
        right: 12px;
        transform: none;
        min-width: auto;
        flex-direction: column;
        gap: 8px;
        padding: 10px;
        bottom: calc(var(--footerH) + 10px + env(safe-area-inset-bottom));
      }
      .w-floatbar .w-btn{
        min-height: 48px;
      }

      /* Modal: full-screen sheet on phones */
      .modal{
        padding: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
      }
      .modal-card{
        width: 100%;
        max-height: calc(100dvh - 20px);
      }
      .modal-list{
        max-height: 48dvh;
      }
      .modal-head{
        grid-template-columns: 1fr;
        gap: 10px;
      }
      #closeNotesModal{
        width: 100%;
      }
    }

    /* Short screens (landscape phones): reduce vertical waste */
    @media (max-height: 700px) and (max-width: 980px){
      textarea.w-text{ min-height: 160px; }
      .modal-list{ max-height: 38vh; }
    }

  </style>
</head>

<body class="page page-crate">
  <!-- фон/рамки — как в item-key -->
  <div class="outer-frame" aria-hidden="true"></div>
  <div class="rays" aria-hidden="true"></div>
  <div class="veil" aria-hidden="true"></div>

  <!-- верхний “герб” -->
  <header class="topbar topbar--edge">
    <a class="toplink" href="../../item-user.html?returnTo=crate/whisperer/whisperer.html" aria-label="Item User">
      <span class="tag">item-user</span>
    </a>
  </header>

  <!-- левый rail -->
  <aside class="rail rail--left" aria-label="Левое меню">
    <a class="rail-link" href="../../index.html">
      <span class="rail-link__title">item-key</span>
      <span class="rail-link__meta">главное меню</span>
    </a>
    <a class="rail-link" href="../../item-crate.html">
      <span class="rail-link__title">item-crate</span>
      <span class="rail-link__meta">назад в хаб</span>
    </a>
  </aside>

  <!-- правый rail -->
  <aside class="rail rail--right" aria-label="Правое меню">
    <a class="rail-link" href="../../item-soft.html">
      <span class="rail-link__title">item-soft</span>
      <span class="rail-link__meta">инструменты / редакторы</span>
    </a>
    <a class="rail-link" href="../../item-security.html">
      <span class="rail-link__title">item-security</span>
      <span class="rail-link__meta">доступ / защита</span>
    </a>
  </aside>

  <main class="center-stage" aria-label="whisperer center">
    <section class="whisperer-wrap" aria-label="whisperer app">
      <div class="w-title">
        <h1>whisperer</h1>
        <div class="sub">прошепчи моё имя, пожалуйста</div>
      </div>

      <div class="w-warning" id="supportBox" hidden>
        Ваш браузер не поддерживает Web Speech API (SpeechSynthesis). Попробуйте Chrome / Edge или обновите браузер.
      </div>

      <div class="w-grid">
        <div class="w-card" aria-label="Ввод текста">
          <div class="w-label">text</div>
          <textarea class="w-text" id="textInput" placeholder="Вставь сюда текст…"></textarea>
          <p class="w-hint">
            Клик по слову в FOLLOW — начать чтение с него. Панель «Озвучить / Пауза / Стоп» всегда видна снизу.
          </p>
        </div>

        <div class="w-card w-controls" aria-label="Настройки">
          <div class="w-label">settings</div>

          <div class="w-row">
            <div class="w-field">
              <div class="w-label">text size</div>
              <input id="fontRange" type="range" min="12" max="30" step="1" value="16" />
              <div class="w-status">
                <span class="w-pill" id="fontVal">16px</span>
                <span class="w-pill" id="langPill">lang: auto</span>
              </div>
            </div>
          </div>

          <div class="w-actions" aria-label="Инструменты">
            <button class="w-btn" id="prepBtn" type="button">Подготовить</button>
            <button class="w-btn" id="clearBtn" type="button">Очистить</button>
          </div>

          <button class="w-btn" id="fromNotesBtn" type="button">Из заметок</button>

          <details class="w-adv">
            <summary>advanced</summary>
            <div class="w-row">
              <div class="w-field">
                <div class="w-label">EN voice (optional)</div>
                <select id="voiceEnSelect" aria-label="English voice">
                  <option value="__auto__">Auto</option>
                </select>
              </div>
              <div class="w-field">
                <div class="w-label">RU voice (optional)</div>
                <select id="voiceRuSelect" aria-label="Russian voice">
                  <option value="__auto__">Auto</option>
                </select>
              </div>
              <p class="w-hint">
                Авто-режим сам выбирает язык (EN/RU) по тексту и переключает озвучку. Эти списки — только если хочешь жёстко закрепить голоса.
              </p>
            </div>
          </details>

          <div class="w-status" aria-label="Статус">
            <span class="w-pill" id="modePill">mode: idle</span>
            <span class="w-pill" id="posPill">word: —</span>
          </div>

          <p class="w-hint">
            Горячие клавиши: Ctrl+Enter — озвучить, Space — пауза/продолжить, Esc — стоп.
          </p>
        </div>
      </div>

      <div class="w-reader" aria-label="Текст с подсветкой">
        <div class="w-label">follow</div>
        <p class="w-display" id="display"></p>
      </div>
    </section>
  </main>

  <!-- Floating transport bar (ALWAYS visible) -->
  <div class="w-floatbar" id="floatbar" aria-label="Управление озвучкой">
    <button class="w-btn w-btn--primary" id="speakBtn" type="button">Озвучить</button>
    <button class="w-btn" id="pauseBtn" type="button" disabled>Пауза</button>
    <button class="w-btn" id="stopBtn" type="button" disabled>Стоп</button>
  </div>

  <footer class="bottombar bottombar--edge">
    <span class="hint">whisperer</span>
    <span class="sep">•</span>
    <span class="hint">speech · follow</span>
  </footer>


  <!-- Notes picker modal -->
  <div class="modal" id="notesModal" role="dialog" aria-modal="true" aria-label="Заметки">
    <div class="modal-card">
      <div class="modal-head">
        <div>
          <div class="w-label">notes</div>
          <div style="font-size:11px; color: rgba(0,0,0,.72); line-height:1.45">
            Выбери заметки — я вставлю их в поле текста. Можно сразу «Озвучить».
          </div>
        </div>
        <button class="w-btn" id="closeNotesModal" type="button">Закрыть</button>
      </div>

      <div class="modal-grid">
        <input id="notesSearch" class="modal-input" placeholder="Поиск заметок…" />
        <div class="modal-list" id="notesList"></div>

        <div class="modal-actions">
          <button class="w-btn" id="insertNotesBtn" type="button">Вставить</button>
          <button class="w-btn w-btn--primary" id="speakNotesBtn" type="button">Вставить и озвучить</button>
        </div>

        <div class="w-hint" style="margin-top:8px">
          Важно: заметки берутся из onoi_notes (IndexedDB). Если ты включил Cloud Sync в заметках, тут тоже будет доступна та же база (на этом же домене).
        </div>
      </div>
    </div>
  </div>

  <style>
    /* modal styles for whisperer */
    .modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.25);
      display: none;
      z-index: 999999;
      padding: 16px;
    }
    .modal.is-open{ display: grid; place-items: center; }
    .modal-card{
      width: min(860px, calc(100% - 8px));
      max-height: calc(100vh - 40px);
      overflow: auto;
      border: 1px solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.96);
      padding: 14px;
      border-radius: 0;
    }
    .modal-head{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: start;
      margin-bottom: 10px;
    }
    .modal-grid{ display: grid; gap: 10px; }
    .modal-input{
      width: 100%;
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.92);
      padding: 10px 12px;
      font-size: 12px;
      outline: none;
      border-radius: 0;
      height: 40px;
      min-width: 0;
    }
    .modal-list{
      border: 1px solid rgba(0,0,0,.14);
      background: rgba(255,255,255,.90);
      padding: 8px;
      display: grid;
      gap: 8px;
      max-height: 46vh;
      overflow: auto;
    }
    .m-row{
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.80);
      padding: 10px;
      display: grid;
      gap: 6px;
      cursor: pointer;
    }
    .m-row:hover{ border-color: rgba(0,0,0,.26); }
    .m-row__top{
      display: grid;
      grid-template-columns: 18px 1fr auto;
      gap: 8px;
      align-items: center;
      min-width: 0;
    }
    .m-title{
      margin: 0;
      font-size: 11px;
      letter-spacing: 2px;
      text-transform: uppercase;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .m-meta{
      font-size: 10px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: rgba(0,0,0,.55);
      white-space: nowrap;
    }
    .m-snippet{
      margin: 0;
      font-size: 11px;
      line-height: 1.4;
      color: rgba(0,0,0,.72);
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      word-break: break-word;
    }
    .modal-actions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 520px){
      .modal-actions{ grid-template-columns: 1fr; }
    }
  </style>

  <script src="../../assets/js/main.js"></script>

  <script>
    (function(){
      const hasSpeech = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
      const supportBox = document.getElementById('supportBox');
      if(!hasSpeech){
        supportBox.hidden = false;
        return;
      }

      // Elements
      const textInput = document.getElementById('textInput');
      const display = document.getElementById('display');

      const fontRange = document.getElementById('fontRange');
      const fontVal = document.getElementById('fontVal');
      const langPill = document.getElementById('langPill');

      const prepBtn = document.getElementById('prepBtn');
      const clearBtn = document.getElementById('clearBtn');

      // Notes bridge
      const fromNotesBtn = document.getElementById('fromNotesBtn');

      const notesModal = document.getElementById('notesModal');
      const closeNotesModal = document.getElementById('closeNotesModal');
      const notesSearch = document.getElementById('notesSearch');
      const notesListEl = document.getElementById('notesList');
      const insertNotesBtn = document.getElementById('insertNotesBtn');
      const speakNotesBtn = document.getElementById('speakNotesBtn');

      const NOTES_DB = 'itemkey_onoi_notes_db_v1'; // must match onoi_notes
      const NOTES_STORE = 'notes';
      const CATS_STORE = 'cats';

      function openModal(){
        notesModal.classList.add('is-open');
        notesSearch.value = '';
        renderNotesPicker('');
        notesSearch.focus();
      }
      function closeModal(){
        notesModal.classList.remove('is-open');
      }

      function htmlToText(html){
        const d = document.createElement('div');
        d.innerHTML = html || '';
        return (d.textContent || '').replace(/\s+/g,' ').trim();
      }

      function fmtTime(ts){
        if(!ts) return '—';
        const d = new Date(ts);
        const z = (n) => String(n).padStart(2,'0');
        return z(d.getDate())+'.'+z(d.getMonth()+1)+'.'+d.getFullYear()+' '+z(d.getHours())+':'+z(d.getMinutes());
      }

      function idbOpenNotes(){
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(NOTES_DB);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      function idbGetAll(db, storeName){
        return new Promise((resolve, reject) => {
          const tx = db.transaction([storeName], 'readonly');
          const st = tx.objectStore(storeName);
          const r = st.getAll();
          r.onsuccess = () => resolve(r.result || []);
          r.onerror = () => reject(r.error);
        });
      }

      let pickerCache = { notes: [], cats: [] };

      async function loadNotesCache(){
        try{
          const db = await idbOpenNotes();
          const [notes, cats] = await Promise.all([
            idbGetAll(db, NOTES_STORE),
            idbGetAll(db, CATS_STORE).catch(()=>[])
          ]);
          db.close();
          pickerCache.notes = Array.isArray(notes) ? notes : [];
          pickerCache.cats = Array.isArray(cats) ? cats : [];
        }catch(e){
          pickerCache.notes = [];
          pickerCache.cats = [];
        }
      }

      function catName(id){
        const c = (pickerCache.cats || []).find(x => x.id === id);
        return c ? (c.name || '—') : '—';
      }

      function renderNotesPicker(q){
        const query = (q || '').trim().toLowerCase();
        const notes = (pickerCache.notes || [])
          .slice()
          .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0))
          .filter(n => {
            if(!query) return true;
            const t = (n.title || '').toLowerCase();
            const b = htmlToText(n.html || '').toLowerCase();
            return t.includes(query) || b.includes(query);
          });

        notesListEl.innerHTML = '';

        if(!notes.length){
          const p = document.createElement('div');
          p.className = 'w-hint';
          p.textContent = 'Заметок не найдено. Открой onoi_notes и создай заметки.';
          notesListEl.appendChild(p);
          return;
        }

        notes.forEach(n => {
          const row = document.createElement('div');
          row.className = 'm-row';
          row.dataset.id = n.id;

          const top = document.createElement('div');
          top.className = 'm-row__top';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.style.width = '16px';
          cb.style.height = '16px';

          const title = document.createElement('p');
          title.className = 'm-title';
          title.textContent = (n.title || 'без названия');

          const meta = document.createElement('div');
          meta.className = 'm-meta';
          meta.textContent = catName(n.catId) + ' · ' + fmtTime(n.updatedAt);

          const sn = document.createElement('p');
          sn.className = 'm-snippet';
          sn.textContent = htmlToText(n.html || '') || '…';

          top.appendChild(cb);
          top.appendChild(title);
          top.appendChild(meta);

          row.appendChild(top);
          row.appendChild(sn);

          row.addEventListener('click', (e) => {
            if(e.target && e.target.tagName && e.target.tagName.toLowerCase() === 'input') return;
            cb.checked = !cb.checked;
          });

          notesListEl.appendChild(row);
        });
      }

      function selectedNoteIds(){
        const ids = [];
        notesListEl.querySelectorAll('.m-row').forEach(row => {
          const cb = row.querySelector('input[type="checkbox"]');
          if(cb && cb.checked) ids.push(row.dataset.id);
        });
        return ids;
      }

      function buildTextFromSelected(){
        const ids = new Set(selectedNoteIds());
        const selected = (pickerCache.notes || []).filter(n => ids.has(n.id))
          .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0));

        const parts = selected.map(n => {
          const title = (n.title || '').trim();
          const body = htmlToText(n.html || '');
          return (title ? (title + '\n') : '') + body;
        });

        return parts.join('\n\n———\n\n').trim();
      }

      async function openNotesPicker(){
        await loadNotesCache();
        openModal();
      }


      const speakBtn = document.getElementById('speakBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const stopBtn = document.getElementById('stopBtn');

      const voiceEnSelect = document.getElementById('voiceEnSelect');
      const voiceRuSelect = document.getElementById('voiceRuSelect');

      const modePill = document.getElementById('modePill');
      const posPill = document.getElementById('posPill');

      const footer = document.querySelector('.bottombar');
      const floatbar = document.getElementById('floatbar');

      // Persisted settings
      const LS = {
        fontSize: 'whisperer_font_size_v2',
        voiceEn: 'whisperer_voice_en_v2',
        voiceRu: 'whisperer_voice_ru_v2'
      };

      function saveSetting(key, value){
        try{ localStorage.setItem(key, value); } catch(e){}
      }
      function loadSetting(key){
        try{ return localStorage.getItem(key); } catch(e){ return null; }
      }

      // Layout: measure footer + floatbar height to prevent overlap
      function measureBottom(){
        const fh = footer ? footer.getBoundingClientRect().height : 56;
        const bh = floatbar ? floatbar.getBoundingClientRect().height : 60;
        document.documentElement.style.setProperty('--footerH', Math.ceil(fh) + 'px');
        document.documentElement.style.setProperty('--floatH', Math.ceil(bh) + 'px');
      }
      measureBottom();
      window.addEventListener('resize', measureBottom);

      // Typography
      function applyFontSize(px){
        const v = Math.min(30, Math.max(12, Number(px) || 16));
        document.documentElement.style.setProperty('--w-font-size', v + 'px');
        fontVal.textContent = v + 'px';
        fontRange.value = String(v);
        saveSetting(LS.fontSize, String(v));
        // Re-measure (font size can change footer wrapping on some screens)
        measureBottom();
      }
      const savedFont = loadSetting(LS.fontSize);
      applyFontSize(savedFont ? Number(savedFont) : Number(fontRange.value));
      fontRange.addEventListener('input', () => applyFontSize(fontRange.value));

      // Text parsing / display
      let words = [];         // word tokens only
      let trails = [];        // trailing whitespace after each word
      let wordSpans = [];
      let wordLang = [];      // "en" | "ru"
      let activeWordIndex = -1;

      function normalizeText(t){
        return (t || '').replace(/\r\n/g, '\n');
      }

      function detectLangForWord(w, fallback){
        // If contains Cyrillic => ru, if contains Latin => en, else fallback
        const hasCyr = /[\u0400-\u04FF]/.test(w);
        const hasLat = /[A-Za-z]/.test(w);
        if(hasCyr && !hasLat) return 'ru';
        if(hasLat && !hasCyr) return 'en';
        if(hasCyr && hasLat) return 'en'; // mixed token: treat as EN by default
        return fallback || 'en';
      }

      function setWordIndex(i){
        activeWordIndex = i;
        posPill.textContent = (i >= 0) ? ('word: ' + (i+1) + '/' + words.length) : 'word: —';
        for(let k=0;k<wordSpans.length;k++){
          wordSpans[k].classList.toggle('is-active', k === i);
        }
        const sp = wordSpans[i];
        if(sp){
          sp.scrollIntoView({block: 'center', inline: 'nearest', behavior: 'smooth'});
        }
      }

      function buildDisplay(){
        const text = normalizeText(textInput.value);
        display.innerHTML = '';
        words = [];
        trails = [];
        wordSpans = [];
        wordLang = [];
        setWordIndex(-1);

        if(!text.trim()){
          langPill.textContent = 'lang: auto';
          return;
        }

        const tokens = text.match(/\S+|\s+/g) || [];
        // First pass: create spans for words, preserve whitespace as text nodes
        for(let i=0;i<tokens.length;i++){
          const tok = tokens[i];
          if(/^\s+$/.test(tok)){
            display.appendChild(document.createTextNode(tok));
          } else {
            const span = document.createElement('span');
            span.className = 'w-word';
            span.textContent = tok;
            span.dataset.index = String(words.length);
            display.appendChild(span);

            wordSpans.push(span);
            words.push(tok);

            // trailing whitespace (if any)
            const next = tokens[i+1];
            trails.push((next && /^\s+$/.test(next)) ? next : '');
          }
        }

        // Language per word (script-based, with fallback chaining)
        let prev = 'en';
        for(let i=0;i<words.length;i++){
          const l = detectLangForWord(words[i], prev);
          wordLang.push(l);
          prev = l;
        }

        // Update language pill summary
        const hasRu = wordLang.includes('ru');
        const hasEn = wordLang.includes('en');
        langPill.textContent = hasRu && hasEn ? 'lang: auto (EN+RU)' : (hasRu ? 'lang: auto (RU)' : 'lang: auto (EN)');
      }

      // Build display live (debounced)
      let buildTimer = null;
      function scheduleBuild(){
        if(buildTimer) clearTimeout(buildTimer);
        buildTimer = setTimeout(() => { buildDisplay(); }, 120);
      }
      textInput.addEventListener('input', scheduleBuild);
      prepBtn.addEventListener('click', buildDisplay);

      // Voices
      let voices = [];
      function getVoices(){
        voices = window.speechSynthesis.getVoices() || [];
        return voices;
      }

      function populateVoiceSelect(selectEl, langPrefix){
        const saved = loadSetting(selectEl === voiceEnSelect ? LS.voiceEn : LS.voiceRu);
        const previous = selectEl.value;

        // Keep the first "Auto" option
        const autoOpt = selectEl.querySelector('option[value="__auto__"]');
        selectEl.innerHTML = '';
        const first = document.createElement('option');
        first.value = '__auto__';
        first.textContent = 'Auto';
        selectEl.appendChild(first);

        const list = (voices || []).filter(v => (v.lang || '').toLowerCase().startsWith(langPrefix));
        list.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.name;
          opt.textContent = v.name + (v.default ? ' (default)' : '');
          selectEl.appendChild(opt);
        });

        // restore selection
        if(saved && [...selectEl.options].some(o => o.value === saved)){
          selectEl.value = saved;
        } else if(previous && [...selectEl.options].some(o => o.value === previous)){
          selectEl.value = previous;
        } else {
          selectEl.value = '__auto__';
        }
      }

      function bestVoiceFor(lang){
        const prefix = lang === 'ru' ? 'ru' : 'en';
        const selectEl = lang === 'ru' ? voiceRuSelect : voiceEnSelect;
        const forced = selectEl.value;
        if(forced && forced !== '__auto__'){
          return (voices || []).find(v => v.name === forced) || null;
        }

        // Auto: prefer default voice in that language; otherwise first match.
        const list = (voices || []).filter(v => (v.lang || '').toLowerCase().startsWith(prefix));
        const def = list.find(v => v.default);
        return def || list[0] || null;
      }

      function onVoicesChanged(){
        getVoices();
        populateVoiceSelect(voiceEnSelect, 'en');
        populateVoiceSelect(voiceRuSelect, 'ru');
      }

      window.speechSynthesis.onvoiceschanged = onVoicesChanged;
      onVoicesChanged();

      voiceEnSelect.addEventListener('change', () => saveSetting(LS.voiceEn, voiceEnSelect.value));
      voiceRuSelect.addEventListener('change', () => saveSetting(LS.voiceRu, voiceRuSelect.value));

      // Speech queue (supports mixed EN/RU)
      let mode = 'idle'; // idle | speaking | paused
      let segments = []; // [{text, lang, wordIndices, wordStarts}]
      let segIdx = 0;
      let cancelled = false;

      function setMode(next){
        mode = next;
        modePill.textContent = 'mode: ' + mode;

        const idle = (mode === 'idle');
        const paused = (mode === 'paused');

        speakBtn.disabled = !idle;
        pauseBtn.disabled = idle;
        stopBtn.disabled = idle;

        pauseBtn.textContent = paused ? 'Продолжить' : 'Пауза';
      }

      function stopAll(){
        cancelled = true;
        segments = [];
        segIdx = 0;
        try{ window.speechSynthesis.cancel(); } catch(e){}
        setMode('idle');
        setWordIndex(-1);
      }

      function buildSegments(fromIndex){
        const start = Math.max(0, Math.min(Number(fromIndex) || 0, Math.max(0, words.length - 1)));
        const maxWords = 18;
        const maxChars = 220;

        const out = [];
        let cur = null;

        function pushCur(){
          if(cur && cur.text.trim()){
            out.push(cur);
          }
          cur = null;
        }

        for(let i=start;i<words.length;i++){
          const wl = wordLang[i] || 'en';
          const w = words[i];
          const t = trails[i] || '';

          if(!cur){
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          const nextText = cur.text + w + t;
          const needSplit = (wl !== cur.lang) || (cur.wordIndices.length >= maxWords) || (nextText.length > maxChars);

          if(needSplit){
            pushCur();
            cur = { text: '', lang: wl, wordIndices: [], wordStarts: [] };
          }

          // record start offset for this word inside segment
          cur.wordStarts.push(cur.text.length);
          cur.wordIndices.push(i);
          cur.text += w + t;
        }

        pushCur();
        return out;
      }

      function speakNext(){
        if(cancelled) return;

        if(segIdx >= segments.length){
          setMode('idle');
          setWordIndex(-1);
          return;
        }

        const seg = segments[segIdx];
        const u = new SpeechSynthesisUtterance(seg.text);

        // auto language per segment
        u.lang = (seg.lang === 'ru') ? 'ru-RU' : 'en-US';
        const v = bestVoiceFor(seg.lang);
        if(v) u.voice = v;

        u.onboundary = function(ev){
          // Highlight the current word (best effort; boundary events vary by browser)
          if(typeof ev.charIndex !== 'number') return;

          const ci = ev.charIndex;
          let local = -1;
          for(let j=0;j<seg.wordStarts.length;j++){
            if(seg.wordStarts[j] <= ci) local = j;
            else break;
          }
          if(local >= 0){
            const globalIndex = seg.wordIndices[local];
            setWordIndex(globalIndex);
          }
        };

        u.onend = function(){
          if(cancelled) return;
          segIdx += 1;
          speakNext();
        };

        u.onerror = function(){
          stopAll();
        };

        setMode('speaking');
        window.speechSynthesis.speak(u);
      }

      function speakFromWordIndex(i){
        buildDisplay(); // ensure words/lang lists exist
        const text = normalizeText(textInput.value);
        if(!text.trim() || !words.length) return;

        stopAll();
        cancelled = false;

        segments = buildSegments(i);
        segIdx = 0;

        // Some engines need a short tick after cancel before speaking again
        setTimeout(() => {
          if(cancelled) return;
          speakNext();
        }, 0);
      }

      function pauseOrResume(){
        if(mode === 'idle') return;

        if(mode === 'speaking'){
          try{ window.speechSynthesis.pause(); } catch(e){}
          setMode('paused');
        } else if(mode === 'paused'){
          try{ window.speechSynthesis.resume(); } catch(e){}
          setMode('speaking');
        }
      }

      // Buttons
      speakBtn.addEventListener('click', () => speakFromWordIndex(0));
      pauseBtn.addEventListener('click', pauseOrResume);
      stopBtn.addEventListener('click', stopAll);

      // Click any word in FOLLOW to start from it
      display.addEventListener('click', (e) => {
        const t = e.target;
        const span = t && t.closest ? t.closest('.w-word') : null;
        if(!span) return;

        const idx = Number(span.dataset.index || 0);
        speakFromWordIndex(idx);
      });

      clearBtn.addEventListener('click', () => {
        stopAll();
        textInput.value = '';
        buildDisplay();
        textInput.focus();
      });

      // Notes picker handlers
      if(fromNotesBtn){
        fromNotesBtn.addEventListener('click', openNotesPicker);
      }
      if(closeNotesModal){
        closeNotesModal.addEventListener('click', closeModal);
      }
      if(notesModal){
        notesModal.addEventListener('click', (e) => { if(e.target === notesModal) closeModal(); });
      }
      if(notesSearch){
        notesSearch.addEventListener('input', () => renderNotesPicker(notesSearch.value));
      }
      if(insertNotesBtn){
        insertNotesBtn.addEventListener('click', () => {
          const t = buildTextFromSelected();
          if(!t){ closeModal(); return; }
          textInput.value = t;
          buildDisplay();
          closeModal();
        });
      }
      if(speakNotesBtn){
        speakNotesBtn.addEventListener('click', () => {
          const t = buildTextFromSelected();
          if(!t){ closeModal(); return; }
          textInput.value = t;
          buildDisplay();
          closeModal();
          speakFromWordIndex(0);
        });
      }

      // Incoming payload from onoi_notes
      // 1) URL param (for short texts)
      try{
        const sp = new URLSearchParams(window.location.search || '');
        const t = sp.get('text');
        if(t){
          textInput.value = String(t);
          buildDisplay();
        }
      }catch(e){}

      // 2) localStorage payload (primary transport)
      try{
        const raw = localStorage.getItem('onoi_whisper_payload_v1');
        if(raw){
          const payload = JSON.parse(raw);
          if(payload && payload.text){
            // Do not override URL param text if it already exists
            if(!textInput.value){
              textInput.value = String(payload.text);
              buildDisplay();
            }
          }
          localStorage.removeItem('onoi_whisper_payload_v1');
        }
      }catch(e){}

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        const inForm = (tag === 'textarea' || tag === 'input' || tag === 'select');

        if(e.key === 'Escape'){
          stopAll();
          return;
        }

        if(e.code === 'Space' && !inForm){
          if(mode !== 'idle'){
            e.preventDefault();
            pauseOrResume();
          }
          return;
        }

        if(e.ctrlKey && (e.key === 'Enter' || e.code === 'Enter')){
          e.preventDefault();
          if(mode === 'idle') speakFromWordIndex(0);
          return;
        }
      });

      // Init
      buildDisplay();
      setMode('idle');

      // Keep bottom measurements accurate even after fonts load
      window.addEventListener('load', () => {
        measureBottom();
      });

      window.addEventListener('beforeunload', () => {
        try{ window.speechSynthesis.cancel(); } catch(e){}
      });
    })();
  </script>
</body>
</html>
