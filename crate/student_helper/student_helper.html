<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Item Key — помощь студентам</title>

  <!-- глобальный стиль сайта -->
  <link rel="stylesheet" href="../../assets/css/styles.css" />

  <!-- внутренний стиль модуля (адаптирован: renamed topbar -> sh-topbar) -->
  <style>

    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
    }

    body {
      background: #000;
      color: #fff;
      font-family: "Anticva", "Times New Roman", serif;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
    }

    :root {
      --bg: #000;
      --fg: #ffffff;
      --soft: #c9c9c9;
      --muted: #7f7f7f;
      --accent: #ffffff;
      --border: #ffffff;
    }

    .elongated {
      display: inline-block;
      transform: scaleY(1.7);
      transform-origin: center;
      letter-spacing: 0.16em;
    }

    .small-elongated {
      display: inline-block;
      transform: scaleY(1.4);
      transform-origin: center;
      letter-spacing: 0.14em;
    }

    .screen {
      position: fixed;
      inset: 0;
      background: #000;
      color: #fff;
      display: none;
    }

    .screen-visible {
      display: block;
    }

    .screen-inner {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    /* 01 — заставка с логотипом */
    #screen-splash .screen-inner {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    .splash-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .splash-hint {
      position: absolute;
      bottom: 24px;
      right: 40px;
      font-size: 10px;
      color: var(--muted);
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    /* 02 — В МОЗГ (мозг + квадраты) */

    #screen-brain .screen-inner {
      padding: 48px 72px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 40px;
    }

    .brain-left {
      flex: 1;
    }
    .brain-site-name {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--muted);
      margin-bottom: 18px;
    }

    .brain-menu {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 380px;
    }

    .brain-menu-btn {
      border: 1px solid #ffffff;
      background: #000000;
      color: #ffffff;
      padding: 10px 16px;
      text-align: left;
      cursor: pointer;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: clamp(16px, 2.4vw, 22px);
      width: 100%;
      transition: background 0.15s ease-out, color 0.15s ease-out, transform 0.15s ease-out;
    }

    .brain-menu-btn:hover {
      background: #ffffff;
      color: #000000;
      transform: translateY(-2px);
    }


    .brain-main-title {
      font-size: clamp(32px, 5vw, 46px);
      margin-bottom: 16px;
      text-transform: uppercase;
      display: block;
    }

    .brain-sub {
      font-size: clamp(16px, 2.4vw, 24px);
      text-transform: uppercase;
      margin-bottom: 6px;
      display: block;
    }

    .brain-sub:nth-child(2) {
      margin-top: 18px;
    }

    .brain-sub:last-child {
      margin-top: 6px;
    }

    .brain-left-bottom {
      margin-top: 40px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .brain-right {
      flex: 0 0 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
    }

    .brain-icon {
      width: 260px;
      max-width: 100%;
      cursor: pointer;
      image-rendering: auto;
    }

    .brain-person {
      width: 100px;
      opacity: 0.95;
    }

    .brain-squares {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 120px));
      gap: 14px;
      margin-top: 6px;
    }

    .brain-square {
      border: 2px solid #fff;
      background: transparent;
      cursor: pointer;
      transition: background 0.15s ease-out, transform 0.15s ease-out;
      /* Золотое сечение: ширина / высота ≈ 1.618 */
      aspect-ratio: 1.618 / 1;
    }

    .brain-square:hover {
      background: #fff;
      transform: translateY(-2px);
    }

    .brain-square.small {
      grid-column: span 2;
      /* Перевёрнутое золотое сечение: ширина / высота ≈ 1 / 0.618 */
      aspect-ratio: 1 / 0.618;
    }

    .brain-square-disabled {
      cursor: default;
      opacity: 0.85;
      pointer-events: none;
    }

    .brain-square-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .square-relative {
      position: relative;
    }

    .brain-io-row {
      display: flex;
      gap: 16px;
      margin-top: 8px;
      align-items: center;
      justify-content: center;
    }

    .brain-io {
      border: 2px solid #fff;
      width: 120px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      background: transparent;
      transition: background 0.15s ease-out, transform 0.15s ease-out;
    }

    .brain-io:hover {
      background: #fff;
      color: #000;
      transform: translateY(-2px);
    }

    #fileInput {
      display: none;
    }

    .brain-brand {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .brain-brand-logo {
      width: 120px;
      opacity: 0.95;
    }

    /* 02b — Экран выбора корня (активизация нейронов) */

    #screen-roots .screen-inner {
      padding: 40px 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 40px;
    }

    .roots-header {
      width: 100%;
      text-align: center;
      text-transform: uppercase;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .roots-title {
      font-size: clamp(42px, 7vw, 64px);
    }

    .roots-sub {
      margin-top: 4px;
      font-size: clamp(18px, 3vw, 24px);
      letter-spacing: 0.18em;
    }

    .roots-center {
      width: 100%;
      max-width: 980px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 40px;
    }

    .roots-bracket {
      border: 2px dotted #ffffff;
      height: 260px;
    }

    .roots-bracket-left {
      border-right: none;
    }

    .roots-bracket-right {
      border-left: none;
    }

    .roots-list-wrapper {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 18px;
    }

    .roots-add-btn {
      width: 60px;
      height: 60px;
      border-radius: 14px;
      border: 2px solid #ffffff;
      background: #ffffff;
      color: #000000;
      font-size: 32px;
      cursor: pointer;
    }

    .roots-add-btn:hover {
      transform: translateY(-2px);
    }

    .roots-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 20px;
      text-transform: uppercase;
    }

    .root-item {
      display: flex;
      align-items: baseline;
      gap: 12px;
      cursor: pointer;
    }

    .root-item-star {
      font-size: 26px;
    }

    .root-item-label {
      letter-spacing: 0.09em;
      display: inline-block;
      transform: scaleY(1.4);
      transform-origin: center;
    }

    .root-item:hover .root-item-label {
      text-decoration: underline;
    }

    .roots-empty {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    /* 03 — Основной экран приложения (архивотсек / паттерн) */

    #screen-app .screen-inner {
      padding: 24px 40px 24px 40px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #appRoot {
      flex: 1;
      display: grid;
      grid-template-columns: 260px 6px minmax(0, 1fr);
      gap: 0px;
    }

    .rootbar {
      border-right: 2px dashed #ffffff;
      padding-right: 12px;
      padding-left: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      background: #050505;
      border-radius: 8px;
      padding-top: 6px;
      padding-bottom: 6px;
    }

    .rootbar-top {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
      margin-bottom: 8px;
    }

    .rootbar-plus {
      width: 100%;
      height: 36px;
      border-radius: 6px;
      background: #ffffff;
      color: #000000;
      border: none;
      font-size: 22px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rootbar-plus:hover {
      transform: translateY(-1px);
      background: #ffffff;
      color: #000000;
    }

    .rootbar-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--muted);
    }

    .rootbar-list {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 11px;
      text-transform: uppercase;
      overflow-y: auto;
    }

    .rootbar-section-title {
      font-size: 9px;
      letter-spacing: 0.16em;
      color: var(--muted);
      margin-top: 4px;
    }

    .rootbar-item {
      padding: 4px 4px;
      border-radius: 6px;
      border: 1px solid transparent;
      cursor: pointer;
      line-height: 1.35;
      margin-bottom: 4px;
      word-break: break-word;
    }

    .rootbar-item:hover {
      border-color: #ffffff;
      background: #101010;
    }

    .rootbar-item-current {
      border-color: #ffffff;
      background: #151515;
    }

    .rootbar-item-label {
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }


    .sidebar {
      border-right: 2px dashed #ffffff;
      padding-right: 12px;
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .sidebar-resizer {
      width: 2px;
      cursor: col-resize;
      align-self: stretch;
      background: #ffffff;
    }

    .sidebar-resizer::before {
      content: none;
    }

    body.resizing {
      cursor: col-resize;
      user-select: none;
    }


    .sidebar-top {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 18px;
    }

    .sidebar-brand {
      font-size: 22px;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      border: 1px solid #ffffff;
      padding: 4px 12px;
      border-radius: 4px;
    }

    .sidebar-brand:hover {
      background: #ffffff;
      color: #000000;
    }

    .sidebar-brand span {
      display: inline-block;
    }

    .sidebar-plus {
      width: 72px;
      height: 40px;
      border-radius: 6px;
      background: #fff;
      color: #000;
      font-size: 26px;
      border: none;
      cursor: pointer;
      display: none;
    }

    .sidebar-plus:hover {
      transform: translateY(-2px);
    }

    .sidebar-breadcrumb-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    #breadcrumb {
      margin-top: 4px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      word-break: break-word;
    }

    .sidebar-tree-wrapper {
      margin-top: 16px;
      overflow-y: visible;
      padding-right: 8px;
      font-size: 13px;
      flex: 1;
    }

    /* simple tree look */
    .tree-item {
      padding: 4px 6px;
      border-left: 2px solid transparent;
      cursor: pointer;
      margin-bottom: 4px;
      text-transform: uppercase;
    }

    .tree-item:hover {
      border-left-color: #fff;
      background: #111;
    }

    .tree-item.active {
      border-left-color: #fff;
      background: #111;
    }

    .tree-label {
      font-size: 13px;
    }

    .tree-meta {
      font-size: 9px;
      color: var(--muted);
    }

    .tree-badge {
      display: none;
    }

    .hier-fx {
      font-size: 20px;
      margin-bottom: 8px;
    }

    .hier-row {
      display: flex;
      position: relative;
      align-items: baseline;
      gap: 6px;
      margin-bottom: 10px;
      cursor: pointer;
    }

    .hier-row.hier-row-drop-inside {
      background: rgba(255, 255, 255, 0.08);
    }

    .hier-row.hier-row-drop-before::before,
    .hier-row.hier-row-drop-after::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      border-top: 2px solid #ffffff;
    }

    .hier-row.hier-row-drop-before::before {
      top: -2px;
    }

    .hier-row.hier-row-drop-after::after {
      bottom: -2px;
    }

    .hier-tag {
      font-size: 11px;
      text-transform: lowercase;
      letter-spacing: 0.1em;
      min-width: 56px;
    }

    .hier-name {
      font-size: 16px;
      text-transform: uppercase;
      display: inline-block;
      transform: scaleY(1.3);
      transform-origin: center;
      letter-spacing: 0.14em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .hier-row-current .hier-name {
      text-decoration: underline;
    }

    .hier-name-link {
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
    }

    /* main panel */
    .main-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
      padding-left: 16px;
    }

    .main-header-line {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      border-bottom: 2px dashed #fff;
      padding-bottom: 8px;
      margin-bottom: 12px;
    }

    .main-title-wrapper {
      font-size: 26px;
      text-transform: uppercase;
    }

    .main-title-wrapper .small-elongated {
      font-size: 18px;
    }

    #headerActions {
      display: flex;
      gap: 8px;
      font-size: 11px;
      text-transform: uppercase;
    }

    #detailsRoot {
      flex: 1;
      overflow-y: auto;
      padding-right: 8px;
      font-size: 13px;
    }

    .section {
      border: 1px solid #ffffff;
      padding: 8px 10px;
      margin-bottom: 10px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-transform: uppercase;
      font-size: 12px;
      cursor: pointer;
    }

    .section-header .section-title {
      display: inline-block;
      transform: scaleY(1.35);
      transform-origin: center;
      letter-spacing: 0.14em;
    }

    .section-body {
      margin-top: 8px;
      font-size: 12px;
    }

    .hint {
      font-size: 11px;
      color: var(--muted);
    }

    .btn {
      font-family: inherit;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      background: #000;
      color: #fff;
      border: 1px solid #fff;
      padding: 4px 10px;
      cursor: pointer;
    }

    .btn-sm {
      font-size: 10px;
      padding: 4px 8px;
    }

    .btn:disabled,
    .btn[disabled] {
      opacity: 0.35;
      cursor: not-allowed;
      border-color: #555555;
      color: #555555;
      background: #000000;
    }

    .btn-primary {
      background: #fff;
      color: #000;
    }

    .btn-ghost {
      background: transparent;
    }

    .btn-danger {
      border-color: #ff6282;
      color: #ff6282;
    }

    .btn-hidden {
      display: none !important;
    }

    .btn-option {
      width: 100%;
      text-align: left;
      margin-bottom: 6px;
    }

    .btn-option-selected {
      background: #fff;
      color: #000;
    }

    .btn-option-correct {
      background: #1c8c3c;
      border-color: #a7ffb0;
      color: #eafff0;
    }

    .btn-option-wrong {
      background: #7b112f;
      border-color: #ff99ba;
      color: #ffe5f1;
    }

    .form-input,
    .form-select,
    .form-textarea {
      width: 100%;
      background: #000;
      border: 1px solid #fff;
      color: #fff;
      padding: 4px 6px;
      font-family: inherit;
      font-size: 12px;
    }

    .form-textarea {
      min-height: 60px;
      resize: vertical;
    }

    .form-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .form-row {
      display: grid;
      grid-template-columns: 150px minmax(0, 1fr);
      gap: 6px;
      margin-bottom: 6px;
      align-items: flex-start;
    }

    .row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .row-xs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .child-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .child-card {
      border: 1px solid #fff;
      padding: 4px 6px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 11px;
    }

    .child-card:hover {
      background: #111;
    }

    .child-name {
      max-width: 240px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .child-meta {
      font-size: 9px;
      color: var(--muted);
      display: flex;
      gap: 8px;
    }

    .card-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .card-table th,
    .card-table td {
      border-bottom: 1px solid #444;
      padding: 4px 4px;
      text-align: left;
    }

    .card-table-actions,
    .card-order-controls {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-start;
    }


    /* Кнопка сворачивания левой панели */
    .sidebar-toggle-fixed {
      position: absolute;
      left: 8px;
      top: 12px;
      z-index: 10;
      width: 26px;
      height: 32px;
      border-radius: 16px;
      border: 1px solid #ffffff;
      background: #000000;
      color: #ffffff;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .sidebar-toggle-fixed:hover {
      background: #ffffff;
      color: #000000;
    }

    #appRoot.sidebar-collapsed {
      grid-template-columns: minmax(0, 1fr);
    }

    #appRoot.sidebar-collapsed .sidebar,
    #appRoot.sidebar-collapsed .sidebar-resizer {
      display: none;
    }

    /* overlays removed (tests + facts view) */

    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.93);
      z-index: 50;
    }

    .modal-card {
      width: min(520px, 100% - 40px);
      background: #000;
      border: 1px solid #fff;
      padding: 14px 16px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
    }

    .modal-header {
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }

    .modal-header-main {
      display: flex;
      flex-direction: column;
    }

    .modal-close {
      border: 1px solid #fff;
      background: transparent;
      color: #fff;
      padding: 0 6px;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      text-transform: none;
    }

    .modal-close:hover {
      background: #fff;
      color: #000;
    }


    .modal-title {
      font-size: 18px;
      text-transform: uppercase;
    }

    .modal-subtitle {
      font-size: 11px;
      color: var(--muted);
      margin-top: 4px;
    }

    .modal-footer {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    .segmented {
      display: inline-flex;
      border: 1px solid #fff;
      padding: 2px;
      gap: 2px;
      margin-top: 4px;
    }

    .segmented button {
      border: none;
      background: transparent;
      color: #fff;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 3px 6px;
      cursor: pointer;
    }

    .segmented button.active {
      background: #fff;
      color: #000;
    }

    .seg-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-top: 4px;
    }

    /* overlay с текстом про мозг */
    .brain-story-overlay {
      position: fixed;
      inset: 0;
      background: #000;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 60;
    }

    .brain-story-overlay.visible {
      display: flex;
    }

    .brain-story-card {
      max-width: 680px;
      padding: 32px 40px 24px;
      border: 1px solid #fff;
      text-align: center;
      font-size: 16px;
      line-height: 1.6;
    }

    .brain-story-card p {
      margin-bottom: 18px;
    }

    /* RESPONSIVE */

    @media (max-width: 960px) {
      #screen-brain .screen-inner {
        padding: 32px 20px;
        flex-direction: column;
      }
      #appRoot {
        grid-template-columns: minmax(0, 1fr);
      }
      .sidebar-resizer {
        display: none;
      }
      .sidebar {
        border-right: none;
        border-bottom: 2px dashed #fff;
        padding-right: 0;
        padding-bottom: 14px;
        margin-bottom: 10px;
      }
      .screen-inner {
        overflow-y: auto;
      }
      body {
        overflow: hidden;
      }
      .hier-header {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    @media (max-width: 640px) {
      #screen-brain .screen-inner {
        padding-inline: 14px;
      }
      .brain-main-title {
        font-size: 26px;
      }
      .brain-sub {
        font-size: 16px;
      }
      #screen-app .screen-inner {
        padding-inline: 18px;
      }
    }
  
/* --- Overrides: статичная верхняя зона + скролл только в контенте --- */
body {
  overflow: hidden;
}

.screen-inner {
  overflow-y: auto;
  overflow-x: hidden;
}

#screen-app .screen-inner{
  overflow: hidden !important;
}

#appRoot.sidebar-collapsed {
  grid-template-columns: 72px minmax(0, 1fr);
}

#appRoot.sidebar-collapsed .sidebar,
#appRoot.sidebar-collapsed .sidebar-resizer {
  display: none;
}

#appRoot.sidebar-collapsed .rootbar {
  display: flex;
  padding-inline: 6px;
  border-right: 1px solid #ffffff;
}

#appRoot.sidebar-collapsed .rootbar-expanded {
  display: none;
}

#appRoot.sidebar-collapsed .rootbar-collapsed {
  display: flex;
}

.hier-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
  gap: 8px;
}


.hier-fx-buttons {
  display: flex;
  gap: 4px;
  font-size: 8px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  flex-wrap: wrap;
}

.hier-fx-btn {
  border: 1px solid #ffffff;
  background: #000000;
  color: #ffffff;
  padding: 2px 6px;
  cursor: pointer;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  display: inline-block;
  transform: scaleY(1.2);
  transform-origin: center;
  flex: 1 1 auto;
  text-align: center;
  white-space: nowrap;
}

.hier-fx-btn:hover {
  background: #ffffff;
  color: #000000;
}


.hier-row-category {
  color: #ffffff;
  /* визуальный маркер: это "папка-отсек" */
  border-left: 2px solid #ffffff;
}

.hier-row-characteristic {
  color: #c9c9c9;
  /* визуальный маркер: это паттерн с фактами */
  border-left: 2px dashed #555555;
}

.hier-toggle {
  width: 14px;
  font-size: 10px;
  text-align: center;
  cursor: pointer;
  user-select: none;
}

.hier-toggle-placeholder {
  visibility: hidden;
  cursor: default;
}

  
    .hier-row.hier-row-drop {
      background: rgba(255, 255, 255, 0.08);
    }

  
    .date-exact-row {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    /* --- Sidebar hierarchy clarity tweaks --- */
    .sidebar-tree-wrapper {
      margin-top: 16px;
      padding: 8px 8px 10px;
      border: 1px solid #ffffff;
      border-radius: 8px;
      background: #050505;
      overflow-y: auto;
      font-size: 13px;
      flex: 1;
    }

    .hier-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px dashed #333333;
    }

    .hier-fx {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .hier-row {
      padding: 4px 6px;
      border-radius: 6px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background 0.12s ease-out, border-color 0.12s ease-out;
      align-items: flex-start;
      line-height: 1.4;
    }

    .hier-row:hover {
      background: #111111;
    }

    .hier-row-current {
      border: 1px solid #ffffff;
      background: #151515;
    }

    .hier-tag {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      min-width: 80px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #555555;
      text-align: center;
      margin-right: 6px;
      flex-shrink: 0;
    }

    .hier-row-category .hier-tag {
      border-color: #ffffff;
      color: #ffffff;
    }

    .hier-row-characteristic .hier-tag {
      border-style: dashed;
      color: var(--muted);
    }

    .hier-name {
      /* название отсека / паттерна в одну строку с троеточием */
      font-size: 12px;
      text-transform: uppercase;
      display: inline-block;
      transform: scaleY(1.25);
      transform-origin: center;
      letter-spacing: 0.14em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .sidebar-legend {
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px dashed #333333;
      font-size: 9px;
      color: var(--muted);
      line-height: 1.5;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 3px;
    }

    .legend-badge {
      border-radius: 999px;
      padding: 1px 6px;
      border: 1px solid #555555;
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    .legend-badge-cell {
      border-color: #ffffff;
      color: #ffffff;
    }

    .legend-badge-patt {
      border-style: dashed;
    }


    /* Новая логика левой панели и поиск */

    .rootbar {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .rootbar-expanded {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .rootbar-collapsed {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding-top: 8px;
    }

    .rootbar-icon,
    .rootbar-toggle-mini {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid #444444;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
    }

    .rootbar-icon img {
      width: 20px;
      height: 20px;
      object-fit: contain;
      pointer-events: none;
    }

    .sidebar-top {
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .sidebar-toggle-inner {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #333333;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 12px;
      flex-shrink: 0;
      margin-top: 2px;
    }

    
    .sidebar-search {
      margin-top: 8px;
      position: relative;
    }

    /* search input (topbar + sidebar reuse) */
    .sidebar-search-input {
      font-size: 11px;
      padding-right: 34px; /* space for clear button */
      border-radius: 10px;
    }

    .searchbox{
      position: relative;
    }

    .searchbox-clear{
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid #333;
      background: #000;
      color: #fff;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      line-height: 1;
      padding: 0;
      font-size: 14px;
      opacity: 0.9;
    }

    .searchbox-clear:hover{
      background: #111;
      border-color: #777;
      opacity: 1;
    }

    .sidebar-search-results {
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      margin-top: 6px;
      max-height: 320px;
      overflow-y: auto;
      background: #000000;
      border: 1px solid #333333;
      border-radius: 10px;
      padding: 6px;
      z-index: 40;
      display: none;
      box-shadow: 0 16px 44px rgba(0,0,0,0.62);
    }

    .search-section{
      border: 1px solid #1d1d1d;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 6px;
    }
    .search-section:last-child{ margin-bottom: 0; }

    .search-section-header{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      border-bottom: 1px solid #1d1d1d;
      background: #050505;
    }

    .search-section-title{
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
      user-select: none;
      display: flex;
      align-items: baseline;
      gap: 8px;
      white-space: nowrap;
    }

    .search-section-count{
      font-size: 9px;
      color: #8a8a8a;
      letter-spacing: 0.12em;
    }

    .search-section-hints{
      display: flex;
      gap: 6px;
      align-items: center;
      color: #8a8a8a;
      font-size: 9px;
      letter-spacing: 0.10em;
      user-select: none;
      white-space: nowrap;
    }

    .kbd{
      border: 1px solid #2b2b2b;
      border-bottom-color: #444;
      padding: 1px 5px;
      border-radius: 6px;
      font-size: 9px;
      color: #bdbdbd;
      background: #000;
    }

    /* suggestion chips */
    .search-sug-body{
      padding: 8px 10px 10px;
      background: #000;
    }

    .search-sug-chips{
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .search-sug-chip{
      border: 1px solid #333;
      background: #000;
      color: #fff;
      cursor: pointer;
      padding: 5px 10px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.10em;
      white-space: nowrap;
    }

    .search-sug-chip:hover{
      background: #111;
      border-color: #777;
    }

    .search-sug-chip .chip-hl{
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
    }

    .chip-action{
      font-size: 10px;
      opacity: 0.65;
      letter-spacing: 0;
    }

    /* results list */
    .search-res-body{
      padding: 4px;
      background: #000;
    }

    .search-item{
      padding: 8px 8px;
      cursor: pointer;
      border-radius: 8px;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .search-item:hover{
      background: #111111;
    }

    .search-item.active{
      background: rgba(255,255,255,0.10);
      outline: 1px solid rgba(255,255,255,0.22);
    }

    .search-badge{
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      border: 1px solid #444;
      border-radius: 999px;
      padding: 3px 7px;
      color: #fff;
      flex: 0 0 auto;
      margin-top: 1px;
      background: #000;
    }

    .search-item-main{
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .search-item-title{
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      display: flex;
      align-items: baseline;
      gap: 6px;
      min-width: 0;
    }

    .search-item-title-main{
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .search-item-year{
      flex: 0 0 auto;
      font-size: 10px;
      letter-spacing: 0.12em;
      color: #bdbdbd;
      opacity: 0.95;
      white-space: nowrap;
    }

    .search-item-sub{
      font-size: 10px;
      color: #aaaaaa;
      line-height: 1.35;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .search-item-path{
      font-size: 9px;
      color: #6f6f6f;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }
/* === Search highlight (как Ctrl+F) === */
    mark.search-highlight{
      background: rgba(255, 0, 0, 0.14);
      color: inherit;
      padding: 0 1px;
      border-bottom: 2px solid rgba(255, 0, 0, 0.95);
      border-radius: 2px;
    }


/* === FIX: only dashed divider between hierarchy and details; draggable on dashed === */
.sidebar{
  border-right: none !important; /* remove extra dashed line on sidebar edge */
}
.sidebar-resizer{
  background: transparent !important; /* remove solid line */
  width: 6px !important;             /* keep hit area for resizing */
  position: relative;
}
.sidebar-resizer::before{
  content: '' !important;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  border-left: 2px dashed #ffffff;
}



/* === TOP HIERARCHY LAYOUT (hierarchy moved from left to top) === */
#appRoot.app-vertical{
  --hierH: 260px;
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0;
  gap: 12px;
}

.sh-topbar{
  display: grid;
  /* ПОИСК (слева) шире, ПУТЬ (справа) компактнее */
  grid-template-columns: minmax(0, 1.8fr) minmax(260px, 1fr);
  gap: 12px;
  align-items: stretch;
  border: 1px solid #ffffff;
  border-radius: 10px;
  background: #050505;
  padding: 10px 12px;
  overflow: visible;
}

.topbar-block{
  min-width: 0;
  align-self: stretch;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.topbar-search{
  position: relative;
  z-index: 70;
}

.topbar-path{
  position: relative;
  z-index: 10;
}

@media (max-width: 900px){
  .sh-topbar{ grid-template-columns: 1fr; }
}
.hierarchy-top-wrapper{
  position: relative;
  border: 1px solid #ffffff;
  border-radius: 10px;
  background: #050505;
  padding: 10px 12px;

  /* статичный размер (управляется пользователем) */
  height: var(--hierH);
  min-height: var(--hierH);
  max-height: var(--hierH);
  flex: 0 0 var(--hierH);

  overflow: auto;
}

/* --- hierarchy resize handle (bottom-right) --- */
.hier-resize-handle{
  position: absolute;
  right: 10px;
  bottom: 10px;
  width: 16px;
  height: 16px;
  cursor: ns-resize;
  opacity: 0.75;
  pointer-events: auto;
}
.hier-resize-handle::before,
.hier-resize-handle::after{
  content: '';
  position: absolute;
  right: 0;
  bottom: 0;
  width: 14px;
  height: 14px;
  border-right: 1px solid #ffffff;
  border-bottom: 1px solid #ffffff;
  opacity: 0.65;
}
.hier-resize-handle::after{
  width: 9px;
  height: 9px;
  opacity: 0.95;
}
.hier-resize-handle:hover{ opacity: 1; }
body.hierarchy-resizing{
  cursor: ns-resize !important;
  user-select: none !important;
}
body.hierarchy-resizing *{
  user-select: none !important;
}


.main-panel-full{
  padding-left: 0;
}

/* FIX: вертикальная раскладка — главный блок занимает остаток высоты, а "ИЕРАРХИЯ" имеет фиксированный размер */
#appRoot.app-vertical > .sh-topbar{
  flex: 0 0 auto;
}
#appRoot.app-vertical > .hierarchy-top-wrapper{
  flex-shrink: 0;
}
#appRoot.app-vertical > .main-panel{
  height: auto;      /* снимаем конфликт с height:100% */
  flex: 1 1 auto;    /* главный контент растёт/сжимается, не давя "ИЕРАРХИЯ" */
  min-height: 0;     /* чтобы внутренний скролл #detailsRoot работал корректно */
}

/* allow hierarchy labels to wrap now that hierarchy is on top */
.hier-name{
  white-space: normal !important;
  overflow: visible !important;
  text-overflow: clip !important;
  line-height: 1.35;
}

/* hierarchy rows get full width */
#treeRoot .hier-row{
  width: 100%;
}

/* search dropdown inside topbar */
.sh-topbar .sidebar-search-results{
  left: 0;
  right: 0;
}

/* responsive */
@media (max-width: 960px){
  .sh-topbar{
    grid-template-columns: 1fr;
  }  #appRoot.app-vertical{
    --hierH: 320px;
  }
}

  </style>

  <!-- интеграция с Item Key + light skin -->
  <style>
    /* не даём модулю "захватить" весь viewport фиксированными слоями */
    .sh-app-host {
      width: min(1180px, 92vw);
      height: clamp(620px, 78vh, 860px);
      margin: 0 auto;
      border: 1px solid rgba(0,0,0,0.14);
      background: rgba(255,255,255,0.86);
      overflow: hidden;
      position: relative;
    }

    /* экраны/оверлеи внутри контейнера, а не поверх всего сайта */
    .sh-app-host .screen {
      position: absolute !important;
      inset: 0 !important;
      background: transparent !important;
      color: rgba(0,0,0,0.82) !important;
    }
    .sh-app-host .overlay,
    .sh-app-host .modal-backdrop,
    .sh-app-host .brain-story-overlay {
      position: absolute !important;
      inset: 0 !important;
    }

    /* сами оверлеи делаем светлыми */
    .sh-app-host .overlay {
      background: rgba(255,255,255,0.78) !important;
      backdrop-filter: blur(6px);
    }
    .sh-app-host .modal-backdrop {
      background: rgba(255,255,255,0.78) !important;
      backdrop-filter: blur(6px);
    }
    .sh-app-host .brain-story-overlay {
      background: rgba(255,255,255,0.78) !important;
      backdrop-filter: blur(6px);
    }

    body.page-student-helper {
      margin: 0 !important;
      background: transparent !important;
      color: rgba(0,0,0,0.82) !important;
    }

    .sh-app-host .sh-topbar,
    .sh-app-host .hierarchy-top-wrapper,
    .sh-app-host .sidebar-tree-wrapper,
    .sh-app-host .section,
    .sh-app-host .modal-card,
    .sh-app-host .overlay-card {
      background: rgba(255,255,255,0.86) !important;
      border-color: rgba(0,0,0,0.14) !important;
      color: rgba(0,0,0,0.82) !important;
    }

    .sh-app-host .sidebar {
      border-right-color: rgba(0,0,0,0.22) !important;
    }

    .sh-app-host .sidebar-breadcrumb-label,
    .sh-app-host .hier-title,
    .sh-app-host .section-title,
    .sh-app-host .seg-title {
      color: rgba(0,0,0,0.72) !important;
    }

    .sh-app-host .hint,
    .sh-app-host .sidebar-breadcrumb-sub,
    .sh-app-host .sidebar-help {
      color: rgba(0,0,0,0.55) !important;
    }

    .sh-app-host .btn,
    .sh-app-host .hier-fx-btn {
      background: rgba(255,255,255,0.92) !important;
      color: rgba(0,0,0,0.82) !important;
      border-color: rgba(0,0,0,0.14) !important;
    }
    .sh-app-host .btn:hover,
    .sh-app-host .hier-fx-btn:hover {
      background: rgba(0,0,0,0.06) !important;
    }

    .sh-app-host .form-input,
    .sh-app-host .form-select,
    .sh-app-host .form-textarea {
      background: rgba(255,255,255,0.92) !important;
      color: rgba(0,0,0,0.82) !important;
      border-color: rgba(0,0,0,0.14) !important;
    }
    .sh-app-host .form-input::placeholder,
    .sh-app-host .form-textarea::placeholder {
      color: rgba(0,0,0,0.40) !important;
    }

    .sh-app-host .sidebar-search-results {
      background: rgba(255,255,255,0.94) !important;
      border-color: rgba(0,0,0,0.14) !important;
    }

    .sh-app-host .hier-row-category {
      color: rgba(0,0,0,0.82) !important;
      border-left-color: rgba(0,0,0,0.22) !important;
    }
    .sh-app-host .hier-row-characteristic {
      color: rgba(0,0,0,0.62) !important;
      border-left-color: rgba(0,0,0,0.22) !important;
    }

    /* таблицы/границы */
    .sh-app-host table,
    .sh-app-host th,
    .sh-app-host td {
      border-color: rgba(0,0,0,0.14) !important;
    }

    /* небольшая "шапка" страницы */
    .helper-hub {
      width: min(920px, 92vw);
      margin: 0 auto;
      display: grid;
      gap: 14px;
      text-align: center;
    }
    .helper-title h1 {
      margin: 0;
      font-size: 14px;
      letter-spacing: 5px;
      text-transform: uppercase;
    }
    .helper-title .sub {
      font-size: 11px;
      letter-spacing: 3.5px;
      text-transform: uppercase;
      color: rgba(0,0,0,0.55);
    }

    @media (max-width: 680px) {
      .sh-app-host {
        height: 78vh;
        min-height: 560px;
      }
    }
  
      /* layout + scrolling fixes for Item Key frame */
    html, body { height: auto; min-height: 100%; }

    /* ВАЖНО: даём странице скролл (в исходнике overflow был hidden) */
    body.page-student-helper{
      background: #ffffff !important;
      color: rgba(0,0,0,0.82) !important;
      overflow-x: hidden !important;
      overflow-y: auto !important;
    }

    /* Центральная зона: всегда по центру и не залезает на боковые рейлы */
    .center-stage{
      width: 100%;
      max-width: 1280px;
      margin: 0 auto;
      box-sizing: border-box;
      padding: 92px clamp(90px, 12vw, 210px) 64px; /* учитываем рейлы слева/справа */
    }

    /* На узких экранах рейлы обычно становятся «поверх» — убираем большие отступы */
    @media (max-width: 900px){
      .center-stage{ padding: 88px 18px 56px; }
    }

    /* Внутренний хаб держим аккуратно по центру */
    .helper-hub{ justify-items: center; }

    /* Хост приложения не должен вылезать за ширину центра */
    .sh-app-host{
      width: min(1180px, 100%);
      max-width: 100%;
    }

    /* FIX: местами оставался белый текст на светлом фоне */
    .sh-app-host .brain-story-card,
    .sh-app-host .brain-story-card p,
    .sh-app-host .overlay-progress,
    .sh-app-host .overlay-subtitle,
    .sh-app-host .quiz-message,
    .sh-app-host .facts-footer-left,
    .sh-app-host .search-section-title,
    .sh-app-host .search-section-count,
    .sh-app-host .search-section-hints,
    .sh-app-host .search-item-sub,
    .sh-app-host .search-item-path,
    .sh-app-host .tree-meta,
    .sh-app-host .rootbar-label,
    .sh-app-host .rootbar-section-title{
      color: rgba(0,0,0,0.62) !important;
    }

    .sh-app-host .overlay-title,
    .sh-app-host .modal-title,
    .sh-app-host .quiz-question,
    .sh-app-host .facts-text,
    .sh-app-host .search-item-title-main{
      color: rgba(0,0,0,0.86) !important;
    }

    /* Бейджи в поиске оставляем «тёмными», чтобы было читабельно */
    .sh-app-host .search-badge{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
      border-color: rgba(0,0,0,0.18) !important;
    }
  

    /* === Item Key: белая готика для поисковика (чтобы не был "чёрным блоком") === */
    .sh-app-host .sidebar-search-results{
      box-shadow: 0 16px 44px rgba(0,0,0,0.10) !important;
      backdrop-filter: blur(6px);
    }

    .sh-app-host .searchbox-clear{
      background: rgba(255,255,255,0.92) !important;
      color: rgba(0,0,0,0.82) !important;
      border-color: rgba(0,0,0,0.14) !important;
      opacity: 0.95;
    }
    .sh-app-host .searchbox-clear:hover{
      background: rgba(0,0,0,0.06) !important;
      border-color: rgba(0,0,0,0.22) !important;
      opacity: 1;
    }

    .sh-app-host .search-section{
      border-color: rgba(0,0,0,0.12) !important;
      background: rgba(255,255,255,0.00) !important;
    }
    .sh-app-host .search-section-header{
      background: rgba(255,255,255,0.88) !important;
      border-bottom-color: rgba(0,0,0,0.12) !important;
    }
    .sh-app-host .search-res-body,
    .sh-app-host .search-sug-body{
      background: transparent !important;
    }

    .sh-app-host .search-item:hover{
      background: rgba(0,0,0,0.05) !important;
    }
    .sh-app-host .search-item.active{
      background: rgba(0,0,0,0.07) !important;
      outline: 1px solid rgba(0,0,0,0.14) !important;
    }

    .sh-app-host .search-sug-chip{
      background: rgba(255,255,255,0.92) !important;
      color: rgba(0,0,0,0.82) !important;
      border-color: rgba(0,0,0,0.14) !important;
    }
    .sh-app-host .search-sug-chip:hover{
      background: rgba(0,0,0,0.06) !important;
      border-color: rgba(0,0,0,0.22) !important;
    }

    .sh-app-host .kbd{
      background: rgba(255,255,255,0.86) !important;
      border-color: rgba(0,0,0,0.12) !important;
      color: rgba(0,0,0,0.62) !important;
    }

    .sh-app-host .search-item-year{
      color: rgba(0,0,0,0.58) !important;
    }

    /* ------------------------------
       QUIZ (SMART TESTS)
    --------------------------------*/
    .sh-app-host .quiz-setup-grid{
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 12px;
      min-height: 360px;
    }
    @media (max-width: 920px){
      .sh-app-host .quiz-setup-grid{
        grid-template-columns: 1fr;
      }
    }
    .sh-app-host .quiz-types{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .sh-app-host .quiz-types button{
      flex: 1 1 auto;
      min-width: 140px;
    }
    .sh-app-host .quiz-setup-opts{
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .sh-app-host .quiz-check{
      display:flex;
      align-items:center;
      gap: 8px;
      font-size: 12px;
      user-select: none;
    }
    .sh-app-host .quiz-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .sh-app-host .quiz-row-label{
      font-size: 11px;
      opacity: 0.75;
      white-space: nowrap;
    }
    .sh-app-host .quiz-pattern-list{
      margin-top: 10px;
      border: 1px solid var(--line2);
      background: var(--wash);
      max-height: 320px;
      overflow: auto;
      padding: 8px;
    }
    .sh-app-host .quiz-pattern-item{
      display:flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 8px 8px;
      border: 1px solid transparent;
      cursor: pointer;
    }
    .sh-app-host .quiz-pattern-item:hover{
      border-color: var(--line2);
      background: rgba(0,0,0,0.03);
    }
    .sh-app-host .quiz-pattern-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .sh-app-host .quiz-pattern-name{
      font-size: 12px;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .sh-app-host .quiz-pattern-meta{
      font-size: 10px;
      opacity: 0.65;
      white-space: nowrap;
      flex: 0 0 auto;
    }
    .sh-app-host .quiz-card{
      border: 1px solid var(--line2);
      background: var(--wash);
      padding: 14px;
    }

.sh-app-host .quiz-context{
  display:flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  padding: 8px 10px;
  border: 1px solid var(--line2);
  background: rgba(0,0,0,0.03);
  font-size: 11px;
  letter-spacing: 0.10em;
  text-transform: uppercase;
  margin-bottom: 10px;
  flex-wrap: wrap;
}
.sh-app-host .quiz-context .muted{
  opacity: 0.72;
  letter-spacing: 0.08em;
}
    .sh-app-host .quiz-question{
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }
    .sh-app-host .quiz-prompt{
      font-size: 14px;
      line-height: 1.45;
      padding: 10px;
      border: 1px dashed var(--line2);
      background: rgba(255,255,255,0.6);
      margin-bottom: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .sh-app-host .quiz-choices{
      display: grid;
      gap: 8px;
    }
    .sh-app-host .quiz-choice{
      text-align: left;
      padding: 10px 10px;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,0.72);
      font-size: 13px;
      cursor: pointer;
    }
    .sh-app-host .quiz-choice:hover{
      background: rgba(0,0,0,0.03);
    }
    .sh-app-host .quiz-choice[disabled]{
      cursor: default;
      opacity: 0.9;
    }
    .sh-app-host .quiz-choice.correct{
      outline: 2px solid rgba(16,185,129,0.55);
      border-color: rgba(16,185,129,0.55);
      background: rgba(16,185,129,0.08);
    }
    .sh-app-host .quiz-choice.wrong{
      outline: 2px solid rgba(239,68,68,0.45);
      border-color: rgba(239,68,68,0.45);
      background: rgba(239,68,68,0.08);
    }
    .sh-app-host .quiz-message{
      margin-top: 10px;
      border-top: 1px dashed var(--line2);
      padding-top: 10px;
      font-size: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    .sh-app-host .quiz-meta{
      margin-top: 10px;
      font-size: 11px;
      opacity: 0.72;
      display:flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .sh-app-host .quiz-footer{
      display:flex;
      justify-content: space-between;
      gap: 10px;
    }
    .sh-app-host .quiz-modal-card{
      width: min(740px, 92vw);
    }

    .sh-app-host .modal-backdrop{
      z-index: 9999 !important;
    }
</style>

  <!-- === FIXES (2025-12-24): цвет "ОТСЕК" + один нормальный скролл страницы === -->
  <style>
    /* 1) Цвет метки "ОТСЕК" (и в списке и в легенде) — было белое по белому на light-skin */
    .sh-app-host .legend-badge-cell{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
      border-color: rgba(0,0,0,0.18) !important;
    }
    .sh-app-host .legend-badge-patt{
      color: rgba(0,0,0,0.72) !important;
      border-color: rgba(0,0,0,0.18) !important;
      background: rgba(255,255,255,0.72) !important;
    }

    /* метки в самой иерархии */
    .sh-app-host .hier-row-category .hier-tag{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
      border-color: rgba(0,0,0,0.18) !important;
    }
    .sh-app-host .hier-row-characteristic .hier-tag{
      background: rgba(255,255,255,0.86) !important;
      color: rgba(0,0,0,0.62) !important;
      border-color: rgba(0,0,0,0.18) !important;
    }

    /* 2) Нормальный скролл: один скролл страницы, без "доп. окна" в характеристиках */
    html, body{
      height: auto !important;
      min-height: 100% !important;
    }
    body.page-student-helper{
      overflow-y: auto !important;
      overflow-x: hidden !important;
    }

    /* хост приложения должен быть "в потоке" и расти по контенту */
    .sh-app-host{
      height: auto !important;
      min-height: 620px;
      overflow: visible !important; /* чтобы не появлялись внутренние ловушки скролла */
    }

    /* экраны внутри хоста — больше не absolute (иначе хост не растёт по высоте) */
    .sh-app-host .screen{
      position: relative !important;
      inset: auto !important;
    }
    .sh-app-host .screen-inner{
      height: auto !important;
      overflow: visible !important;
    }

    /* убираем внутренний скролл с "характеристик" — пусть растёт и скроллится страницей */
    #detailsRoot{
      overflow: visible !important;
      padding-right: 0 !important;
    }

    /* снимаем принудительный flex-рост, который делал внутренний скролл */
    #appRoot.app-vertical{
      height: auto !important;
      min-height: 0 !important;
    }
    #appRoot.app-vertical > .main-panel{
      flex: 0 0 auto !important;
      min-height: auto !important;
      height: auto !important;
    }

    /* иерархию оставляем компактной, но БЕЗ "второго скролла", когда контента мало */
    .hierarchy-top-wrapper{
      overflow: visible; /* базово */
    }
    @media (max-width: 680px){
      .sh-app-host{ min-height: 560px; }
    }
  </style>


  <!-- === UI POLISH (2025-12-24): готика + аккуратная верстка, без поломки логики === -->
  <style>
    /* ------------------------------
       GLOBAL PAGE (Item Key frame)
    --------------------------------*/
    body.page-student-helper{
      --paper: #ffffff;
      --ink: rgba(0,0,0,0.86);
      --ink2: rgba(0,0,0,0.72);
      --muted: rgba(0,0,0,0.55);
      --line: rgba(0,0,0,0.18);
      --line2: rgba(0,0,0,0.12);
      --wash: rgba(0,0,0,0.045);
      --wash2: rgba(0,0,0,0.075);
      --shadow: 0 18px 48px rgba(0,0,0,0.10);
      background: var(--paper) !important;
      color: var(--ink) !important;
      line-height: 1.45;
    }

    /* аккуратный центр + одинаковые отступы */
    .page-student-helper .center-stage{
      padding-top: 96px;
      padding-bottom: 72px;
    }

    .page-student-helper .helper-hub{
      gap: 18px;
    }

    .page-student-helper .helper-title{
      padding: 10px 0 4px;
    }

    .page-student-helper .helper-title h1{
      font-size: clamp(14px, 1.25vw, 18px);
      letter-spacing: 0.42em;
      line-height: 1.25;
    }

    .page-student-helper .helper-title .sub{
      margin-top: 8px;
      letter-spacing: 0.30em;
      color: var(--muted);
    }

    /* ------------------------------
       APP HOST (обёртка приложения)
    --------------------------------*/
    .page-student-helper .sh-app-host{
      border: 1px solid var(--line) !important;
      background: rgba(255,255,255,0.92) !important;
      box-shadow: var(--shadow);
      border-radius: 0 !important;      /* готика — острые углы */
      overflow: visible !important;     /* один нормальный скролл страницы */
    }

    /* лёгкие "угловые метки" (готика, но не крикливо) */
    .page-student-helper .sh-app-host::before{
      content: "";
      position: absolute;
      inset: 10px;
      pointer-events: none;
      opacity: 0.35;
      background:
        linear-gradient(var(--ink) 0 0) left top/18px 1px no-repeat,
        linear-gradient(var(--ink) 0 0) left top/1px 18px no-repeat,
        linear-gradient(var(--ink) 0 0) right top/18px 1px no-repeat,
        linear-gradient(var(--ink) 0 0) right top/1px 18px no-repeat,
        linear-gradient(var(--ink) 0 0) left bottom/18px 1px no-repeat,
        linear-gradient(var(--ink) 0 0) left bottom/1px 18px no-repeat,
        linear-gradient(var(--ink) 0 0) right bottom/18px 1px no-repeat,
        linear-gradient(var(--ink) 0 0) right bottom/1px 18px no-repeat;
      mix-blend-mode: multiply;
    }

    /* ------------------------------
       APP LAYOUT: делаем читабельнее
    --------------------------------*/
    /* снимаем "приложение = 100% высоты" и фиксированную высоту ИЕРАРХИИ:
       пусть блоки растут по контенту, а скролл — один (страницы) */
    #appRoot.app-vertical{
      height: auto !important;
      min-height: 0 !important;
      gap: 14px !important;
    }

    .hierarchy-top-wrapper{
      flex: 0 0 auto !important;
      height: auto !important;
      min-height: 0 !important;
      max-height: none !important;
      overflow: visible !important;
      padding: 12px 14px !important;
      border-radius: 0 !important;
    }

    /* если ты захочешь вернуть "ручную высоту" — просто убери display:none */
    .hier-resize-handle{ display: none !important; }

    .sh-topbar{
      border-radius: 0 !important;
      padding: 12px 14px !important;
      grid-template-columns: minmax(260px, 1fr) minmax(360px, 1.65fr) !important;
      gap: 14px !important;
    }

    @media (max-width: 960px){
      .sh-topbar{
        grid-template-columns: 1fr !important;
      }
    }

    .topbar-block{
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #breadcrumb{
      padding: 8px 10px;
      border: 1px solid var(--line2);
      background: rgba(255,255,255,0.74);
      border-radius: 0;
      min-height: 34px;
      display: flex;
      align-items: center;
    }

    /* заголовки в приложении */
    .hier-title,
    .sidebar-breadcrumb-label{
      font-size: 10px !important;
      letter-spacing: 0.22em !important;
      color: var(--ink2) !important;
    }

    .main-header-line{
      align-items: center !important;
      gap: 12px;
      padding-bottom: 10px !important;
      margin-bottom: 14px !important;
      border-bottom-color: var(--line) !important;
    }

    .main-title-wrapper{
      display: flex;
      align-items: baseline;
      gap: 10px;
    }

    #headerActions{
      align-items: center;
      gap: 8px !important;
      flex-wrap: wrap;
    }

    /* ------------------------------
       BUTTONS / INPUTS (единый стиль)
    --------------------------------*/
    .sh-app-host .btn,
    .sh-app-host .hier-fx-btn,
    .sh-app-host .brain-menu-btn,
    .sh-app-host .search-sug-chip{
      border-radius: 0 !important;
      border-width: 1px !important;
      padding: 7px 12px !important;
      min-height: 32px;
      line-height: 1;
      transition: transform 0.12s ease, background 0.12s ease, color 0.12s ease, border-color 0.12s ease;
    }

    .sh-app-host .btn:hover,
    .sh-app-host .hier-fx-btn:hover{
      background: var(--wash) !important;
      transform: translateY(-1px);
    }

    .sh-app-host .btn:active,
    .sh-app-host .hier-fx-btn:active{
      transform: translateY(0px);
      background: var(--wash2) !important;
    }

    .sh-app-host .btn-primary{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
      border-color: rgba(0,0,0,0.20) !important;
    }
    .sh-app-host .btn-primary:hover{
      background: rgba(0,0,0,0.78) !important;
    }

    .sh-app-host .btn-danger{
      border-color: rgba(140, 18, 56, 0.55) !important;
      color: rgba(140, 18, 56, 0.95) !important;
      background: rgba(140, 18, 56, 0.06) !important;
    }
    .sh-app-host .btn-danger:hover{
      background: rgba(140, 18, 56, 0.10) !important;
      border-color: rgba(140, 18, 56, 0.70) !important;
    }

    .sh-app-host .form-input,
    .sh-app-host .form-select,
    .sh-app-host .form-textarea{
      border-radius: 0 !important;
      padding: 8px 10px !important;
      border-color: var(--line) !important;
      background: rgba(255,255,255,0.92) !important;
      color: var(--ink) !important;
      transition: box-shadow 0.12s ease, border-color 0.12s ease;
    }

    .sh-app-host .form-input:focus,
    .sh-app-host .form-select:focus,
    .sh-app-host .form-textarea:focus{
      outline: none;
      border-color: rgba(0,0,0,0.28) !important;
      box-shadow: 0 0 0 3px rgba(0,0,0,0.10);
    }

    .sh-app-host .form-label{
      color: var(--muted) !important;
      letter-spacing: 0.20em !important;
    }

    /* ------------------------------
       PANELS / SECTIONS
    --------------------------------*/
    .sh-app-host .section,
    .sh-app-host .sidebar-tree-wrapper,
    .sh-app-host .search-section,
    .sh-app-host .overlay-card,
    .sh-app-host .modal-card{
      border-radius: 0 !important;
      border-color: var(--line) !important;
      box-shadow: none;
    }

    .sh-app-host .section{
      padding: 10px 12px !important;
      margin-bottom: 12px !important;
    }

    .sh-app-host .section-header{
      gap: 10px;
      padding-bottom: 6px;
      border-bottom: 1px dashed var(--line2);
    }

    .sh-app-host .section-body{
      margin-top: 10px !important;
      line-height: 1.55;
    }

    .sh-app-host .child-card{
      border-color: var(--line) !important;
      border-radius: 0 !important;
      padding: 8px 10px !important;
    }

    /* ------------------------------
       SEARCH: выравнивание и читабельность
    --------------------------------*/
    .sh-app-host .sidebar-search-results{
      border-radius: 0 !important;
      padding: 8px !important;
    }

    .sh-app-host .search-section-header{
      padding: 10px 12px !important;
    }

    .sh-app-host .search-item{
      padding: 10px 10px !important;
      border-radius: 0 !important;
      border: 1px solid transparent;
    }

    .sh-app-host .search-item:hover{
      border-color: var(--line2);
      background: var(--wash) !important;
    }

    /* ------------------------------
       OVERLAYS / MODALS: центр и воздух
    --------------------------------*/
    .sh-app-host .overlay-card{
      padding: 18px 18px 14px !important;
      gap: 12px !important;
    }

    .sh-app-host .modal-card{
      padding: 16px 16px 14px !important;
      gap: 10px !important;
    }

    .sh-app-host .overlay-header,
    .sh-app-host .quiz-footer{
      border-color: var(--line2) !important;
    }
  

    
</style>


  <!-- === FIX (2025-12-24): тесты были "белое по белому" после перехода на светлую тему === -->
  <style>
    /* Ключевая причина: базовые стили тестов были рассчитаны на чёрный фон (#000),
       а в light-skin кнопки/текст сливались с белой карточкой оверлея. */

    /* Заголовки/текст теста */
    .sh-app-host .overlay-title,
    .sh-app-host .quiz-question,
    .sh-app-host .facts-text{
      color: rgba(0,0,0,0.90) !important;
    }
    .sh-app-host .overlay-progress,
    .sh-app-host .overlay-subtitle,
    .sh-app-host .quiz-message{
      color: rgba(0,0,0,0.62) !important;
    }

    /* Варианты ответа (основная проблема видимости) */
    .sh-app-host .btn.btn-option{
      background: rgba(255,255,255,0.96) !important;
      color: rgba(0,0,0,0.88) !important;
      border-color: rgba(0,0,0,0.22) !important;
      box-shadow: 0 10px 28px rgba(0,0,0,0.06);
    }
    .sh-app-host .btn.btn-option:hover{
      background: rgba(0,0,0,0.045) !important;
      border-color: rgba(0,0,0,0.32) !important;
      transform: translateY(-1px);
    }
    .sh-app-host .btn-option-selected{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
      border-color: rgba(0,0,0,0.30) !important;
    }

    /* Правильно/неправильно — держим контраст на белом фоне */
    .sh-app-host .btn-option-correct{
      background: rgba(22, 126, 61, 0.96) !important;
      border-color: rgba(22, 126, 61, 0.70) !important;
      color: #ffffff !important;
    }
    .sh-app-host .btn-option-wrong{
      background: rgba(143, 18, 56, 0.92) !important;
      border-color: rgba(143, 18, 56, 0.70) !important;
      color: #ffffff !important;
    }

    /* Оверлей/карточка теста: принудительно тёмный слой (чтобы текст не терялся на белых фонах Item Key) */
    .sh-app-host .overlay{
      background: rgba(0,0,0,0.92) !important;
      z-index: 9999 !important;
    }
    .sh-app-host .overlay-card{
      background: #000000 !important;
      color: #ffffff !important;
      border-color: rgba(255,255,255,0.55) !important;
      box-shadow: 0 22px 60px rgba(0,0,0,0.55);
    }
    .sh-app-host .overlay-title,
    .sh-app-host .quiz-question,
    .sh-app-host .quiz-message,
    .sh-app-host .facts-text{
      color: #ffffff !important;
    }
    .sh-app-host .overlay-subtitle,
    .sh-app-host .overlay-progress{
      color: rgba(255,255,255,0.70) !important;
    }
    .sh-app-host .overlay-header,
    .sh-app-host .quiz-footer{
      border-color: rgba(255,255,255,0.28) !important;
    }
    /* FIX (2025-12-24): тест мог выглядеть "пустым" из‑за конфликта стилей с Item Key
       (иногда .overlay-header/контейнеры растягивались и перекрывали body+footer).
       Жёстко закрепляем раскладку оверлея внутри .sh-app-host. */
    .sh-app-host .overlay-card{
      display:flex !important;
      flex-direction:column !important;
      align-items:stretch !important;
    }
    .sh-app-host .overlay-header{
      position:relative !important;
      inset:auto !important;
      height:auto !important;
      display:flex !important;
    }
    .sh-app-host .overlay-body{
      position:relative !important;
      flex: 1 1 auto !important;
      min-height: 0 !important;
      overflow: auto !important;
      display:block !important;
    }
    .sh-app-host .quiz-footer{
      position:relative !important;
      inset:auto !important;
      height:auto !important;
      display:flex !important;
    }
</style>


  <!-- === PATH UI (2025-12-24): Windows-like breadcrumb + stable search dropdown === -->
  <style>
    /* breadcrumb as "address bar" (Windows Explorer vibe) */
    .sh-app-host .sh-topbar{ overflow: visible !important; }
    .sh-app-host .topbar-search{ position: relative; z-index: 70; }
    .sh-app-host .sidebar-search-results{ z-index: 80; }

    #breadcrumb{
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      gap: 0;
      white-space: nowrap;
      overflow-x: auto;
      overflow-y: hidden;
      text-transform: none !important;
      letter-spacing: 0.06em !important;
      word-break: normal !important;
      max-width: 100%;
      scrollbar-width: thin;
      scroll-behavior: smooth;
    }

    #breadcrumb::-webkit-scrollbar{ height: 8px; }
    #breadcrumb::-webkit-scrollbar-thumb{ background: rgba(0,0,0,0.18); }
    #breadcrumb::-webkit-scrollbar-track{ background: rgba(0,0,0,0.06); }

    #breadcrumb .breadcrumb-item{
      display: inline-flex;
      align-items: center;
      min-height: 30px;
      padding: 6px 10px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.86);
      color: rgba(0,0,0,0.86);
      cursor: pointer;
      user-select: none;
    }
    #breadcrumb .breadcrumb-item:hover{
      background: rgba(0,0,0,0.05);
      border-color: rgba(0,0,0,0.18);
    }
    #breadcrumb .breadcrumb-item:active{
      background: rgba(0,0,0,0.08);
    }

    #breadcrumb .breadcrumb-item-current{
      cursor: default;
      background: rgba(0,0,0,0.86);
      color: #ffffff;
      border-color: rgba(0,0,0,0.20);
    }

    #breadcrumb .breadcrumb-sep{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
      color: rgba(0,0,0,0.42);
      user-select: none;
    }

    /* search dropdown: always below the input and not clipped */
    .topbar-search .sidebar-search-results{
      top: calc(100% + 6px);
    }
  </style>

    <!-- === TOPBAR (2025-12-25 v6): сетка заново — ПОИСК слева шире, КАТЕГОРИИ справа компактнее, высота 1:1, острые рамки === -->
  <style>
    .sh-app-host .sh-topbar{
      --tbControlH: 56px;
      --tbLabelH: 14px;
      --tbGap: 8px;

      display: grid !important;
      grid-template-columns: minmax(260px, 1fr) minmax(360px, 1.65fr) !important;
      gap: 14px !important;
      align-items: stretch !important;

      padding: 12px 14px !important;
      border: 1px solid var(--line2, rgba(0,0,0,0.55)) !important;
      background: var(--paper, rgba(255,255,255,0.85)) !important;
      border-radius: 0 !important;
      overflow: visible !important;
    }

    .sh-app-host .sh-topbar .topbar-block{
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: var(--tbGap);
      justify-content: flex-start;
      align-self: stretch;
    }

    .sh-app-host .sh-topbar .sidebar-breadcrumb-label{
      height: var(--tbLabelH);
      line-height: var(--tbLabelH);
      white-space: nowrap;
      font-size: 10px !important;
      letter-spacing: 0.22em !important;
      text-transform: uppercase;
      color: var(--ink2, rgba(0,0,0,0.65)) !important;
    }

    /* ПОИСК */
    .sh-app-host .sh-topbar .topbar-search{ position: relative; z-index: 70; }
    .sh-app-host .sh-topbar .searchbox{
      position: relative;
      height: var(--tbControlH);
      min-height: var(--tbControlH);
      border: 1px solid var(--line2, rgba(0,0,0,0.55)) !important;
      background: var(--paper, rgba(255,255,255,0.92)) !important;
      border-radius: 0 !important;
      display: flex;
      align-items: center;
      padding: 0;
      box-sizing: border-box;
    }
    .sh-app-host .sh-topbar .sidebar-search-input{
      height: 100% !important;
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
      outline: none !important;
      padding: 0 44px 0 12px !important;
      line-height: 1.1;
    }

    .sh-app-host .sidebar-search-results{ border-radius: 0 !important; }
    .sh-app-host .sh-topbar .searchbox-clear{
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      width: 28px;
      height: 28px;
      border-radius: 0 !important;
    }

    /* КАТЕГОРИИ / ПУТЬ */
    .sh-app-host .sh-topbar .topbar-path{ position: relative; z-index: 10; }
    .sh-app-host .sh-topbar #breadcrumb{
            margin: 0 !important;
height: var(--tbControlH);
      min-height: var(--tbControlH);
      border: 1px solid var(--line2, rgba(0,0,0,0.55)) !important;
      background: var(--paper, rgba(255,255,255,0.92)) !important;
      border-radius: 0 !important;

      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      gap: 0;
      white-space: nowrap;
      overflow-x: auto;
      overflow-y: hidden;

      padding: 6px 8px;
      box-sizing: border-box;

      scrollbar-gutter: stable both-edges;
      scrollbar-width: thin;
      scroll-behavior: smooth;
    }
    .sh-app-host .sh-topbar #breadcrumb::-webkit-scrollbar{ height: 10px; }
    .sh-app-host .sh-topbar #breadcrumb::-webkit-scrollbar-thumb{ background: rgba(0,0,0,0.22); }
    .sh-app-host .sh-topbar #breadcrumb::-webkit-scrollbar-track{ background: rgba(0,0,0,0.08); }

    /* острые углы у сегментов */
    .sh-app-host #breadcrumb .breadcrumb-item,
    .sh-app-host #breadcrumb .breadcrumb-item-current{
      border-radius: 0 !important;
      min-height: 30px;
      padding: 6px 10px;
    }
    .sh-app-host #breadcrumb .breadcrumb-sep{ border-radius: 0 !important; }

    @media (max-width: 960px){
      .sh-app-host .sh-topbar{ grid-template-columns: 1fr !important; }
    }
  </style>
<!-- === FIX (2025-12-25): hover = чёрный фон + белый текст (без "чёрного на чёрном") === -->
  <style>
    /* Если где-то ховер делает фон тёмным, принудительно держим белый текст */
    .sh-app-host .btn:hover,
    .sh-app-host .hier-fx-btn:hover,
    .sh-app-host .brain-menu-btn:hover,
    .sh-app-host .search-sug-chip:hover,
    .sh-app-host .searchbox-clear:hover,
    .sh-app-host .segmented button:hover,
    .sh-app-host .modal-close:hover,
    .sh-app-host button.btn:hover{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
      border-color: rgba(0,0,0,0.22) !important;
    }

    /* чтобы не ломать первичную "тёмную" кнопку: остаётся белой на чёрном */
    .sh-app-host .btn-primary:hover{
      background: rgba(0,0,0,0.78) !important;
      color: #ffffff !important;
    }
  </style>


  <!-- === FIX v2 (2025-12-25): дочерние карточки/кнопки и активный хлебный путь === -->
  <style>
    /* 1) "Содержимое категории" — child-card становится тёмным и текст белым */
    .sh-app-host .child-card:hover,
    .sh-app-host .child-card:hover *{
      color: #ffffff !important;
    }
    .sh-app-host .child-card:hover{
      background: rgba(0,0,0,0.86) !important;
      border-color: rgba(0,0,0,0.22) !important;
    }

    /* 2) Активный элемент в хлебных крошках не должен светлеть на hover */
    #breadcrumb .breadcrumb-item-current:hover{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
      border-color: rgba(0,0,0,0.20) !important;
    }
  </style>


  <!-- === FIX v3 (2025-12-25): иерархия — инверсия логотипа "отсек" при hover === -->
  <style>
    /* Общий hover строки отсека */
    .sh-app-host .hier-row:hover{
      background: rgba(0,0,0,0.86) !important;
      color: #ffffff !important;
    }

    /* Лого "отсек": по умолчанию как есть */
    .sh-app-host .hier-row .hier-badge{
      background: rgba(0,0,0,0.86);
      color: #ffffff;
      border: 1px solid rgba(255,255,255,0.25);
    }

    /* При hover строки — инверсия бейджа */
    .sh-app-host .hier-row:hover .hier-badge{
      background: #ffffff !important;
      color: #000000 !important;
      border-color: rgba(0,0,0,0.35) !important;
    }
  </style>


  
  <!-- === QUIZ UI UPGRADE (2025-12-26): cleaner layout + hotkeys + progress === -->
  <style>
    /* Quiz modal polish (light skin) */
    .sh-app-host .quiz-modal-card{
      width: min(860px, 94vw) !important;
    }

    .sh-app-host .quiz-progressbar{
      height: 4px;
      margin-top: 6px;
      width: 100%;
      background: rgba(0,0,0,0.10);
      border: 1px solid rgba(0,0,0,0.10);
    }
    .sh-app-host .quiz-progressbar-fill{
      height: 100%;
      width: 0%;
      background: rgba(0,0,0,0.55);
      transition: width 160ms ease;
    }

    .sh-app-host .quiz-card{
      border: 1px solid rgba(0,0,0,0.18) !important;
      background: rgba(255,255,255,0.90) !important;
      padding: 16px !important;
    }

    .sh-app-host .quiz-head{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      min-width: 0;
    }
    .sh-app-host .quiz-type-badge{
      flex: 0 0 auto;
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 4px 8px;
      border: 1px solid rgba(0,0,0,0.20);
      background: rgba(0,0,0,0.04);
      white-space: nowrap;
    }
    .sh-app-host .quiz-hotkeys{
      flex: 1 1 auto;
      min-width: 0;
      text-align: right;
      font-size: 11px;
      opacity: 0.70;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    @media (max-width: 560px){
      .sh-app-host .quiz-hotkeys{ display:none; }
    }

    .sh-app-host .quiz-question{
      font-size: 16px !important;
      letter-spacing: 0.02em !important;
      text-transform: none !important;
      margin: 0 0 10px 0 !important;
      font-weight: 600;
      line-height: 1.25;
    }

    .sh-app-host .quiz-prompt{
      font-size: 13px !important;
      line-height: 1.55 !important;
      padding: 10px 12px !important;
      border: 1px solid rgba(0,0,0,0.14) !important;
      background: rgba(0,0,0,0.03) !important;
      margin-bottom: 12px !important;
      white-space: pre-wrap !important;
    }

    .sh-app-host .quiz-choices{
      display: grid !important;
      gap: 10px !important;
    }

    .sh-app-host .quiz-choice{
      display: flex !important;
      align-items: flex-start !important;
      gap: 10px !important;
      text-align: left !important;
      padding: 12px 12px !important;
      border: 1px solid rgba(0,0,0,0.18) !important;
      background: rgba(255,255,255,0.92) !important;
      font-size: 14px !important;
      line-height: 1.35 !important;
    }
    .sh-app-host .quiz-choice:hover{
      background: rgba(0,0,0,0.03) !important;
    }

    .sh-app-host .quiz-choice::before{
      content: attr(data-kbd);
      flex: 0 0 auto;
      width: 22px;
      height: 22px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(0,0,0,0.03);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      line-height: 1;
      margin-top: 1px;
    }

    /* Correct / wrong states without “hard colors” */
    .sh-app-host .quiz-choice.correct{
      border-color: rgba(0,0,0,0.62) !important;
      background: rgba(0,0,0,0.06) !important;
    }
    .sh-app-host .quiz-choice.wrong{
      border-style: dashed !important;
      opacity: 0.92;
    }

    .sh-app-host .quiz-message{
      margin-top: 12px !important;
      border: 1px solid rgba(0,0,0,0.14) !important;
      background: rgba(0,0,0,0.02) !important;
      padding: 10px 12px !important;
      white-space: pre-wrap !important;
      line-height: 1.55 !important;
    }

    .sh-app-host .quiz-meta{
      margin-top: 10px !important;
      border-top: 1px solid rgba(0,0,0,0.10);
      padding-top: 10px;
      font-size: 11px !important;
      opacity: 0.72 !important;
    }
  

    /* ============================
       Ultra-compact quiz panel
       (removes dead space, keeps it crisp)
       ============================ */

    /* Only the quiz modal: make it behave like an in-panel screen (not a centered popup) */
    .sh-app-host #quizModal.modal-backdrop{
      background: transparent !important;
      align-items: flex-start !important;
      justify-content: center !important;

      /* push below topbar, keep neat margins */
      padding: var(--quiz-topbar-h, 66px) 12px 12px !important;

      overflow: auto !important;
    }

    .sh-app-host #quizModal .quiz-modal-card{
      position: relative !important;
      width: min(980px, 100%) !important;
      max-width: 980px !important;
      height: auto !important;

      padding: 10px !important;
      gap: 10px !important;

      display: flex !important;
      flex-direction: column !important;

      margin: 0 auto !important;
    }

    .sh-app-host #quizModal .modal-body{
      padding: 0 !important;
    }
    .sh-app-host #quizModal .modal-footer.quiz-footer{
      margin: 0 !important;
      padding-top: 8px !important;
      border-top: 1px solid rgba(0,0,0,0.14);
    }

    /* Tighten the card itself */
    .sh-app-host #quizModal .quiz-card{
      padding: 12px !important;
      max-width: 980px;
      margin: 0 auto;
    }
    .sh-app-host #quizModal .quiz-head{
      gap: 8px !important;
      margin-bottom: 8px !important;
    }
    .sh-app-host #quizModal .quiz-type-badge{
      font-size: 10px !important;
      padding: 3px 7px !important;
    }
    .sh-app-host #quizModal .quiz-hotkeys{
      font-size: 10px !important;
    }

    /* Context strip: same info, less height */
    .sh-app-host #quizModal .quiz-context{
      padding: 6px 8px !important;
      font-size: 10px !important;
      line-height: 1.25 !important;
      margin: 0 0 8px 0 !important;
    }

    .sh-app-host #quizModal .quiz-question{
      font-size: 15px !important;
      margin: 0 0 6px 0 !important;
    }
    .sh-app-host #quizModal .quiz-prompt{
      padding: 8px 10px !important;
      margin-bottom: 8px !important;
      line-height: 1.45 !important;
    }
    .sh-app-host #quizModal .quiz-choices{
      gap: 8px !important;
    }
    .sh-app-host #quizModal .quiz-choice{
      padding: 10px 10px !important;
      gap: 8px !important;
      line-height: 1.32 !important;
    }
    .sh-app-host #quizModal .quiz-choice::before{
      width: 20px !important;
      height: 20px !important;
      font-size: 11px !important;
    }

    .sh-app-host #quizModal .quiz-message{
      margin-top: 8px !important;
      padding: 8px 10px !important;
    }

    .sh-app-host #quizModal .quiz-meta{
      margin-top: 8px !important;
      padding: 6px 8px !important;
      font-size: 11px !important;
      line-height: 1.35 !important;
    }

    /* Footer buttons: compact, still clickable */
    .sh-app-host #quizModal .quiz-footer .btn{
      padding: 9px 14px !important;
    }



    /* ============================
       V5 — compact + no-duplication quiz UI
       ============================ */

    .sh-app-host #quizModal .quiz-head{
      margin-bottom: 6px !important;
    }
    .sh-app-host #quizModal .quiz-chips{
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .sh-app-host #quizModal .quiz-chip{
      flex: 0 1 auto;
      min-width: 0;
      font-size: 10px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 3px 8px;
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(0,0,0,0.03);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sh-app-host #quizModal .quiz-chip-type{
      margin-left: auto;
      flex: 0 0 auto;
    }

    /* Prompt: inline by default, boxed only when long */
    .sh-app-host #quizModal .quiz-prompt{
      border: none !important;
      background: transparent !important;
      padding: 0 !important;
      margin: 0 0 8px 0 !important;
      font-size: 12px !important;
      line-height: 1.35 !important;
      opacity: 0.82;
      white-space: pre-wrap !important;
    }
    .sh-app-host #quizModal .quiz-prompt.boxed{
      border: 1px solid rgba(0,0,0,0.14) !important;
      background: rgba(0,0,0,0.03) !important;
      padding: 8px 10px !important;
      opacity: 1;
    }

    /* Choices: tighter vertical rhythm */
    .sh-app-host #quizModal .quiz-choices{
      gap: 6px !important;
    }
    .sh-app-host #quizModal .quiz-choice{
      padding: 9px 10px !important;
    }

    /* Meta: single compact line */
    .sh-app-host #quizModal .quiz-meta{
      border-top: 1px solid rgba(0,0,0,0.10) !important;
      padding-top: 8px !important;
      margin-top: 8px !important;
      font-size: 10px !important;
      opacity: 0.70 !important;
    }

</style>

</head>
<body class="page page-student-helper">

  <div class="outer-frame" aria-hidden="true"></div>
  <div class="rays" aria-hidden="true"></div>
  <div class="veil" aria-hidden="true"></div>

  <header class="topbar topbar--edge">
    <a class="toplink" href="../../item-user.html?returnTo=crate/student_helper/student_helper.html" aria-label="Item User">
      <span class="tag">item-user</span>
    </a>
  </header>

  <aside class="rail rail--left" aria-label="Левое меню">
    <a class="rail-link" href="../../index.html">
      <span class="rail-link__title">item-key</span>
      <span class="rail-link__meta">главное меню</span>
    </a>
    <a class="rail-link" href="../../item-manufacture.html">
      <span class="rail-link__title">item-manufacture</span>
      <span class="rail-link__meta">создание / производство</span>
    </a>
    <a class="rail-link" href="../../item-crate.html">
      <span class="rail-link__title">item-crate</span>
      <span class="rail-link__meta">архив / контейнеры</span>
    </a>
  </aside>

  <aside class="rail rail--right" aria-label="Правое меню">
    <a class="rail-link" href="../../item-security.html">
      <span class="rail-link__title">item-security</span>
      <span class="rail-link__meta">доступ / защита</span>
    </a>
    <a class="rail-link" href="../../item-soft.html">
      <span class="rail-link__title">item-soft</span>
      <span class="rail-link__meta">инструменты / редакторы</span>
    </a>
  </aside>

  <main class="center-stage" aria-label="Центр">
    <section class="helper-hub" aria-label="Помощь студентам">
      <div class="helper-title">
        <h1>помощь студентам</h1>
        <div class="sub">exam · knowledge · search</div>
      </div>

      <div class="sh-app-host" aria-label="Student Helper app">
<!-- 03. Основной интерфейс -->
  <div id="screen-app" class="screen screen-visible">
    <div class="screen-inner">
      
<div id="appRoot" class="app-vertical">
  <!-- TOP: breadcrumb + global search -->
  <header class="sh-topbar">
    <div class="topbar-block topbar-path">
      <div class="sidebar-breadcrumb-label">КАТЕГОРИИ</div>
      <div id="breadcrumb"></div>
    </div>

    <div class="topbar-block topbar-search">
      <div class="sidebar-breadcrumb-label">ПОИСК</div>
      <div class="searchbox" id="globalSearchBox">
        <input
          type="search"
          id="globalSearchInput"
          class="form-input sidebar-search-input"
          placeholder="поиск по всем отсекам и фактам..."
          autocomplete="off"
        />
        <button class="searchbox-clear" id="globalSearchClear" type="button" title="Очистить" aria-label="Очистить поиск">×</button>
      </div>
      <div class="sidebar-search-results" id="globalSearchResults"></div>
    </div>
  </header>

  <!-- TOP: hierarchy (full width) -->
  <div class="hierarchy-top-wrapper" id="hierarchyPanel">
    <div class="hier-header">
      <div class="hier-title">ИЕРАРХИЯ</div>
      <button class="btn btn-sm btn-ghost" id="btnTreeAddRoot" type="button" title="Добавить корневую категорию (корень)">+</button>
    </div>

    <div id="treeRoot"></div>

    <div class="sidebar-legend">
      <div class="legend-item">
        <span class="legend-badge legend-badge-cell">ОТСЕК</span>
        <span>— раздел / «папка» с подкатегориями.</span>
      </div>
      <div class="legend-item">
        <span class="legend-badge legend-badge-patt">ПАТТЕРН</span>
        <span>— внутри него лежат факты, годы, списки и термины.</span>
      </div>
    </div>
    <div class="hier-resize-handle" id="hierResizeHandle" title="Высота иерархии"></div>
  </div>

  <!-- MAIN -->
  <section class="main-panel main-panel-full">
    <div class="main-header-line">
      <div class="main-title-wrapper">
        <span class="small-elongated" id="mainTitleText">ПОДГОТОВКА К ЭКЗАМЕНАМ</span>
      </div>
      <div id="headerActions">
        <button class="btn btn-sm btn-ghost" id="btnExport" type="button" title="Скачать базу (exam-db.json)">Экспорт</button>
        <button class="btn btn-sm btn-ghost" id="btnImport" type="button" title="Загрузить базу (exam-db.json)">Импорт</button>
        <input id="fileInput" type="file" accept="application/json" />
      </div>
    </div>
    <div id="detailsRoot"></div>
  </section>
</div>
<!-- Текст при клике на мозг -->
  <div id="brainStory" class="brain-story-overlay">
    <div class="brain-story-card">
      <p>
        Здравствуйте, сайт сделан психически больным человеком, он хотел знать очень много,
        и его мозг не был способен всё уместить, поэтому оно создало этот сайт.
        Ему стало легче, жить, чуть чуть.
      </p>
      <button class="btn btn-sm btn-primary" id="brainStoryClose">вернуться</button>
    </div>
  </div>
  
  <!-- overlays removed -->

<!-- CREATE MODAL -->
  <div class="modal-backdrop" id="createModal">
    <div class="modal-card">
      <div class="modal-header">
        <div class="modal-header-main">
          <div class="modal-title" id="createModalTitle"></div>
          <div class="modal-subtitle" id="createModalSubtitle"></div>
        </div>
        <button type="button" class="modal-close" id="createModalClose">×</button>
      </div>

      <div class="modal-body">
        <div class="form-row" style="margin-bottom:8px;">
          <div class="form-label" id="createNameLabel">Название</div>
          <div>
            <input class="form-input" id="createNameInput" placeholder="Например: «История Беларуси»" />
            <div class="form-helper">Можно оставить пустым — имя подставится автоматически.</div>
          </div>
        </div>

        <div id="createConfigBlock">
          <div class="seg-group">
            <div class="seg-title">Где используется эта категория?</div>
            <div class="segmented" id="segConfigScope">
              <button type="button" data-scope="subject">УЧЕБНЫЙ ПРЕДМЕТ</button>
              <button type="button" data-scope="personal">ЛИЧНОЕ / СВОИ ЗАМЕТКИ</button>
            </div>
          </div>

          <div class="seg-group" id="configPresetSubject">
            <div class="seg-title">Готовый пресет предмета</div>
            <div class="segmented" id="segConfigPresetSubject">
              <button type="button" data-preset="history">ИСТОРИЯ</button>
              <button type="button" data-preset="english">АНГЛИЙСКИЙ</button>
            </div>
          </div>

          <div class="seg-group" id="configPresetPersonal">
            <div class="seg-title">Личные пространства</div>
            <div class="segmented" id="segConfigPresetPersonal">
              <button type="button" data-preset="notes">ЗАМЕТКИ</button>
              <button type="button" data-preset="ideas">ИДЕИ / ЧЕРНОВИКИ</button>
            </div>
          </div>

          <div class="seg-group" id="configImportBlock">
            <div class="seg-title">Импорт готовой базы</div>
            <p class="hint" style="margin-top:4px; margin-bottom:4px;">
              Если у тебя уже есть файл <code>exam-db.json</code>, можно импортировать его вместо создания с нуля.
            </p>
            <button type="button" class="btn btn-sm" id="btnImportInCreate">Импортировать базу</button>
          </div>
        </div>
      </div>

      <div id="createPatternTypeBlock" style="display:none; margin-top:8px;">
        <div class="seg-title">Тип паттерна</div>
        <div class="segmented" id="segPatternType">
          <button type="button" data-ptype="assertion">ФАКТЫ</button>
          <button type="button" data-ptype="years">ГОДА</button>
          <button type="button" data-ptype="olist">ОБЪЕКТНЫЕ СПИСКИ</button>
          <button type="button" data-ptype="term">СЛОВА-ОПРЕДЕЛЕНИЯ</button>
        </div>
      </div>

      <div class="modal-footer">
        <button class="btn btn-sm btn-ghost" id="btnCreateCancel">Отмена</button>
        <button class="btn btn-sm btn-primary" id="btnCreateConfirm">Создать</button>
      </div>
    </div>
  </div>

  <!-- QUIZ SETUP MODAL -->
  <div class="modal-backdrop" id="quizSetupModal" style="display:none;">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modal-content">
        <div class="modal-header">
          <div>
            <div class="modal-title" id="quizSetupTitle">ТЕСТЫ</div>
            <div class="modal-subtitle" id="quizSetupSubtitle">Настройка</div>
          </div>
          <button class="btn btn-sm btn-ghost" id="btnQuizSetupClose">Закрыть</button>
        </div>

        <div class="modal-body">
          <div class="quiz-setup-grid">
            <div class="quiz-setup-left">
              <div class="seg-title">Типы</div>
              <div class="segmented quiz-types" id="quizTypeSeg">
                <button type="button" data-qtype="assertion">ФАКТЫ</button>
                <button type="button" data-qtype="years">ГОДА</button>
                <button type="button" data-qtype="olist">ОБЪЕКТНЫЕ СПИСКИ</button>
                <button type="button" data-qtype="term">СЛОВА-ОПРЕДЕЛЕНИЯ</button>
                <button type="button" data-qtype="mix">СБОРНАЯ СОЛЯНКА</button>
              </div>

              <div class="quiz-setup-opts">
                <label class="quiz-check">
                  <input type="checkbox" id="chkQuizIncludeSub" checked />
                  <span>Учитывать подотсеки (цепочка)</span>
                </label>

                <div class="quiz-row">
                  <div class="quiz-row-label">Количество вопросов</div>
                  <input class="form-input" id="quizQuestionLimit" type="number" min="5" max="200" step="5" value="20" />
                </div>

                <div class="quiz-row">
                  <div class="quiz-row-label">Режим</div>
                  <div class="segmented" id="quizModeSeg">
                    <button type="button" data-mode="smart">умный</button>
                    <button type="button" data-mode="ordered">по порядку</button>
                  </div>
                </div>

                <div class="quiz-row">
                  <div class="quiz-row-label">Направление (для годов/терминов)</div>
                  <div class="segmented" id="quizDirectionSeg">
                    <button type="button" data-dir="auto">авто</button>
                    <button type="button" data-dir="forward">вопрос → ответ</button>
                    <button type="button" data-dir="reverse">ответ → вопрос</button>
                  </div>
                </div>

                <label class="quiz-check">
                  <input type="checkbox" id="chkQuizShowExplain" checked />
                  <span>Показывать «почему» после ответа</span>
                </label>
              </div>
            </div>

            <div class="quiz-setup-right">
              <div class="seg-title">Какие паттерны участвуют</div>
              <div class="quiz-row" style="margin-top:8px;">
                <input class="form-input" id="quizPatternFilter" type="search" placeholder="Фильтр по названию паттерна..." />
                <div style="display:flex; gap:8px;">
                  <button type="button" class="btn btn-sm btn-ghost" id="btnQuizSelectAll">Все</button>
                  <button type="button" class="btn btn-sm btn-ghost" id="btnQuizClearAll">Ничего</button>
                </div>
              </div>

              <div class="quiz-pattern-list" id="quizPatternList"></div>

              <div class="hint" id="quizSetupHint" style="margin-top:10px;"></div>
            </div>
          </div>
        </div>

        <div class="modal-footer quiz-setup-footer">
          <button class="btn btn-sm btn-ghost" id="btnQuizSetupCancel">Отмена</button>
          <button class="btn btn-sm btn-primary" id="btnQuizStart">Начать тест</button>
        </div>
      </div>
    </div>
  </div>

  <!-- QUIZ MODAL -->
  <div class="modal-backdrop" id="quizModal" style="display:none;">
    <div class="modal-card quiz-modal-card" role="dialog" aria-modal="true">
      
        <div class="modal-header">
          <div style="min-width:0;">
            <div class="modal-title" id="quizTitle">ТЕСТ</div>
            <div class="modal-subtitle" id="quizProgress">0/0</div>
            <div class="quiz-progressbar" aria-hidden="true"><div class="quiz-progressbar-fill" id="quizProgressFill"></div></div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <button class="btn btn-sm btn-ghost" id="btnQuizExit">Выйти</button>
          </div>
        </div>

        <div class="modal-body">
          <div class="quiz-card">
            <div class="quiz-head">
              <div class="quiz-chips">
                <div class="quiz-chip" id="quizTopicBadge" style="display:none;"></div>
                <div class="quiz-chip quiz-chip-type" id="quizTypeBadge">ТЕСТ</div>
              </div>
            </div>
            <div class="quiz-question" id="quizQuestionTitle">Вопрос</div>
            <div class="quiz-prompt" id="quizPromptText"></div>
            <div class="quiz-choices" id="quizChoices"></div>

            <div class="quiz-message" id="quizMessage" style="display:none;"></div>

            <div class="quiz-meta" id="quizMeta" style="display:none;"></div>
          </div>
        </div>

        <div class="modal-footer quiz-footer">
          <button class="btn btn-sm btn-ghost" id="btnQuizPrev">Назад</button>
          <button class="btn btn-sm btn-primary" id="btnQuizNext">Дальше</button>
        </div>
    </div>
  </div>

<script>
    // ===== DOM ELEMENTS =====

    const treeRootEl = document.getElementById('treeRoot');
    let dragNodeId = null;
    let dragOverMode = null;

    // Включаем встроенную проверку орфографии браузера для всех полей ввода текста
    document.addEventListener('focusin', (e) => {
      const t = e.target;
      if (!t || !t.tagName) return;
      const tag = t.tagName.toLowerCase();
      if (tag === 'textarea') {
        t.setAttribute('spellcheck', 'true');
      } else if (tag === 'input') {
        const type = (t.getAttribute('type') || 'text').toLowerCase();
        if (type === 'text' || type === 'search') {
          t.setAttribute('spellcheck', 'true');
        }
      }
    });


    if (treeRootEl) {
      treeRootEl.addEventListener('dragstart', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row || !row.dataset.id) return;
        dragNodeId = row.dataset.id;
        dragOverMode = null;
        if (e.dataTransfer) {
          e.dataTransfer.effectAllowed = 'move';
          try {
            e.dataTransfer.setData('text/plain', dragNodeId);
          } catch (err) {}
        }
      });

      treeRootEl.addEventListener('dragover', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row) return;
        e.preventDefault();

        const rect = row.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        let mode = 'inside';
        if (offsetY < rect.height * 0.25) {
          mode = 'before';
        } else if (offsetY > rect.height * 0.75) {
          mode = 'after';
        }

        dragOverMode = mode;

        // очистим старые подсветки
        Array.from(treeRootEl.querySelectorAll('.hier-row')).forEach(r => {
          r.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
        });

        if (mode === 'before') {
          row.classList.add('hier-row-drop-before');
        } else if (mode === 'after') {
          row.classList.add('hier-row-drop-after');
        } else {
          row.classList.add('hier-row-drop-inside');
        }

        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = 'move';
        }
      });

      treeRootEl.addEventListener('dragleave', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row) return;
        row.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
      });

      treeRootEl.addEventListener('drop', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row || !row.dataset.id) return;
        e.preventDefault();
        const targetId = row.dataset.id;
        const draggedId = dragNodeId;
        dragNodeId = null;

        Array.from(treeRootEl.querySelectorAll('.hier-row')).forEach(r => {
          r.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
        });

        if (!draggedId || draggedId === targetId) {
          dragOverMode = null;
          return;
        }

        const draggedNode = getNode(draggedId);
        const targetNode = getNode(targetId);
        if (!draggedNode || !targetNode) {
          dragOverMode = null;
          return;
        }

        let mode = dragOverMode || 'inside';
        let newParentId;
        let afterSiblingId = null;

        if (mode === 'inside' && targetNode.type === 'category') {
          // Бросили внутрь категории — кладём в конец её содержимого
          newParentId = targetNode.id;
        } else {
          // Бросили между соседями — работаем на уровне родителя
          const parent = getNode(targetNode.parentId || state.rootId);
          if (!parent) {
            dragOverMode = null;
            return;
          }
          newParentId = parent.id;
          const siblings = parent.children || [];
          const idx = siblings.indexOf(targetNode.id);

          if (mode === 'before') {
            if (idx <= 0) {
              // вставка в самое начало
              afterSiblingId = '__FIRST__';
            } else {
              // вставка после предыдущего соседа => визуально "перед" текущим
              afterSiblingId = siblings[idx - 1];
            }
          } else {
            // after или inside по не‑категории — просто после целевого узла
            afterSiblingId = targetNode.id;
          }
        }

        moveNode(draggedId, newParentId, afterSiblingId);
        dragOverMode = null;
        render();
      });

      treeRootEl.addEventListener('dragend', () => {
        dragNodeId = null;
        dragOverMode = null;
        Array.from(treeRootEl.querySelectorAll('.hier-row')).forEach(r => {
          r.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
        });
      });
    }

    const detailsRootEl = document.getElementById('detailsRoot');
    const breadcrumbEl = document.getElementById('breadcrumb');
    const headerActionsEl = document.getElementById('headerActions');
    const mainTitleTextEl = document.getElementById('mainTitleText');

    const btnCreateRootCategory = document.getElementById('btnCreateRootCategory');
    const rootsListEl = document.getElementById('rootsList');
    const btnRootsAdd = document.getElementById('btnRootsAdd');
    const rootbarListEl = document.getElementById('rootbarList');
    const btnRootbarAdd = document.getElementById('btnRootbarAdd');

    const btnExport = document.getElementById('btnExport');
    const btnImport = document.getElementById('btnImport');
    const fileInput = document.getElementById('fileInput');

        // (quiz / facts overlays removed)

    const createModalEl = document.getElementById('createModal');
    const createModalTitleEl = document.getElementById('createModalTitle');
    const createModalSubtitleEl = document.getElementById('createModalSubtitle');
    const createNameLabelEl = document.getElementById('createNameLabel');
    const createNameInputEl = document.getElementById('createNameInput');
    const createConfigBlockEl = document.getElementById('createConfigBlock');
    const segConfigScopeEl = document.getElementById('segConfigScope');
    const configPresetSubjectEl = document.getElementById('configPresetSubject');
    const configPresetPersonalEl = document.getElementById('configPresetPersonal');
    const segConfigPresetSubjectEl = document.getElementById('segConfigPresetSubject');
    const segConfigPresetPersonalEl = document.getElementById('segConfigPresetPersonal');
    const createPatternTypeBlockEl = document.getElementById('createPatternTypeBlock');
    const segPatternTypeEl = document.getElementById('segPatternType');
    const btnCreateClose = document.getElementById('createModalClose');
    const btnCreateCancel = document.getElementById('btnCreateCancel');
    const btnCreateConfirm = document.getElementById('btnCreateConfirm');
    const btnImportInCreate = document.getElementById('btnImportInCreate');
    const btnTreeAddRoot = document.getElementById('btnTreeAddRoot');

    // ROOT '+' modal
    const rootPlusModalEl = document.getElementById('rootPlusModal');
    const rootPlusCloseEl = document.getElementById('rootPlusClose');
    const rootPlusCancelEl = document.getElementById('rootPlusCancel');
    const rootPlusCreateEl = document.getElementById('rootPlusCreate');
    const rootPlusImportEl = document.getElementById('rootPlusImport');


    const appRootEl = document.getElementById('appRoot');
    const sidebarEl = document.querySelector('.sidebar');
    const sidebarResizerEl = document.getElementById('sidebarResizer');
    let sidebarIsResizing = false;
    let sidebarStartX = 0;
    let sidebarStartWidth = 0;
    const SIDEBAR_MIN_WIDTH = 200;
    const SIDEBAR_MAX_WIDTH = 600;

    if (sidebarResizerEl && appRootEl && sidebarEl) {
      const applySidebarWidth = (w) => {
        window.__sidebarWidthPx = w;
        appRootEl.style.gridTemplateColumns = `${w}px 6px minmax(0, 1fr)`;
      };

      const initialRect = sidebarEl.getBoundingClientRect();
      if (initialRect.width) {
        applySidebarWidth(initialRect.width);
      }

      sidebarResizerEl.addEventListener('mousedown', (e) => {
        e.preventDefault();
        sidebarIsResizing = true;
        sidebarStartX = e.clientX;
        sidebarStartWidth = sidebarEl.getBoundingClientRect().width;
        document.body.classList.add('resizing');
        document.addEventListener('mousemove', onSidebarResizeMove);
        document.addEventListener('mouseup', onSidebarResizeEnd);
      });

      function onSidebarResizeMove(e) {
        if (!sidebarIsResizing) return;
        let newWidth = sidebarStartWidth + (e.clientX - sidebarStartX);
        if (newWidth < SIDEBAR_MIN_WIDTH) newWidth = SIDEBAR_MIN_WIDTH;
        if (newWidth > SIDEBAR_MAX_WIDTH) newWidth = SIDEBAR_MAX_WIDTH;
        applySidebarWidth(newWidth);
      }

      function onSidebarResizeEnd() {
        if (!sidebarIsResizing) return;
        sidebarIsResizing = false;
        document.body.classList.remove('resizing');
        document.removeEventListener('mousemove', onSidebarResizeMove);
        document.removeEventListener('mouseup', onSidebarResizeEnd);
      }
    }

    // ===== HIERARCHY PANEL RESIZE (bottom-right handle) =====
    const hierarchyPanelEl = document.getElementById('hierarchyPanel');
    const hierResizeHandleEl = document.getElementById('hierResizeHandle');
    const HIER_HEIGHT_KEY = 'exam-helper-hierarchy-height-px';

    let hierIsResizing = false;
    let hierStartY = 0;
    let hierStartHeight = 0;

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    const getHierarchyMaxHeight = () => {
      const topbarEl = document.querySelector('.sh-topbar');
      const topbarH = topbarEl ? topbarEl.getBoundingClientRect().height : 0;
      // небольшой запас под отступы/гепы и нижнюю часть экрана
      const max = window.innerHeight - topbarH - 180;
      return Math.max(220, max);
    };

    const applyHierarchyHeight = (px) => {
      if (!appRootEl) return;
      const maxH = getHierarchyMaxHeight();
      const h = clamp(px, 160, maxH);
      appRootEl.style.setProperty('--hierH', `${Math.round(h)}px`);
      try { localStorage.setItem(HIER_HEIGHT_KEY, String(Math.round(h))); } catch (e) {}
    };

    // init from storage
    try {
      const saved = parseInt(localStorage.getItem(HIER_HEIGHT_KEY) || '', 10);
      if (Number.isFinite(saved) && saved > 0) {
        applyHierarchyHeight(saved);
      }
    } catch (e) {}

    if (hierResizeHandleEl && hierarchyPanelEl) {
      hierResizeHandleEl.addEventListener('mousedown', (e) => {
        e.preventDefault();
        hierIsResizing = true;
        hierStartY = e.clientY;
        hierStartHeight = hierarchyPanelEl.getBoundingClientRect().height;
        document.body.classList.add('hierarchy-resizing');
        document.addEventListener('mousemove', onHierResizeMove);
        document.addEventListener('mouseup', onHierResizeEnd);
      });

      function onHierResizeMove(e) {
        if (!hierIsResizing) return;
        const delta = e.clientY - hierStartY;
        applyHierarchyHeight(hierStartHeight + delta);
      }

      function onHierResizeEnd() {
        if (!hierIsResizing) return;
        hierIsResizing = false;
        document.body.classList.remove('hierarchy-resizing');
        document.removeEventListener('mousemove', onHierResizeMove);
        document.removeEventListener('mouseup', onHierResizeEnd);
      }
    }

    window.addEventListener('resize', () => {
      // на ресайзе окна — поджимаем высоту, если она стала слишком большой
      try {
        const current = hierarchyPanelEl ? hierarchyPanelEl.getBoundingClientRect().height : null;
        if (current) applyHierarchyHeight(current);
      } catch (e) {}
    });


    // ===== DATA MODEL =====

    function createInitialState() {
      const rootId = 'root';
      return {
        rootId,
        nextId: 1,
        nodes: {
          [rootId]: {
            id: rootId,
            type: 'category',
            name: 'Моя база знаний',
            parentId: null,
            children: [],
            cards: [],
            config: null
          }
        }
      };
    }

    const STORAGE_KEY = 'exam-helper-state-v1';

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return createInitialState();
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object' || !parsed.nodes) {
          return createInitialState();
        }
        return parsed;
      } catch (e) {
        console.warn('Failed to load state, using initial', e);
        return createInitialState();
      }
    }

    let __stateRevision = 0;

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('Failed to save state', e);
      }
      // ревизия состояния (для кешей, например поиска)
      __stateRevision++;
    }

    let state = loadState();
    let currentNodeId = state.rootId;
    let treeExpanded = {};
    let sidebarViewNodeId = state.rootId;

    // База данных разработчика (item:корни).
    // Вшита прямо в этот файл как embeddedDeveloperDB,
    // а при наличии exam-db.json рядом с HTML — подменяется свежей версией.
    const embeddedDeveloperDB = {"rootId": "root", "nextId": 141, "nodes": {"root": {"id": "root", "name": "Категории", "type": "category", "parentId": null, "children": ["n1"], "cards": []}, "n1": {"id": "n1", "name": "История Беларуси", "type": "category", "parentId": "root", "children": ["n2"], "config": {"scope": "subject", "preset": "history"}, "cards": []}, "n2": {"id": "n2", "name": "ВКЛ", "type": "category", "parentId": "n1", "children": ["n3", "n83"], "cards": []}, "n3": {"id": "n3", "name": "Князья", "type": "category", "parentId": "n2", "children": ["n9", "n26", "n32", "n40", "n46", "n56"], "cards": []}, "n9": {"id": "n9", "name": "Миндовг", "type": "category", "parentId": "n3", "children": ["n10", "n23", "n74"], "cards": []}, "n10": {"id": "n10", "name": "Года", "type": "characteristic", "parentId": "n9", "children": [], "factType": "years", "cards": [{"id": "n11", "kind": "years", "event": "Миндовг уже имел значительную власть и контролировал определенную часть литовских земель - \"Литва Миндовга\", хотя еще не правил всей Литвой", "timeRaw": "1235", "era": "н. э.", "person": "Миндовг"}, {"id": "n12", "kind": "years", "event": "произошла битва под Шяуляем, где литовцы, во главе Миндовга, разгромили Орден меченосцев", "timeRaw": "1236", "era": "н. э.", "person": "Миндовг"}, {"id": "n13", "kind": "years", "event": "Миндовг стал князем Новогородского(Новогрудок) княжества", "timeRaw": "1240", "era": "н. э.", "person": "Миндовг"}, {"id": "n14", "kind": "years", "event": "Миндовг принял православие", "timeRaw": "1246", "era": "н. э.", "person": "Миндовг"}, {"id": "n15", "kind": "years", "event": "Миндовг принял католичество", "timeRaw": "1251", "era": "н. э.", "person": "Миндовг"}, {"id": "n16", "kind": "years", "event": "Миндовг короновался в Новгородке (Можно считать официальной датой создания ВКЛ)", "timeRaw": "1253", "era": "н. э.", "person": "Миндовг"}, {"id": "n17", "kind": "years", "event": "произошла битва на озере Дурбе, под командованием Миндовга, против Тевтонского ордена", "timeRaw": "1260", "era": "н. э.", "person": "Миндовг"}, {"id": "n18", "kind": "years", "event": "Миндовг разорвал союз с крестоносцами, и заключил союз с Александром Невским", "timeRaw": "1261", "era": "н. э.", "person": "Миндовг"}, {"id": "n19", "kind": "years", "event": "Миндовг был убит в результате заговора между Тройнатом, Товтивилом, Довмонтом", "timeRaw": "1263", "era": "н. э.", "person": "Миндовг"}]}, "n23": {"id": "n23", "name": "Факт", "type": "characteristic", "parentId": "n9", "children": [], "factType": "assertion", "cards": [{"id": "n24", "kind": "assertion", "text": "первый князь ВКЛ, объединил Литву и Новогородское княжество в одно государство", "subject": "Миндовг"}, {"id": "n25", "kind": "assertion", "text": "Годы правления: 1253 - 1263 гг.", "subject": "Миндовг"}]}, "n26": {"id": "n26", "name": "Тройнат", "type": "category", "parentId": "n3", "children": ["n28"], "cards": []}, "n28": {"id": "n28", "name": "Факт", "type": "characteristic", "parentId": "n26", "children": [], "factType": "years", "cards": [{"id": "n29", "kind": "assertion", "text": "один из заговорщиков против Миндовга", "subject": "Тройнат"}, {"id": "n30", "kind": "assertion", "text": "стал князем ВКЛ после убийства Миндовга", "subject": "Тройнат"}, {"id": "n31", "kind": "assertion", "text": "его правление сопровождалось междоусобицами и нестабильностью", "subject": "Тройнат"}]}, "n32": {"id": "n32", "name": "Войшелк", "type": "category", "parentId": "n3", "children": ["n33"], "cards": []}, "n33": {"id": "n33", "name": "Факт", "type": "characteristic", "parentId": "n32", "children": [], "factType": "assertion", "cards": [{"id": "n34", "kind": "assertion", "text": "сын Миндовга", "subject": "Войшелк"}, {"id": "n35", "kind": "assertion", "text": "принял монашество", "subject": "Войшелк"}, {"id": "n36", "kind": "assertion", "text": "после убийства Тройната вернулся к власти", "subject": "Войшелк"}, {"id": "n37", "kind": "assertion", "text": "передал власть Шварну", "subject": "Войшелк"}, {"id": "n38", "kind": "assertion", "text": "был убит Левом Даниловичем", "subject": "Войшелк"}, {"id": "n39", "kind": "assertion", "text": "его правление способствовало укреплению христианства", "subject": "Войшелк"}]}, "n40": {"id": "n40", "name": "Тройдень", "type": "category", "parentId": "n3", "children": ["n41", "n43"], "cards": []}, "n41": {"id": "n41", "name": "Факт", "type": "characteristic", "parentId": "n40", "children": [], "factType": "assertion", "cards": [{"id": "n42", "kind": "assertion", "text": "один из князей ВКЛ, пришёл к власти после Войшелка", "subject": "Тройдень"}]}, "n43": {"id": "n43", "name": "Года", "type": "characteristic", "parentId": "n40", "children": [], "factType": "years", "cards": [{"id": "n44", "kind": "years", "event": "Тройдень разбил татар возле Гродно и Слонима", "timeRaw": "1277", "era": "н. э.", "person": "Тройдень"}, {"id": "n45", "kind": "years", "event": "Тройдень воевал с крестоносцами возле Динабурга", "timeRaw": "1281", "era": "н. э.", "person": "Тройдень"}]}, "n46": {"id": "n46", "name": "Витень", "type": "category", "parentId": "n3", "children": ["n47", "n50"], "cards": []}, "n47": {"id": "n47", "name": "Факт", "type": "characteristic", "parentId": "n46", "children": [], "factType": "assertion", "cards": [{"id": "n48", "kind": "assertion", "text": "князь ВКЛ до Гедимина", "subject": "Витень"}, {"id": "n49", "kind": "assertion", "text": "укреплял государство и вел борьбу с крестоносцами", "subject": "Витень"}, {"id": "n51", "kind": "assertion", "text": "при нём ВКЛ усилило своё влияние в регионе", "subject": "Витень"}]}, "n50": {"id": "n50", "name": "Года", "type": "characteristic", "parentId": "n46", "children": [], "factType": "years", "cards": [{"id": "n52", "kind": "years", "event": "битва Витеня с крестоносцами под Рудой", "timeRaw": "1298", "era": "н. э.", "person": "Витень"}, {"id": "n53", "kind": "years", "event": "укрепление Витенем Новогрудка как одного из центров ВКЛ", "timeRaw": "1316", "era": "н. э.", "person": "Витень"}, {"id": "n54", "kind": "years", "event": "приблизительное время смерти Витеня", "timeRaw": "1316", "era": "н. э.", "person": "Витень"}]}, "n56": {"id": "n56", "name": "Гедимин", "type": "category", "parentId": "n3", "children": ["n57", "n58"], "cards": []}, "n57": {"id": "n57", "name": "Года", "type": "characteristic", "parentId": "n56", "children": [], "factType": "years", "cards": [{"id": "n60", "kind": "years", "event": "Гедимин основал Вильно и перенес столицу в Вильно", "timeRaw": "1323", "era": "н. э.", "person": "Гедимин"}, {"id": "n65", "kind": "years", "event": "битва Гедимина на реке Окмене", "timeRaw": "1331", "era": "н. э.", "person": "Гедимин"}]}, "n58": {"id": "n58", "name": "Факт", "type": "characteristic", "parentId": "n56", "children": [], "factType": "assertion", "cards": [{"id": "n59", "kind": "assertion", "text": "великая князь ВКЛ, при котором государство значительно усилилось", "subject": "Гедимин"}, {"id": "n61", "kind": "assertion", "text": "при Гедимине ВКЛ активно расширяло свои территории на восток и запад", "subject": "Гедимин"}, {"id": "n62", "kind": "assertion", "text": "известен дипломатическими письмами западноевропейским правителям и орденам", "subject": "Гедимин"}, {"id": "n63", "kind": "assertion", "text": "стремился привлечь в ВКЛ ремесленников и купцов из Европы", "subject": "Гедимин"}, {"id": "n64", "kind": "assertion", "text": "при нём ВКЛ укрепило позиции в борьбе с Тевтонским орденом", "subject": "Гедимин"}, {"id": "n66", "kind": "assertion", "text": "династия Гедиминовичей стала одной из ведущих династий Восточной Европы", "subject": "Гедимин"}, {"id": "n67", "kind": "assertion", "text": "сыновья Гедимина правили в разных частях ВКЛ и соседних землях", "subject": "Гедимин"}, {"id": "n68", "kind": "assertion", "text": "Гедимин поддерживал относительную религиозную терпимость в государстве", "subject": "Гедимин"}, {"id": "n69", "kind": "assertion", "text": "при нём укреплялась роль Вильно как политического и культурного центра", "subject": "Гедимин"}, {"id": "n70", "kind": "assertion", "text": "его политика заложила основу дальнейшего усиления ВКЛ при его преемниках", "subject": "Гедимин"}, {"id": "n71", "kind": "assertion", "text": "Гедимин стал родоначальником династии, связанной с многими европейскими правящими домами", "subject": "Гедимин"}, {"id": "n72", "kind": "assertion", "text": "его правление считается одним из ключевых этапов формирования мощи ВКЛ", "subject": "Гедимин"}]}, "n74": {"id": "n74", "type": "characteristic", "name": "123", "parentId": "n9", "children": [], "factType": "assertion", "cards": []}, "n83": {"id": "n83", "type": "category", "name": "Система государственной власти", "parentId": "n2", "children": ["n84", "n112", "n118"], "cards": [], "config": null}, "n84": {"id": "n84", "type": "category", "name": "Верхняя власть", "parentId": "n83", "children": ["n87", "n100", "n107"], "cards": [], "config": null}, "n87": {"id": "n87", "type": "category", "name": "ВЕЛИКИЙ КНЯЗЬ ЛИТВОСКИЙ", "parentId": "n84", "children": ["n89", "n94"], "cards": [], "config": null}, "n89": {"id": "n89", "type": "characteristic", "name": "НАИМИНОВАНИЯ", "parentId": "n87", "children": [], "factType": "olist", "cards": [{"id": "n96", "kind": "olist-item", "text": "Великий князь литовский"}, {"id": "n97", "kind": "olist-item", "text": "король"}, {"id": "n98", "kind": "olist-item", "text": "господарь"}, {"id": "n99", "kind": "olist-item", "text": "король литвы и руси"}]}, "n94": {"id": "n94", "type": "characteristic", "name": "факты", "parentId": "n87", "children": [], "factType": "assertion", "cards": [{"id": "n95", "kind": "assertion", "text": "наследственная власть", "subject": "ВЕЛИКИЙ КНЯЗЬ ЛИТВОСКИЙ"}]}, "n100": {"id": "n100", "type": "category", "name": "паны-рада", "parentId": "n84", "children": ["n101"], "cards": [], "config": null}, "n101": {"id": "n101", "type": "characteristic", "name": "факты", "parentId": "n100", "children": [], "factType": "assertion", "cards": [{"id": "n103", "kind": "assertion", "text": "с 14 века - совещательный орган при князе", "subject": "паны-рада"}, {"id": "n105", "kind": "assertion", "text": "\"преднейшая лавица\" - постоянно действующий орган власти  в стране (центральная администрация, местное управление...)", "subject": "паны-рада"}, {"id": "n106", "kind": "assertion", "text": "1492 год, 1506год -привилей Александра Раде, о расширении полномочий - законодательные органы власти", "subject": "паны-рада"}]}, "n107": {"id": "n107", "type": "category", "name": "сейм", "parentId": "n84", "children": ["n108"], "cards": [], "config": null}, "n108": {"id": "n108", "type": "characteristic", "name": "факты", "parentId": "n107", "children": [], "factType": "assertion", "cards": [{"id": "n109", "kind": "assertion", "text": "сьезд шляхты в вкл", "subject": "сейм"}, {"id": "n110", "kind": "assertion", "text": "с 1511 года шляхта заседала по 2 представителя от поветов", "subject": "сейм"}, {"id": "n111", "kind": "assertion", "text": "с 14 века - высший законодательный орган власти", "subject": "сейм"}]}, "n112": {"id": "n112", "type": "category", "name": "центральная власть", "parentId": "n83", "children": ["n114"], "cards": [], "config": null}, "n114": {"id": "n114", "type": "characteristic", "name": "урядники", "parentId": "n112", "children": [], "factType": "term", "cards": [{"id": "n115", "kind": "term", "word": "канцлер", "definition": "заведовал государственной канцелярией, печатью"}, {"id": "n116", "kind": "term", "word": "гетман наивысший", "definition": "командовал войском вкл"}, {"id": "n117", "kind": "term", "word": "подскарбий земкский", "definition": "заведовал казной (скарбом) вкл"}]}, "n118": {"id": "n118", "type": "category", "name": "местное управление", "parentId": "n83", "children": ["n124"], "cards": [], "config": null}, "n121": {"id": "n121", "type": "characteristic", "name": "административные единицы", "parentId": "n124", "children": [], "factType": "term", "cards": [{"id": "n122", "kind": "term", "word": "Воеводство", "definition": "крупнейшая административная единица, делилось на поветы (на современный лад - области)"}, {"id": "n123", "kind": "term", "word": "повет = волость", "definition": "административная единица (на современный лад - район)"}]}, "n124": {"id": "n124", "type": "category", "name": "АДМИНИСТРАТИВНЫЕ ЕДИНИЦЫ", "parentId": "n118", "children": ["n121", "n125", "n126"], "cards": [], "config": null}, "n125": {"id": "n125", "type": "category", "name": "Воеводство", "parentId": "n124", "children": ["n131"], "cards": [], "config": null}, "n126": {"id": "n126", "type": "category", "name": "повет(волость)", "parentId": "n124", "children": ["n137", "n140"], "cards": [], "config": null}, "n131": {"id": "n131", "type": "characteristic", "name": "ПРЕДСТАВИТЕЛИ ВОЕВОДСТВА", "parentId": "n125", "children": [], "factType": "term", "cards": [{"id": "n132", "kind": "term", "word": "воевода", "definition": "сменил княжеского наместника; из местной шляхты; назначен пожизненно; присутствовал на заседании рады и сейма"}, {"id": "n133", "kind": "term", "word": "каштелян", "definition": "возглавлял войско воеводства"}, {"id": "n135", "kind": "term", "word": "городничий", "definition": "отвечал за укрепление воеводского замка"}, {"id": "n136", "kind": "term", "word": "ключник", "definition": "отвечал за сбор податей"}]}, "n137": {"id": "n137", "type": "characteristic", "name": "ПРЕДСТАВИТЕЛИ повета", "parentId": "n126", "children": [], "factType": "term", "cards": [{"id": "n138", "kind": "term", "word": "староста", "definition": "руководил районом, представитель местной шляхты"}, {"id": "n139", "kind": "term", "word": "Тиун", "definition": "старец,, отвечал за сбор податей в государственную казну"}]}, "n140": {"id": "n140", "type": "characteristic", "name": "определения повета", "parentId": "n126", "children": [], "factType": "term", "cards": [{"id": "n141", "kind": "term", "word": "волость(10-30 сёл)", "definition": "сельский войт"}]}}};

    // Если у пользователя ещё нет своей базы (пустой старт),
    // то сразу открываем «Подготовку к экзаменам» на базе разработчика.
    try {
      const onlyRoot =
        state &&
        state.nodes &&
        Object.keys(state.nodes).length === 1 &&
        state.nodes[state.rootId] &&
        state.nodes[state.rootId].name === 'Моя база знаний';
      if (onlyRoot) {
        state = JSON.parse(JSON.stringify(embeddedDeveloperDB));
        currentNodeId = state.rootId;
        sidebarViewNodeId = state.rootId;
        saveState();
      }
    } catch (e) {}

    window.__developerState = embeddedDeveloperDB;

    (function loadDeveloperState() {
      try {
        fetch('exam-db.json')
          .then(resp => {
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            return resp.json();
          })
          .then(data => {
            if (data && typeof data === 'object' && data.nodes && data.rootId) {
              window.__developerState = data;
              // Обновим экран корней, если он уже открыт
              try {
                renderRootsScreen();
              } catch (e) {
                console.warn('Cannot re-render roots screen after developer DB load', e);
              }
            }
          })
          .catch(err => {
            console.warn('Не удалось загрузить внешнюю exam-db.json с корнями разработчика (используем встроенную версию):', err);
          });
      } catch (err) {
        console.warn('fetch exam-db.json не поддерживается в этом окружении (используем встроенную версию)', err);
      }
    })();

    function genId() {
      state.nextId = (state.nextId || 1) + 1;
      return 'n' + state.nextId;
    }

    function getNode(id) {
      return state.nodes[id] || null;
    }

    function createCategory(name, parentId, config = null) {
      const id = genId();
      state.nodes[id] = {
        id,
        type: 'category',
        name: name || '',
        parentId: parentId || state.rootId,
        children: [],
        cards: [],
        config: config || null
      };
      const parent = getNode(parentId || state.rootId);
      if (parent) {
        parent.children = parent.children || [];
        parent.children.push(id);
      }
      saveState();
      return id;
    }

    function createCharacteristic(name, parentId, factType = 'assertion') {
      const id = genId();
      const node = {
        id,
        type: 'characteristic',
        name: name || '',
        parentId: parentId || state.rootId,
        children: [],
        factType: factType || 'assertion',
        cards: []
      };
      state.nodes[id] = node;
      const parent = getNode(parentId || state.rootId);
      if (parent) {
        parent.children = parent.children || [];
        parent.children.push(id);
      }
      saveState();
      return id;
    }

    function renameNode(id, name) {
      const n = getNode(id);
      if (!n) return;
      if (!name || !name.trim()) return;
      n.name = name.trim();
      saveState();
    }

    function deleteNodeAndDescendants(id) {
      if (id === state.rootId) return;
      const node = getNode(id);
      if (!node) return;
      const parent = getNode(node.parentId);
      if (parent) {
        parent.children = (parent.children || []).filter(c => c !== id);
      }
      function walkRemove(nodeId) {
        const n = getNode(nodeId);
        if (!n) return;
        (n.children || []).forEach(ch => walkRemove(ch));
        delete state.nodes[nodeId];
      }
      walkRemove(id);
      saveState();
    }

    function moveNode(nodeId, newParentId, afterSiblingId = null) {
      const node = getNode(nodeId);
      const newParent = getNode(newParentId);
      if (!node || !newParent) return;
      if (node.id === state.rootId) return;

      // не даём переместить узел внутрь самого себя или своего потомка
      let p = newParent;
      while (p) {
        if (p.id === node.id) return;
        p = getNode(p.parentId);
      }

      const oldParent = getNode(node.parentId);
      if (oldParent && oldParent.children) {
        oldParent.children = oldParent.children.filter(c => c !== node.id);
      }

      newParent.children = newParent.children || [];

      // Специальный маркер: вставить в самое начало списка детей
      if (afterSiblingId === '__FIRST__') {
        newParent.children = newParent.children.filter(c => c !== node.id);
        newParent.children.unshift(node.id);
      }
      // если нужно — вставляем сразу после указанного соседа
      else if (afterSiblingId && newParent.children.includes(afterSiblingId)) {
        const idx = newParent.children.indexOf(afterSiblingId);
        // на всякий случай удалим узел, если он уже был в этом списке
        newParent.children = newParent.children.filter(c => c !== node.id);
        newParent.children.splice(idx + 1, 0, node.id);
      } else {
        // по умолчанию кладём в конец
        if (!newParent.children.includes(node.id)) {
          newParent.children.push(node.id);
        }
      }

      node.parentId = newParent.id;
      saveState();
    }

    // --- FACT CARDS ---

    function addAssertionCard(nodeId, text, subject) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'assertion';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'assertion',
        text: (text || '').trim(),
        subject: (subject || '').trim() || null
      });
      saveState();
    }

    function addYearsCard(nodeId, event, timeRaw, era, person, timeExact) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'years';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'years',
        event: (event || '').trim(),
        timeRaw: (timeRaw || '').trim(),
        era: (era || '').trim(),
        person: (person || '').trim() || null,
        timeExact: (timeExact || '').trim() || null
      });
      saveState();
    }

    function addOListItem(nodeId, text) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'olist';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'olist-item',
        text: (text || '').trim()
      });
      saveState();
    }

    function addTermCard(nodeId, word, definition) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'term';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'term',
        word: (word || '').trim(),
        definition: (definition || '').trim()
      });
      saveState();
    }

    
    function updateCard(nodeId, cardId, patch) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      const cards = node.cards || [];
      const card = cards.find(c => c.id === cardId);
      if (!card) return;
      Object.assign(card, patch);
      saveState();
    }

function deleteCard(nodeId, cardId) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.cards = (node.cards || []).filter(c => c.id !== cardId);
      saveState();
    }

    function moveCard(nodeId, cardId, direction) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      const cards = node.cards || [];
      const index = cards.findIndex(c => c.id === cardId);
      if (index === -1) return;
      const newIndex = direction === 'up' ? index - 1 : index + 1;
      if (newIndex < 0 || newIndex >= cards.length) return;
      const [moved] = cards.splice(index, 1);
      cards.splice(newIndex, 0, moved);
      saveState();
    }

    // ===== UTILS =====

    function isValidYearOrPeriod(str) {
      const s = (str || '').trim();
      if (!s) return false;
      const single = /^\d{1,4}$/;
      const range = /^(\d{1,4})\s*[-–—]\s*(\d{1,4})$/;
      return single.test(s) || range.test(s);
    }

    function normalizeMonthName(monthRaw) {
      const m = (monthRaw || '').toLowerCase().trim();
      if (!m) return '';
      // оставляем только буквы (латиница + кириллица)
      const s = m.normalize('NFD').replace(/[^a-zа-яё]+/g, '');
      return s;
    }

    function getMaxDaysForMonth(monthRaw) {
      const m = normalizeMonthName(monthRaw);
      if (!m) return 31;
      const ru = {
        'январь': 31, 'января': 31,
        'февраль': 28, 'февраля': 28,
        'март': 31, 'марта': 31,
        'апрель': 30, 'апреля': 30,
        'май': 31, 'мая': 31,
        'июнь': 30, 'июня': 30,
        'июль': 31, 'июля': 31,
        'август': 31, 'августа': 31,
        'сентябрь': 30, 'сентября': 30,
        'октябрь': 31, 'октября': 31,
        'ноябрь': 30, 'ноября': 30,
        'декабрь': 31, 'декабря': 31
      };
      if (ru[m] != null) return ru[m];
      const en = {
        'january': 31,
        'february': 28,
        'march': 31,
        'april': 30,
        'may': 31,
        'june': 30,
        'july': 31,
        'august': 31,
        'september': 30,
        'october': 31,
        'november': 30,
        'december': 31
      };
      if (en[m] != null) return en[m];
      return 31;
    }

    function formatYears(card) {
      const raw = (card.timeRaw || '').trim();
      const exact = (card.timeExact || '').trim();
      if (!raw && !exact) return '';

      const hasDash =
        raw.includes('-') || raw.includes('–') || raw.includes('—');

      let res = '';
      if (exact && raw && !hasDash) {
        // классический кейс: «14 августа 1385 г.»
        res = exact + ' ' + raw;
      } else if (raw) {
        res = raw;
      } else {
        // вдруг указана только точная дата без года
        res = exact;
      }

      const era = (card.era || '').trim();

      // Если указана ЭРА (кроме «н. э.»), то не добавляем «г.»/«гг.»,
      // чтобы получить, например, «14 век», а не «14 г. век».
      if (raw && (!era || era === 'н. э.')) {
        res += hasDash ? ' гг.' : ' г.';
      }

      if (era && era !== 'н. э.') {
        res += ' ' + era;
      }
      return res;
    }

    function formatFactDisplay(node, card) {
      const type = node.factType || 'assertion';
      if (type === 'assertion') {
        const subj = card.subject || node.name || '';
        return subj ? subj + ': ' + (card.text || '') : (card.text || '');
      }
      if (type === 'years') {
        const y = formatYears(card);
        const ev = card.event || '';
        const person = card.person || '';
        let prefix = '';
        if (person) prefix = person + ': ' + ev;
        else prefix = ev;
        return y ? prefix + ' — ' + y : prefix;
      }
      if (type === 'olist') {
        return '• ' + (card.text || '');
      }
      if (type === 'term') {
        return (card.word || '') + ' — ' + (card.definition || '');
      }
      return '';
    }

    function getCategorySubtreeNodeIds(nodeId) {
      const res = [];
      function walk(id) {
        res.push(id);
        const n = getNode(id);
        if (!n) return;
        (n.children || []).forEach(ch => walk(ch));
      }
      walk(nodeId);
      return res;
    }

    function getCategoryCharacteristics(nodeId) {
      return getCategorySubtreeNodeIds(nodeId)
        .map(id => getNode(id))
        .filter(n => n && n.type === 'characteristic');
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function pickRandom(arr, count, exceptVal) {
      const base = arr.filter(x => x !== exceptVal);
      return shuffle(base).slice(0, count);
    }

    // ===== RENDER: BREADCRUMB & TREE =====

    function buildBreadcrumb(nodeId) {
      const path = [];
      let n = getNode(nodeId);
      while (n) {
        path.unshift(n);
        if (!n.parentId) break;
        n = getNode(n.parentId);
      }

      breadcrumbEl.innerHTML = '';

      path.forEach((node, idx) => {
        if (idx > 0) {
          const sep = document.createElement('span');
          sep.textContent = ' \\ ';
          sep.className = 'breadcrumb-sep';
          breadcrumbEl.appendChild(sep);
        }

        const seg = document.createElement('span');
        const isLast = idx === path.length - 1;
        seg.className = 'breadcrumb-item' + (isLast ? ' breadcrumb-item-current' : '');
        seg.textContent = node.name || '(без названия)';

        if (!isLast) {
          seg.title = 'Перейти';
          seg.onclick = () => {
            currentNodeId = node.id;
            if (node.type === 'category') {
              sidebarViewNodeId = node.id;
            } else if (node.parentId) {
              sidebarViewNodeId = node.parentId;
            }
            render();
          };
        } else {
          seg.setAttribute('aria-current', 'page');
        }

        breadcrumbEl.appendChild(seg);
      });

      // как в Windows Explorer: показываем "хвост" пути (последние сегменты)
      try {
        breadcrumbEl.scrollLeft = breadcrumbEl.scrollWidth;
      } catch (e) {}
    }



// helpers for сворачивание/разворачивание иерархии
function isNodeExpanded(id, depth) {
  if (Object.prototype.hasOwnProperty.call(treeExpanded, id)) {
    return !!treeExpanded[id];
  }
  // по умолчанию корневые категории (depth = 0) раскрыты, вложенные — свернуты
  return depth === 0;
}

function setAllTreeExpanded(expanded) {
  Object.keys(state.nodes || {}).forEach(id => {
    const n = getNode(id);
    if (n && n.type === 'category') {
      treeExpanded[id] = !!expanded;
    }
  });
  renderTree();
}

function renderTree() {
  if (!treeRootEl) return;

  // Точка входа для навигации в левой панели:
  // sidebarViewNodeId — "текущая папка", в которой мы сейчас находимся.
  let viewNode = getNode(sidebarViewNodeId);
  if (!viewNode) {
    viewNode = getNode(state.rootId);
    sidebarViewNodeId = viewNode ? viewNode.id : null;
  }
  if (!viewNode) return;

  const isRoot = !viewNode.parentId;

  treeRootEl.innerHTML = '';

  // Шапка как в мессенджерах / проводнике:
  // слева — кнопка «назад», по центру — название текущего отсека.
  const header = document.createElement('div');
  header.className = 'hier-header';

  const left = document.createElement('div');
  left.className = 'hier-fx';

  if (!isRoot) {
    const backBtn = document.createElement('button');
    backBtn.type = 'button';
    backBtn.className = 'hier-fx-btn';
    backBtn.textContent = '← НАЗАД';
    backBtn.onclick = (e) => {
      e.stopPropagation();
      const parent = getNode(viewNode.parentId);
      if (parent) {
        sidebarViewNodeId = parent.id;
        currentNodeId = parent.id;
        render();
      }
    };
    
    // Можно «вытащить» паттерн/отсек на уровень выше: перетяни на «← НАЗАД»
    backBtn.addEventListener('dragover', (e) => {
      e.preventDefault();
      backBtn.classList.add('hier-row-drop-inside');
      if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    });
    backBtn.addEventListener('dragleave', () => {
      backBtn.classList.remove('hier-row-drop-inside');
    });
    backBtn.addEventListener('drop', (e) => {
      e.preventDefault();
      backBtn.classList.remove('hier-row-drop-inside');
      const draggedId = dragNodeId;
      dragNodeId = null;
      dragOverMode = null;
      const parent = getNode(viewNode.parentId);
      if (!draggedId || !parent) return;
      // переносим узел на уровень выше (в родителя текущего отсека)
      moveNode(draggedId, parent.id, null);
      // остаёмся в текущем «родительском» экране
      sidebarViewNodeId = parent.id;
      currentNodeId = draggedId;
      render();
    });

left.appendChild(backBtn);
  } else {
    const label = document.createElement('div');
    label.textContent = 'ВСЕ ОТСЕКИ';
    left.appendChild(label);
  }

  const right = document.createElement('div');
  right.className = 'hier-fx-buttons';

  const title = document.createElement('div');
  title.className = 'hier-name';
  title.textContent = viewNode.name || 'Категории';

  // Клик по названию отсека в шапке — открыть его характеристику справа
  if (!isRoot) {
    title.classList.add('hier-name-link');
    title.title = 'Открыть характеристику этого отсека';
    title.style.cursor = 'pointer';
    title.onclick = (e) => {
      e.stopPropagation();
      // Просто показываем характеристику текущего отсека в правой панели
      currentNodeId = viewNode.id;
      render();
    };
  }

  right.appendChild(title);

  header.appendChild(left);
  header.appendChild(right);
  treeRootEl.appendChild(header);

  // Список "как в чате": показываем только прямых детей текущего отсека.
  const children = (viewNode.children || [])
    .map(id => getNode(id))
    .filter(n => !!n);

  if (!children.length) {
    const empty = document.createElement('div');
    empty.className = 'hint';
    empty.style.marginTop = '6px';
    empty.textContent = 'Здесь пока пусто. Создай подкатегорию или паттерн.';
    treeRootEl.appendChild(empty);
    return;
  }

  children.forEach(n => {
    const row = document.createElement('div');
    row.className = 'hier-row';
    row.dataset.id = n.id;
    row.setAttribute('draggable', 'true');

    if (n.type === 'category') row.classList.add('hier-row-category');
    else if (n.type === 'characteristic') row.classList.add('hier-row-characteristic');
    if (n.id === currentNodeId) row.classList.add('hier-row-current');

    // без лесенки, всё на одном уровне
    row.style.paddingLeft = '8px';

    const tag = document.createElement('div');
    tag.className = 'hier-tag';
    if (n.type === 'category') tag.textContent = 'ОТСЕК';
    else if (n.type === 'characteristic') tag.textContent = 'ПАТТЕРН';
    else tag.textContent = 'ОТСЕК';

    const name = document.createElement('div');
    name.className = 'hier-name';
    name.textContent = n.name || '(без названия)';

    row.appendChild(tag);
    row.appendChild(name);

    // маленький индикатор, что по категории можно "зайти внутрь"
    if (n.type === 'category') {
      const arrow = document.createElement('div');
      arrow.style.marginLeft = 'auto';
      arrow.style.fontSize = '11px';
      arrow.textContent = '▸';
      row.appendChild(arrow);
    }

    row.onclick = () => {
      currentNodeId = n.id;
      if (n.type === 'category') {
        sidebarViewNodeId = n.id; // заходим внутрь выбранного отсека
      }

      render();
    };

    treeRootEl.appendChild(row);
  });
}
function attachSectionToggles(wrapper) {
      const sections = wrapper.querySelectorAll('.section');
      sections.forEach(sec => {
        const header = sec.querySelector('.section-header');
        if (!header) return;
        header.addEventListener('click', (e) => {
          if (e.target.closest('button, input, select, textarea')) return;
          sec.classList.toggle('collapsed');
        });
      });
    }

    function renderDetails() {
      const node = getNode(currentNodeId);
      detailsRootEl.innerHTML = '';
      headerActionsEl.innerHTML = '';

      if (!node) {
        if (mainTitleTextEl) {
          mainTitleTextEl.textContent = 'АРХИВ';
        }
        detailsRootEl.innerHTML =
          '<div class="hint">Выбери категорию или характеристику слева.</div>';
        return;
      }

      // заголовок сверху: АРХИВ / ОТСЕК / ПАТТЕРН
      let titleWrapper = null;
      if (mainTitleTextEl) {
        let titleText = 'АРХИВ';
        const name = (node.name || '(без названия)').toUpperCase();
        if (node.type === 'category') {
          titleText = 'ОТСЕК: ' + name;
        } else if (node.type === 'characteristic') {
          titleText = 'ПАТТЕРН: ' + name;
        }
        mainTitleTextEl.textContent = titleText;

        // найдём обёртку заголовка и уберём старую кнопку «ОТСЕК: …», если она есть
        titleWrapper = mainTitleTextEl.parentElement;
        if (titleWrapper) {
          const oldBtn = titleWrapper.querySelector('.main-title-parent-btn');
          if (oldBtn) oldBtn.remove();
        }
      }

      if (node.id !== state.rootId) {
        const kindLabel = node.type === 'category' ? 'ОТСЕК' : 'ПАТТЕРН';

        const renameBtn = document.createElement('button');
        renameBtn.className = 'btn btn-sm btn-ghost btn-chip';
        renameBtn.textContent = 'ПЕРЕИМЕНОВАТЬ ' + kindLabel;
        renameBtn.onclick = () => {
          const newName = prompt('Новое название:', node.name || '');
          if (newName && newName.trim()) {
            renameNode(node.id, newName);
            render();
          }
        };
        headerActionsEl.appendChild(renameBtn);

        const delBtn = document.createElement('button');
        delBtn.className = 'btn btn-sm btn-danger btn-chip';
        delBtn.textContent = 'УДАЛИТЬ ' + kindLabel;
        delBtn.onclick = () => {
          const ok = confirm(
            'Удалить "' + (node.name || 'без названия') + '" и всё внутри?'
          );
          if (!ok) return;
          const parentId = node.parentId || state.rootId;
          deleteNodeAndDescendants(node.id);
          currentNodeId = parentId;
          render();
        };
        headerActionsEl.appendChild(delBtn);
      }

      // Если мы внутри паттерна — добавляем кнопку с названием его отсека
      // прямо рядом с заголовком «ПАТТЕРН: …».
      if (node.type === 'characteristic' && mainTitleTextEl && mainTitleTextEl.parentElement) {
        const parent = getNode(node.parentId);
        if (parent && parent.type === 'category') {
          const goCategoryBtn = document.createElement('button');
          goCategoryBtn.className = 'btn btn-sm btn-ghost btn-chip main-title-parent-btn';
          goCategoryBtn.textContent = 'ОТСЕК: ' + (parent.name || '(без названия)');
          goCategoryBtn.title = 'Открыть характеристику этого отсека';
          goCategoryBtn.onclick = () => {
            currentNodeId = parent.id;
            sidebarViewNodeId = parent.id;
            render();
          };

          const wrapper = mainTitleTextEl.parentElement;
          wrapper.appendChild(goCategoryBtn);
        }
      }

      if (node.type === 'category') {
        renderCategoryDetails(node);
      } else {
        renderCharacteristicDetails(node);
      }
    }

    function renderCategoryDetails(node) {
      const wrapper = document.createElement('div');

      // title row
      const titleRow = document.createElement('div');
      titleRow.className = 'title-row';

      const titleMain = document.createElement('div');
      titleMain.className = 'title-main';
      titleMain.innerHTML =
        '<span>' + (node.name || '(без названия)') + '</span>';
      titleRow.appendChild(titleMain);

      if (node.parentId === state.rootId && node.config) {
        const tag = document.createElement('div');
        tag.className = 'tag-config';
        let scopeText = node.config.scope === 'personal' ? 'Личное' : 'Предмет';
        let presetText = node.config.preset || '';
        if (node.config.scope === 'subject') {
          if (presetText === 'history') presetText = 'История';
          if (presetText === 'english') presetText = 'Английский';
        } else {
          if (presetText === 'notes') presetText = 'Заметки';
          if (presetText === 'ideas') presetText = 'Идеи';
        }
        tag.textContent = scopeText + (presetText ? ' · ' + presetText : '');
        titleRow.appendChild(tag);
      }

      wrapper.appendChild(titleRow);

      // summary line: facts & tests
      const chars = getCategoryCharacteristics(node.id);
      const factsCount = chars.reduce(
        (acc, ch) => acc + ((ch.cards || []).length),
        0
      );
      const summary = document.createElement('div');
      summary.className = 'hint';
      summary.textContent =
        'Отсек: ' +
        (node.name || '') +
        ' — ' +
        factsCount +
        ' фактов в ' +
        chars.length +
        ' характеристиках.';
      wrapper.appendChild(summary);

      // section: create inside
      const secCreate = document.createElement('div');
      secCreate.className = 'section';

      const secCreateHeader = document.createElement('div');
      secCreateHeader.className = 'section-header';
      secCreateHeader.innerHTML =
        '<div class="section-title">Зародить организм внутри отсека</div>';
      secCreate.appendChild(secCreateHeader);

      const secCreateBody = document.createElement('div');
      secCreateBody.className = 'section-body';

      const rowButtons = document.createElement('div');
      rowButtons.className = 'row';

      const btnCat = document.createElement('button');
      btnCat.className = 'btn btn-sm btn-ghost btn-full';
      btnCat.textContent = '+ Узел отсека';
      btnCat.onclick = () => openCreateDialog('category', node.id);

      const btnChar = document.createElement('button');
      btnChar.className = 'btn btn-sm btn-primary btn-full';
      btnChar.textContent = '+ Паттерн';
      btnChar.onclick = () => openCreateDialog('characteristic', node.id);

      const col1 = document.createElement('div');
      col1.appendChild(btnCat);
      const col2 = document.createElement('div');
      col2.appendChild(btnChar);

      rowButtons.appendChild(col1);
      rowButtons.appendChild(col2);

      secCreateBody.appendChild(rowButtons);
      secCreate.appendChild(secCreateBody);
      wrapper.appendChild(secCreate);

      // section: children
      const secChildren = document.createElement('div');
      secChildren.className = 'section';

      const secChHeader = document.createElement('div');
      secChHeader.className = 'section-header';
      const st = document.createElement('div');
      st.className = 'section-title';
      st.textContent = 'Содержимое категории';
      secChHeader.appendChild(st);
      secChildren.appendChild(secChHeader);

      const secChBody = document.createElement('div');
      secChBody.className = 'section-body';

      const childList = document.createElement('div');
      childList.className = 'child-list';

      if (!node.children || !node.children.length) {
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent =
          'Пока пусто. Сначала создай подкатегорию или характеристику.';
        childList.appendChild(p);
      } else {
        node.children.forEach(cid => {
          const ch = getNode(cid);
          if (!ch) return;
          const card = document.createElement('div');
          card.className = 'child-card';

          const name = document.createElement('div');
          name.className = 'child-name';
          name.textContent = ch.name || '(без названия)';

          const meta = document.createElement('div');
          meta.className = 'child-meta';

          const left = document.createElement('span');
          left.textContent = ch.type === 'category' ? 'Отсек' : 'Паттерн';

          const right = document.createElement('span');
          if (ch.type === 'category') {
            const subChars = getCategoryCharacteristics(ch.id);
            right.textContent = subChars.length + ' хар.';
          } else {
            const cnt = (ch.cards || []).length;
            let t = ch.factType || 'assertion';
            if (t === 'assertion') t = 'утв.';
            else if (t === 'years') t = 'годы';
            else if (t === 'olist') t = 'список';
            else if (t === 'term') t = 'слова';
            right.textContent = t + ' · ' + cnt;
          }
          meta.appendChild(left);
          meta.appendChild(right);

          card.appendChild(name);
          card.appendChild(meta);

          card.onclick = () => {
            currentNodeId = ch.id;
            if (ch.type === 'category') {
              sidebarViewNodeId = ch.id;
            } else if (ch.parentId) {
              sidebarViewNodeId = ch.parentId;
            }
            render();
          };

          childList.appendChild(card);
        });
      }

      secChBody.appendChild(childList);
      secChildren.appendChild(secChBody);
      wrapper.appendChild(secChildren);

            // SECTION: tests (умный режим)
      const secQuiz = document.createElement('div');
      secQuiz.className = 'section';

      const secQuizHeader = document.createElement('div');
      secQuizHeader.className = 'section-header';
      secQuizHeader.innerHTML =
        '<div class="section-title">Тесты по отсеку</div>';
      secQuiz.appendChild(secQuizHeader);

      const secQuizBody = document.createElement('div');
      secQuizBody.className = 'section-body';

      const quizRow = document.createElement('div');
      quizRow.className = 'row';
      quizRow.style.flexWrap = 'wrap';

      const qStats = computeScopeStats('category', node.id, true);

      function addQuizBtn(type, label, enabled, count){
        const b = document.createElement('button');
        b.className = 'btn btn-sm ' + (enabled ? 'btn-primary' : 'btn-ghost');
        b.type = 'button';
        b.disabled = !enabled;
        b.textContent = label + (typeof count === 'number' ? (' · ' + count) : '');
        b.onclick = () => startQuizQuick('category', node.id, type);
        quizRow.appendChild(b);
      }

      addQuizBtn('assertion', 'ФАКТЫ', !!qStats.canStart.assertion, qStats.byType.assertion.cards);
      addQuizBtn('years', 'ГОДА', !!qStats.canStart.years, qStats.byType.years.cards);
      addQuizBtn('olist', 'ОБЪЕКТНЫЕ СПИСКИ', !!qStats.canStart.olist, qStats.byType.olist.cards);
      addQuizBtn('term', 'СЛОВА-ОПРЕДЕЛЕНИЯ', !!qStats.canStart.term, qStats.byType.term.cards);

      const btnMix = document.createElement('button');
      btnMix.className = 'btn btn-sm ' + (qStats.canMix ? 'btn-primary' : 'btn-ghost');
      btnMix.type = 'button';
      btnMix.disabled = !qStats.canMix;
      btnMix.textContent = 'СБОРНАЯ СОЛЯНКА';
      btnMix.onclick = () => startQuizQuick('category', node.id, 'mix');
      quizRow.appendChild(btnMix);

      const btnCfg = document.createElement('button');
      btnCfg.className = 'btn btn-sm btn-ghost';
      btnCfg.type = 'button';
      btnCfg.textContent = '⚙ Настроить';
      btnCfg.onclick = () => openQuizSetup('category', node.id, ['mix']);
      quizRow.appendChild(btnCfg);

      secQuizBody.appendChild(quizRow);

      const hint = document.createElement('div');
      hint.className = 'hint';
      hint.textContent = 'Тесты учитывают паттерны внутри отсека и всех его подотсеков. В настройке можно вручную выбрать типы и конкретные паттерны.';
      secQuizBody.appendChild(hint);

      secQuiz.appendChild(secQuizBody);
      wrapper.appendChild(secQuiz);



      detailsRootEl.appendChild(wrapper);
      attachSectionToggles(wrapper);
    }

    function renderCharacteristicDetails(node) {
      const wrapper = document.createElement('div');

      const titleRow = document.createElement('div');
      titleRow.className = 'title-row';

      const titleMain = document.createElement('div');
      titleMain.className = 'title-main characteristic';
      titleMain.textContent = node.name || '(без названия)';
      titleRow.appendChild(titleMain);
      wrapper.appendChild(titleRow);

      const parent = getNode(node.parentId);

      // SECTION: Тип факта
      const secType = document.createElement('div');
      secType.className = 'section';

      let ft = node.factType || 'assertion';
      const parentName = parent ? (parent.name || '') : '';

      const patternLabelMap = {
        assertion: 'ФАКТЫ',
        years: 'ГОДА',
        olist: 'ОБЪЕКТНЫЕ СПИСКИ',
        term: 'СЛОВА-ОПРЕДЕЛЕНИЯ'
      };
      const patternLabel = patternLabelMap[ft] || '';

      const secTypeHeader = document.createElement('div');
      secTypeHeader.className = 'section-header';
      secTypeHeader.innerHTML =
        '<div class="section-title">ТИП ПАТТЕРНА: ' + patternLabel + '</div>';
      secType.appendChild(secTypeHeader);

      const secTypeBody = document.createElement('div');
      secTypeBody.className = 'section-body';

      const rowType = document.createElement('div');
      rowType.className = 'row';

      const colInfo = document.createElement('div');
      const h1 = document.createElement('div');
      h1.className = 'hint';
      if (parent) {
        h1.textContent = 'Отсек: ' + parentName;
        h1.style.cursor = 'pointer';
        h1.title = 'Открыть этот отсек';
        h1.onclick = () => {
          currentNodeId = parent.id;
          sidebarViewNodeId = parent.id;
          render();
        };
      } else {
        h1.textContent = 'Без отсека';
      }
      colInfo.appendChild(h1);

      const h2 = document.createElement('div');
      h2.className = 'hint';
      h2.textContent =
        'Тип паттерна выбирается при создании и здесь только отображается.';
      colInfo.appendChild(h2);

      rowType.appendChild(colInfo);
      secTypeBody.appendChild(rowType);
      secType.appendChild(secTypeBody);
      wrapper.appendChild(secType);

            // (pattern use toolbar removed)
// SECTION: Добавление факта
      const secAdd = document.createElement('div');
      secAdd.className = 'section';
      const secAddHeader = document.createElement('div');
      secAddHeader.className = 'section-header';
      secAddHeader.innerHTML =
        '<div class="section-title">Зародить организм внутри паттерна</div>';
      secAdd.appendChild(secAddHeader);

      const secAddBody = document.createElement('div');
      secAddBody.className = 'section-body';

      if (node.factType === 'assertion') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Кто / что? (необязательно)';
        const c1 = document.createElement('div');
        const i1 = document.createElement('input');
        i1.className = 'form-input';
        i1.placeholder = 'Например: «Минск» или «Яглонский»';
        if (parent && parent.name) {
          i1.value = parent.name;
        }
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const r2 = document.createElement('div');
        r2.className = 'form-row';
        const l2 = document.createElement('div');
        l2.className = 'form-label';
        l2.textContent = 'Утверждение';
        const c2 = document.createElement('div');
        const t2 = document.createElement('textarea');
        t2.className = 'form-textarea';
        t2.placeholder = 'Краткое утверждение, по которому потом будет вопрос.';
        c2.appendChild(t2);
        r2.appendChild(l2);
        r2.appendChild(c2);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить утверждение';
        btnAdd.onclick = () => {
          addAssertionCard(node.id, t2.value, i1.value);
          t2.value = '';
          i1.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(r2);
        secAddBody.appendChild(rowBtns);
      } else if (node.factType === 'years') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Событие';
        const c1 = document.createElement('div');
        const i1 = document.createElement('input');
        i1.className = 'form-input';
        i1.placeholder = 'Например: «Убийство Вещи»';
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const r2 = document.createElement('div');
        r2.className = 'form-row';
        const l2 = document.createElement('div');
        l2.className = 'form-label';
        l2.textContent = 'Год / период';
        const c2 = document.createElement('div');
        const i2 = document.createElement('input');
        i2.className = 'form-input';
        i2.placeholder = 'Например: «1067» или «1359-2053»';
        i2.addEventListener('input', () => {
          i2.value = i2.value.replace(/[^0-9\-–—]/g, '');
        });
        c2.appendChild(i2);
        r2.appendChild(l2);
        r2.appendChild(c2);

        const r3 = document.createElement('div');
        r3.className = 'form-row';
        const l3 = document.createElement('div');
        l3.className = 'form-label';
        l3.textContent = 'Точная дата (необязательно)';
        const c3 = document.createElement('div');
        const dateWrap = document.createElement('div');
        dateWrap.className = 'date-exact-row';
        const i3day = document.createElement('input');
        i3day.className = 'form-input';
        i3day.type = 'number';
        i3day.min = '1';
        i3day.max = '31';
        i3day.placeholder = '32';
        const i3month = document.createElement('input');
        i3month.className = 'form-input';
        i3month.placeholder = 'августа';
        i3month.addEventListener('input', () => {
          i3month.value = i3month.value.replace(/[0-9]/g, '');
          const maxDay = getMaxDaysForMonth(i3month.value.trim());
          i3day.max = String(maxDay);
          const cur = Number(i3day.value);
          if (cur > maxDay) {
            i3day.value = maxDay ? String(maxDay) : '';
          }
        });

        i3day.addEventListener('input', () => {
          const month = i3month.value.trim();
          const maxDay = month ? getMaxDaysForMonth(month) : 31;
          let val = Number(i3day.value);
          if (!val) {
            i3day.value = '';
            return;
          }
          if (val < 1) val = 1;
          if (val > maxDay) val = maxDay;
          i3day.value = String(val);
        });

        dateWrap.appendChild(i3day);
        dateWrap.appendChild(i3month);
        c3.appendChild(dateWrap);
        r3.appendChild(l3);
        r3.appendChild(c3);

        const r4 = document.createElement('div');
        r4.className = 'form-row';
        const l4 = document.createElement('div');
        l4.className = 'form-label';
        l4.textContent = 'Эра';
        const c4 = document.createElement('div');
        const i4 = document.createElement('input');
        i4.className = 'form-input';
        i4.placeholder = 'Например: «н. э.» (оставь пустым, если речь идет о годах нашей эры)';
        c4.appendChild(i4);
        r4.appendChild(l4);
        r4.appendChild(c4);

        const r5 = document.createElement('div');
        r5.className = 'form-row';
        const l5 = document.createElement('div');
        l5.className = 'form-label';
        l5.textContent = 'Персона (необязательно)';
        const c5 = document.createElement('div');
        const i5 = document.createElement('input');
        i5.className = 'form-input';
        i5.placeholder = 'Например: «Скарина»';
        if (parent && parent.name) {
          i5.value = parent.name;
        }
        c5.appendChild(i5);
        r5.appendChild(l5);
        r5.appendChild(c5);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить событие';
        btnAdd.onclick = () => {
          const raw = (i2.value || '').trim();
          if (!raw) {
            alert('Сначала укажи год или период.');
            return;
          }
          if (!isValidYearOrPeriod(raw)) {
            alert('Год / период должен быть в формате «1385» или «1385-1386».');
            return;
          }

          const day = i3day.value.trim();
          const month = i3month.value.trim();

          if (day && !month) {
            alert('Если указываешь число дня, укажи и месяц.');
            return;
          }

          if (day) {
            const maxDay = month ? getMaxDaysForMonth(month) : 31;
            const dayNum = Number(day);
            if (dayNum < 1 || dayNum > maxDay) {
              alert('В этом месяце не может быть дня «' + day + '». Максимум: ' + maxDay + '.');
              return;
            }
          }

          let exact = '';
          if (day || month) {
            exact = day && month ? (day + ' ' + month) : (day || month);
          }
          addYearsCard(node.id, i1.value, raw, i4.value, i5.value, exact);
          i1.value = '';
          i2.value = '';
          i3day.value = '';
          i3month.value = '';
          i4.value = '';
          i5.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(r2);
        secAddBody.appendChild(r3);
        secAddBody.appendChild(r4);
        secAddBody.appendChild(r5);
        secAddBody.appendChild(rowBtns);
      } else if (node.factType === 'olist') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Пункт списка';
        const c1 = document.createElement('div');
        const i1 = document.createElement('textarea');
        i1.className = 'form-textarea';
        i1.placeholder =
          'Каждый пункт списка — отдельный факт. Например: «Столица — Минск».';
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить пункт';
        btnAdd.onclick = () => {
          addOListItem(node.id, i1.value);
          i1.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(rowBtns);
      } else if (node.factType === 'term') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Слово / термин';
        const c1 = document.createElement('div');
        const i1 = document.createElement('input');
        i1.className = 'form-input';
        i1.placeholder = 'Например: «Референдум»';
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const r2 = document.createElement('div');
        r2.className = 'form-row';
        const l2 = document.createElement('div');
        l2.className = 'form-label';
        l2.textContent = 'Определение';
        const c2 = document.createElement('div');
        const i2 = document.createElement('textarea');
        i2.className = 'form-textarea';
        i2.placeholder = 'Краткое, но понятное определение.';
        c2.appendChild(i2);
        r2.appendChild(l2);
        r2.appendChild(c2);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить термин';
        btnAdd.onclick = () => {
          addTermCard(node.id, i1.value, i2.value);
          i1.value = '';
          i2.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(r2);
        secAddBody.appendChild(rowBtns);
      }

      secAdd.appendChild(secAddBody);
      wrapper.appendChild(secAdd);

      // SECTION: Список фактов и тестов
      const secFacts = document.createElement('div');
      secFacts.className = 'section';
      const secFactsHeader = document.createElement('div');
      secFactsHeader.className = 'section-header';
      secFactsHeader.innerHTML =
        '<div class="section-title">Существующие факты внутри паттерна</div>';
      secFacts.appendChild(secFactsHeader);

      const secFactsBody = document.createElement('div');
      secFactsBody.className = 'section-body';

            const cards = node.cards || [];
      if (!cards.length) {
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent =
          'Фактов пока нет. Добавь хотя бы пару выше, чтобы начать тренироваться.';
        secFactsBody.appendChild(p);
      } else {
        const table = document.createElement('table');
        table.className = 'card-table';
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        ['Факт', 'Управление', 'Порядок'].forEach(h => {
          const th = document.createElement('th');
          th.textContent = h;
          trh.appendChild(th);
        });
        thead.appendChild(trh);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');

        cards.forEach((card, index) => {
          const tr = document.createElement('tr');
          const tdText = document.createElement('td');
          const span = document.createElement('div');
          span.className = 'card-display';
          span.textContent = formatFactDisplay(node, card);
          tdText.appendChild(span);

          const tdActions = document.createElement('td');
          const btns = document.createElement('div');
          btns.className = 'card-table-actions';

          const btnEdit = document.createElement('button');
          btnEdit.className = 'btn btn-sm btn-ghost';
          btnEdit.textContent = 'Редактировать';

          const btnDel = document.createElement('button');
          btnDel.className = 'btn btn-sm btn-danger';
          btnDel.textContent = 'Удалить';

          btnDel.onclick = () => {
            const ok = confirm('Удалить этот факт?');
            if (!ok) return;
            deleteCard(node.id, card.id);
            render();
          };

          btnEdit.onclick = () => {
            // не даём открыть несколько форм редактирования для одного факта
            const existing = tdText.querySelector('.fact-edit-container');
            if (existing) existing.remove();

            const editContainer = document.createElement('div');
            editContainer.className = 'fact-edit-container';
            editContainer.style.marginTop = '6px';
            const hr = document.createElement('hr');
            hr.style.border = 'none';
            hr.style.borderTop = '1px dashed rgba(148,163,184,0.4)';
            hr.style.margin = '6px 0';
            editContainer.appendChild(hr);

            const form = document.createElement('div');
            form.className = 'section-body';

            if (node.factType === 'assertion') {
              const r1 = document.createElement('div');
              r1.className = 'form-row';
              const l1 = document.createElement('div');
              l1.className = 'form-label';
              l1.textContent = 'Кто / что?';
              const c1 = document.createElement('div');
              const i1 = document.createElement('input');
              i1.className = 'form-input';
              i1.value = card.subject || '';
              c1.appendChild(i1);
              r1.appendChild(l1);
              r1.appendChild(c1);

              const r2 = document.createElement('div');
              r2.className = 'form-row';
              const l2 = document.createElement('div');
              l2.className = 'form-label';
              l2.textContent = 'Утверждение';
              const c2 = document.createElement('div');
              const i2 = document.createElement('textarea');
              i2.className = 'form-textarea';
              i2.value = card.text || '';
              c2.appendChild(i2);
              r2.appendChild(l2);
              r2.appendChild(c2);

              form.appendChild(r1);
              form.appendChild(r2);

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                updateCard(node.id, card.id, {
                  subject: i1.value,
                  text: i2.value
                });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            } else if (node.factType === 'years') {
              const inputs = {};

              // Событие
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Событие';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.event || '';
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.event = inp;
              }

              // Год / период
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Год / период';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.timeRaw || '';
                inp.addEventListener('input', () => {
                  inp.value = inp.value.replace(/[^0-9\-–—]/g, '');
                });
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.timeRaw = inp;
              }

              // Точная дата (необязательно): день + месяц
              const rExact = document.createElement('div');
              rExact.className = 'form-row';
              const lExact = document.createElement('div');
              lExact.className = 'form-label';
              lExact.textContent = 'Точная дата (необязательно)';
              const cExact = document.createElement('div');
              const wrapExact = document.createElement('div');
              wrapExact.className = 'date-exact-row';

              const inpDay = document.createElement('input');
              inpDay.className = 'form-input';
              inpDay.type = 'number';
              inpDay.min = '1';
              inpDay.max = '31';
              inpDay.placeholder = '32';

              const inpMonth = document.createElement('input');
              inpMonth.className = 'form-input';
              inpMonth.placeholder = 'августа';

              inpMonth.addEventListener('input', () => {
                inpMonth.value = inpMonth.value.replace(/[0-9]/g, '');
                const maxDay = getMaxDaysForMonth(inpMonth.value.trim());
                inpDay.max = String(maxDay);
                const cur = Number(inpDay.value);
                if (cur > maxDay) {
                  inpDay.value = maxDay ? String(maxDay) : '';
                }
              });

              inpDay.addEventListener('input', () => {
                const month = inpMonth.value.trim();
                const maxDay = month ? getMaxDaysForMonth(month) : 31;
                let val = Number(inpDay.value);
                if (!val) {
                  inpDay.value = '';
                  return;
                }
                if (val < 1) val = 1;
                if (val > maxDay) val = maxDay;
                inpDay.value = String(val);
              });

              if (card.timeExact) {
                const parts = String(card.timeExact).split(' ');
                if (parts.length > 0) inpDay.value = parts[0];
                if (parts.length > 1) inpMonth.value = parts.slice(1).join(' ');
              }

              wrapExact.appendChild(inpDay);
              wrapExact.appendChild(inpMonth);
              cExact.appendChild(wrapExact);
              rExact.appendChild(lExact);
              rExact.appendChild(cExact);
              form.appendChild(rExact);

              // Эра
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Эра';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.era || '';
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.era = inp;
              }

              // Персона
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Персона (если не тот о ком идет речь - замени)';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.person || '';
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.person = inp;
              }

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                const raw = (inputs.timeRaw.value || '').trim();
                if (!raw) {
                  alert('Сначала укажи год или период.');
                  return;
                }
                if (!isValidYearOrPeriod(raw)) {
                  alert('Год / период должен быть в формате «1385» или «1385-1386».');
                  return;
                }

                const day = inpDay.value.trim();
                const month = inpMonth.value.trim();

                if (day && !month) {
                  alert('Если указываешь число дня, укажи и месяц.');
                  return;
                }

                if (day) {
                  const maxDay = month ? getMaxDaysForMonth(month) : 31;
                  const dayNum = Number(day);
                  if (dayNum < 1 || dayNum > maxDay) {
                    alert('В этом месяце не может быть дня «' + day + '». Максимум: ' + maxDay + '.');
                    return;
                  }
                }

                let exact = '';
                if (day || month) {
                  exact = day && month ? (day + ' ' + month) : (day || month);
                }
                updateCard(node.id, card.id, {
                  event: inputs.event.value,
                  timeRaw: raw,
                  era: inputs.era.value,
                  person: inputs.person.value,
                  timeExact: exact
                });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            } else if (node.factType === 'olist') {
              const rowF = document.createElement('div');
              rowF.className = 'form-row';
              const l = document.createElement('div');
              l.className = 'form-label';
              l.textContent = 'Пункт списка';
              const c = document.createElement('div');
              const t = document.createElement('textarea');
              t.className = 'form-textarea';
              t.value = card.text || '';
              c.appendChild(t);
              rowF.appendChild(l);
              rowF.appendChild(c);
              form.appendChild(rowF);

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                updateCard(node.id, card.id, { text: t.value });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            } else if (node.factType === 'term') {
              const r1 = document.createElement('div');
              r1.className = 'form-row';
              const l1 = document.createElement('div');
              l1.className = 'form-label';
              l1.textContent = 'Слово / термин';
              const c1 = document.createElement('div');
              const i1 = document.createElement('input');
              i1.className = 'form-input';
              i1.value = card.word || '';
              c1.appendChild(i1);
              r1.appendChild(l1);
              r1.appendChild(c1);

              const r2 = document.createElement('div');
              r2.className = 'form-row';
              const l2 = document.createElement('div');
              l2.className = 'form-label';
              l2.textContent = 'Определение';
              const c2 = document.createElement('div');
              const i2 = document.createElement('textarea');
              i2.className = 'form-textarea';
              i2.value = card.definition || '';
              c2.appendChild(i2);
              r2.appendChild(l2);
              r2.appendChild(c2);

              form.appendChild(r1);
              form.appendChild(r2);

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                updateCard(node.id, card.id, {
                  word: i1.value,
                  definition: i2.value
                });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            }

            editContainer.appendChild(form);
            tdText.appendChild(editContainer);
          };

          btns.appendChild(btnEdit);
          btns.appendChild(btnDel);
          tdActions.appendChild(btns);

          tr.appendChild(tdText);
          tr.appendChild(tdActions);

          const tdOrder = document.createElement('td');
          const orderWrap = document.createElement('div');
          orderWrap.className = 'card-order-controls';

          const btnUp = document.createElement('button');
          btnUp.className = 'btn btn-sm btn-ghost';
          btnUp.textContent = '↑';
          if (index === 0) btnUp.disabled = true;
          btnUp.onclick = () => {
            moveCard(node.id, card.id, 'up');
            render();
          };

          const btnDown = document.createElement('button');
          btnDown.className = 'btn btn-sm btn-ghost';
          btnDown.textContent = '↓';
          if (index === cards.length - 1) btnDown.disabled = true;
          btnDown.onclick = () => {
            moveCard(node.id, card.id, 'down');
            render();
          };

          orderWrap.appendChild(btnUp);
          orderWrap.appendChild(btnDown);
          tdOrder.appendChild(orderWrap);
          tr.appendChild(tdOrder);

          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        secFactsBody.appendChild(table);
      }

      secFacts.appendChild(secFactsBody);
      wrapper.appendChild(secFacts);

      // section: tests for pattern
      const secQuizP = document.createElement('div');
      secQuizP.className = 'section';

      const secQuizPHeader = document.createElement('div');
      secQuizPHeader.className = 'section-header';
      secQuizPHeader.innerHTML =
        '<div class="section-title">Тесты по паттерну</div>';
      secQuizP.appendChild(secQuizPHeader);

      const secQuizPBody = document.createElement('div');
      secQuizPBody.className = 'section-body';

      const pType = node.factType || 'assertion';
      const pStats = computeScopeStats('characteristic', node.id, false);
      const pEnabled = !!pStats.canStart[pType];

      const pRow = document.createElement('div');
      pRow.className = 'row';
      pRow.style.flexWrap = 'wrap';

      const btnStartP = document.createElement('button');
      btnStartP.className = 'btn btn-sm ' + (pEnabled ? 'btn-primary' : 'btn-ghost');
      btnStartP.type = 'button';
      btnStartP.disabled = !pEnabled;
      btnStartP.textContent = 'Начать (' + (node.cards ? node.cards.length : 0) + ')';
      btnStartP.onclick = () => startQuizQuick('characteristic', node.id, pType);
      pRow.appendChild(btnStartP);

      const btnCfgP = document.createElement('button');
      btnCfgP.className = 'btn btn-sm btn-ghost';
      btnCfgP.type = 'button';
      btnCfgP.textContent = '⚙ Настроить';
      btnCfgP.onclick = () => openQuizSetup('characteristic', node.id, [pType]);
      pRow.appendChild(btnCfgP);

      secQuizPBody.appendChild(pRow);

      const hintP = document.createElement('div');
      hintP.className = 'hint';
      hintP.textContent = pEnabled
        ? 'Тест создаётся из фактов внутри этого паттерна. Неправильные ответы подбираются из похожих вариантов + один «несуществующий» ответ.'
        : 'Для теста нужно хотя бы 3 разных ответа внутри этого паттерна.';
      secQuizPBody.appendChild(hintP);

      secQuizP.appendChild(secQuizPBody);
      wrapper.appendChild(secQuizP);

      detailsRootEl.appendChild(wrapper);
      attachSectionToggles(wrapper);
    }

    //     // ===== removed =====

    // ===== removed =====

// ===== QUIZ SYSTEM (smart tests) =====

    const quizSetupModalEl = document.getElementById('quizSetupModal');
    const quizModalEl = document.getElementById('quizModal');

    const quizSetupTitleEl = document.getElementById('quizSetupTitle');
    const quizSetupSubtitleEl = document.getElementById('quizSetupSubtitle');
    const btnQuizSetupClose = document.getElementById('btnQuizSetupClose');
    const btnQuizSetupCancel = document.getElementById('btnQuizSetupCancel');
    const btnQuizStart = document.getElementById('btnQuizStart');

    const quizTypeSegEl = document.getElementById('quizTypeSeg');
    const chkQuizIncludeSubEl = document.getElementById('chkQuizIncludeSub');
    const quizQuestionLimitEl = document.getElementById('quizQuestionLimit');
    const quizModeSegEl = document.getElementById('quizModeSeg');
    const quizDirectionSegEl = document.getElementById('quizDirectionSeg');
    const chkQuizShowExplainEl = document.getElementById('chkQuizShowExplain');

    const quizPatternFilterEl = document.getElementById('quizPatternFilter');
    const btnQuizSelectAll = document.getElementById('btnQuizSelectAll');
    const btnQuizClearAll = document.getElementById('btnQuizClearAll');
    const quizPatternListEl = document.getElementById('quizPatternList');
    const quizSetupHintEl = document.getElementById('quizSetupHint');

    const quizTitleEl = document.getElementById('quizTitle');
    const quizProgressEl = document.getElementById('quizProgress');
    const quizQuestionTitleEl = document.getElementById('quizQuestionTitle');
    const quizPromptTextEl = document.getElementById('quizPromptText');
    const quizChoicesEl = document.getElementById('quizChoices');
    const quizMessageEl = document.getElementById('quizMessage');
    const quizMetaEl = document.getElementById('quizMeta');

    function setQuizPrompt(text, { boxed = false, show = true } = {}) {
      if (!quizPromptTextEl) return;
      if (!show) {
        quizPromptTextEl.textContent = '';
        quizPromptTextEl.style.display = 'none';
        quizPromptTextEl.classList.remove('boxed');
        return;
      }
      quizPromptTextEl.textContent = String(text ?? '');
      quizPromptTextEl.style.display = '';
      quizPromptTextEl.classList.toggle('boxed', !!boxed);
    }

    const btnQuizExit = document.getElementById('btnQuizExit');
    const btnQuizPrev = document.getElementById('btnQuizPrev');
    const btnQuizNext = document.getElementById('btnQuizNext');

    const quizTopicBadgeEl = document.getElementById('quizTopicBadge');
    const quizTypeBadgeEl = document.getElementById('quizTypeBadge');
    const quizProgressFillEl = document.getElementById('quizProgressFill');
    let __quizChoiceButtons = [];


    const QUIZ_PREFS_KEY = 'sh-quiz-prefs-v1';

    const QUIZ_LABELS = {
      assertion: 'Факт',
      years: 'Года',
      olist: 'Список',
      term: 'Термин',
      mix: 'Микс'
    };

    function loadQuizPrefs(){
      try{
        const raw = localStorage.getItem(QUIZ_PREFS_KEY);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(!obj || typeof obj !== 'object') return null;
        return obj;
      }catch{ return null; }
    }
    function saveQuizPrefs(prefs){
      try{ localStorage.setItem(QUIZ_PREFS_KEY, JSON.stringify(prefs||{})); }catch{}
    }

    function __uniq(arr){
      const seen = new Set();
      const out = [];
      arr.forEach(v=>{
        const k = (v ?? '').toString();
        if(!k) return;
        if(seen.has(k)) return;
        seen.add(k);
        out.push(k);
      });
      return out;
    }

    function __shuffle(arr){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function __commonPrefixLen(a,b){
      const n = Math.min(a.length,b.length);
      let i=0;
      for(; i<n; i++){
        if(a[i]!==b[i]) break;
      }
      return i;
    }

    function __stemTokenSet(s){
      const tokens = tokenizeForSearch((s||'').toString());
      const set = new Set();
      tokens.forEach(t=>{
        const st = ruStem(normalizeTextForSearch(t));
        if(st && st.length>=2) set.add(st);
      });
      return set;
    }

    function __jaccardSet(a,b){
      let inter = 0;
      a.forEach(v=>{ if(b.has(v)) inter++; });
      const union = a.size + b.size - inter;
      return union ? (inter/union) : 0;
    }

    function __stringSim(a,b){
      const A = (a||'').toString().trim();
      const B = (b||'').toString().trim();
      if(!A || !B) return 0;
      const aN = normalizeTextForSearch(A);
      const bN = normalizeTextForSearch(B);
      if(aN === bN) return 1.25;
      // 1) prefix helps for single words
      let score = 0;
      const cp = __commonPrefixLen(aN,bN);
      score += Math.min(0.35, cp * 0.05);
      // 2) stems/trigrams
      const aStem = ruStem(aN);
      const bStem = ruStem(bN);
      if(aStem && bStem){
        if(aStem === bStem && aStem.length>=3) score += 0.75;
        score += jaccard(trigrams(aStem), trigrams(bStem)) * 0.55;
      }
      // 3) token overlap for phrases
      const sa = __stemTokenSet(aN);
      const sb = __stemTokenSet(bN);
      score += __jaccardSet(sa,sb) * 0.75;
      return score;
    }

    function __parseFirstYear(s){
      const m = ((s||'')+'').match(/(-?\d{1,4})/);
      if(!m) return null;
      const n = parseInt(m[1],10);
      if(Number.isNaN(n)) return null;
      return n;
    }

    function __formatYearsAnswer(card){
      let t = (card && card.timeRaw ? (card.timeRaw+'').trim() : '');
      let era = (card && card.era ? (card.era+'').trim() : '');
      let exact = (card && card.timeExact ? (card.timeExact+'').trim() : '');
      let out = t;
      if(era) out = out ? (out + ' ' + era) : era;
      if(exact) out = exact + (out ? (' · ' + out) : '');
      return (out || '').trim();
    }

    function __formatYearsEvent(card){
      const ev = (card && card.event ? (card.event+'').trim() : '');
      const who = (card && card.person ? (card.person+'').trim() : '');
      if(who && ev) return who + ': ' + ev;
      return ev || who || '(событие)';
    }

    function __extractPair(text){
      const s = (text||'').toString().trim();
      if(!s) return null;
      // ищем "лево — право" / "лево: право" / "лево -> право"
      const re = /^(.{2,90}?)(?:\s*(?:—|–|-|:|=>|->|→|=)\s*)(.{2,260})$/;
      const m = s.match(re);
      if(!m) return null;
      const left = (m[1]||'').trim();
      const right = (m[2]||'').trim();
      if(!left || !right) return null;
      // фильтр: если "право" слишком длинное — всё равно ок, но ограничим
      return { left, right };
    }

    function __makeFakeAnswer(type, correct, poolAll){
      const poolSet = new Set(poolAll||[]);
      const cor = (correct||'').toString();
      // 1) years: чуть сдвинем число
      if(type === 'years'){
        const y = __parseFirstYear(cor);
        if(y !== null){
          for(let k=0;k<12;k++){
            const delta = (Math.floor(Math.random()*7)-3) || 1;
            const ny = y + delta;
            let fake = cor.replace(String(y), String(ny));
            fake = fake.replace(/\s+/g,' ').trim();
            if(fake && !poolSet.has(fake) && fake !== cor) return fake;
          }
        }
      }

      // 2) общий текст: берём существующий вариант и портим одно слово/число
      const base = (poolAll && poolAll.length ? poolAll[Math.floor(Math.random()*poolAll.length)] : cor) || cor;
      const words = (base||'').toString().match(/[A-Za-zА-Яа-яЁёЭэ0-9]+/g) || [];
      if(!words.length){
        // fallback: добавим символ
        const fake = (base||'') + ' (?)';
        if(fake && !poolSet.has(fake)) return fake;
        return fake;
      }

      // если есть число — сместим его
      const numIdx = words.findIndex(w => /^-?\d{1,4}$/.test(w));
      if(numIdx >= 0){
        const n = parseInt(words[numIdx],10);
        if(!Number.isNaN(n)){
          for(let k=0;k<10;k++){
            const delta = (Math.floor(Math.random()*5)-2) || 1;
            const nn = n + delta;
            const fakeWords = words.slice();
            fakeWords[numIdx] = String(nn);
            const fake = fakeWords.join(' ');
            if(fake && !poolSet.has(fake) && fake !== cor) return fake;
          }
        }
      }

      // меняем одно слово на другое слово из глобального корпуса
      const corpus = window.__quizCorpusTokens || null;
      const idx = Math.floor(Math.random()*words.length);
      let replacement = null;
      if(corpus && corpus.length){
        replacement = corpus[Math.floor(Math.random()*corpus.length)];
      }else{
        // fallback: генерим псевдо-слово
        const letters = 'абвгдежзиклмнопрстуфхцчшщыэюя';
        const len = Math.max(4, Math.min(10, words[idx].length));
        let w = '';
        for(let i=0;i<len;i++){
          w += letters[Math.floor(Math.random()*letters.length)];
        }
        replacement = w;
      }
      const fakeWords = words.slice();
      fakeWords[idx] = replacement;
      const fake = fakeWords.join(' ');
      if(fake && !poolSet.has(fake) && fake !== cor) return fake;

      // last resort
      const fake2 = cor + ' (другое)';
      if(fake2 && !poolSet.has(fake2)) return fake2;
      return fake2;
    }

    function __getNodePathList(nodeId){
      const path = [];
      let cur = getNode(nodeId);
      while(cur && cur.id && cur.id !== state.rootId){
        path.unshift(cur);
        cur = getNode(cur.parentId);
      }
      const root = getNode(state.rootId);
      if(root) path.unshift(root);
      return path;
    }

    function __patternTypeLabel(t){
      return QUIZ_LABELS[t] || t;
    }

    function __collectCorpusTokens(){
      try{
        const tokens = [];
        const nodes = state && state.nodes ? Object.values(state.nodes) : [];
        nodes.forEach(n=>{
          if(!n || n.type !== 'characteristic') return;
          const name = (n.name||'').toString();
          name.match(/[A-Za-zА-Яа-яЁёЭэ]+/g)?.forEach(w=>tokens.push(normalizeTextForSearch(w)));
          (n.cards||[]).forEach(c=>{
            const txt = formatFactDisplay(n,c);
            (txt||'').toString().match(/[A-Za-zА-Яа-яЁёЭэ]+/g)?.forEach(w=>tokens.push(normalizeTextForSearch(w)));
          });
        });
        // чистим
        const filtered = tokens
          .map(t=>(t||'').trim())
          .filter(t=>t && t.length>=3 && t.length<=16);
        window.__quizCorpusTokens = __uniq(filtered).slice(0, 2500);
      }catch{}
    }
    __collectCorpusTokens();

    function getDirectCategoryCharacteristics(categoryId){
      const node = getNode(categoryId);
      if(!node || node.type !== 'category') return [];
      const out = [];
      (node.children||[]).forEach(cid=>{
        const ch = getNode(cid);
        if(ch && ch.type === 'characteristic') out.push(ch);
      });
      return out;
    }

    function collectScopeCharacteristics(scopeType, scopeId, includeSub){
      if(scopeType === 'characteristic'){
        const n = getNode(scopeId);
        return n && n.type === 'characteristic' ? [n] : [];
      }
      if(scopeType === 'category'){
        return includeSub ? getCategoryCharacteristics(scopeId) : getDirectCategoryCharacteristics(scopeId);
      }
      return [];
    }

    function computeScopeStats(scopeType, scopeId, includeSub){
      const chars = collectScopeCharacteristics(scopeType, scopeId, includeSub);
      const byType = { assertion:{patterns:0,cards:0}, years:{patterns:0,cards:0}, olist:{patterns:0,cards:0}, term:{patterns:0,cards:0} };
      chars.forEach(ch=>{
        const t = ch.factType || 'assertion';
        if(!byType[t]) byType[t] = {patterns:0,cards:0};
        byType[t].patterns++;
        byType[t].cards += (ch.cards||[]).length;
      });

      // "можно ли начать": нужно минимум 3 уникальных ответа в пуле
      const canStart = {};
      Object.keys(byType).forEach(t=>{
        const pool = [];
        chars.filter(ch => (ch.factType||'assertion')===t).forEach(ch=>{
          (ch.cards||[]).forEach(c=>{
            const qa = buildQAFromCard(ch, c, t, {direction:'forward'});
            if(qa && qa.answer) pool.push(qa.answer);
          });
        });
        const uniq = __uniq(pool);
        canStart[t] = uniq.length >= 3;
      });

      const canMix = Object.keys(byType).some(t => canStart[t]);
      return { chars, byType, canStart, canMix };
    }

    function buildQAFromCard(patternNode, card, type, opts){
      const direction = (opts && opts.direction) ? opts.direction : 'forward';

      if(type === 'years'){
        const date = __formatYearsAnswer(card);
        const ev = __formatYearsEvent(card);
        const forward = direction !== 'reverse';
        if(forward){
          return {
            promptTitle: 'Укажи дату / период для события:',
            promptText: ev,
            answer: date || '(нет даты)',
            explain: formatFactDisplay(patternNode, card),
            poolKey: 'years:evt2date'
          };
        }else{
          return {
            promptTitle: 'Что произошло в эту дату / период?',
            promptText: date || '(нет даты)',
            answer: ev,
            explain: formatFactDisplay(patternNode, card),
            poolKey: 'years:date2evt'
          };
        }
      }

      if(type === 'term'){
        const w = (card && (card.word||card.term||card.title) ? (card.word||card.term||card.title)+'': '').trim();
        const def = (card && (card.definition||card.def||card.text) ? (card.definition||card.def||card.text)+'': '').trim();
        const forward = direction !== 'reverse';
        if(forward){
          return {
            promptTitle: 'Какое слово подходит под определение?',
            promptText: def || '(нет определения)',
            answer: w || '(нет слова)',
            explain: (w && def) ? ('Термин: ' + w + '\nОпределение: ' + def) : formatFactDisplay(patternNode, card),
            poolKey: 'term:def2word'
          };
        }else{
          return {
            promptTitle: 'Что означает этот термин?',
            promptText: w || '(нет слова)',
            answer: def || '(нет определения)',
            explain: (w && def) ? ('Термин: ' + w + '\nОпределение: ' + def) : formatFactDisplay(patternNode, card),
            poolKey: 'term:word2def'
          };
        }
      }

      if(type === 'assertion' || type === 'olist'){
        const raw = (card && card.text ? (card.text+'') : formatFactDisplay(patternNode, card)) || '';
        const pair = __extractPair(raw);
        if(pair){
          const forward = direction !== 'reverse';
          if(forward){
            return {
              promptTitle: 'Укажи продолжение / ответ для:',
              promptText: pair.left,
              answer: pair.right,
              explain: raw,
              poolKey: type + ':pair:l2r'
            };
          }else{
            return {
              promptTitle: 'К чему относится этот ответ?',
              promptText: pair.right,
              answer: pair.left,
              explain: raw,
              poolKey: type + ':pair:r2l'
            };
          }
        }
        // fallback: строим нормальный вопрос под тип
        const ctxTopic = (() => {
          const topicNode = (patternNode && patternNode.parentId) ? getNode(patternNode.parentId) : null;
          const groupNode = (topicNode && topicNode.parentId) ? getNode(topicNode.parentId) : null;
          return {
            topicNode,
            groupNode,
            topicName: topicNode ? (topicNode.name || '') : '',
            groupId: groupNode ? groupNode.id : (topicNode ? topicNode.id : 'root')
          };
        })();

// ФАКТЫ (assertion)
if(type === 'assertion'){
  const topicLabel = ctxTopic.topicName || (patternNode && patternNode.name) || 'теме';
  const forward = direction !== 'reverse';
  if(forward){
    return {
      promptTitle: 'Что верно про «' + topicLabel + '»?',
      promptText: '',
      answer: raw.trim() || '(пусто)',
      explain: raw,
      poolKey: 'assertion:topic2text:' + ctxTopic.groupId,
      // важно: отвлекающие НЕ из того же паттерна (иначе может быть несколько «правильных»)
      noSamePattern: true
    };
  }else{
    return {
      promptTitle: 'О ком / о чём это утверждение?',
      promptText: raw.trim() || '(пусто)',
      answer: topicLabel,
      explain: 'Тема: ' + topicLabel + '\n' + raw,
      poolKey: 'assertion:text2topic:' + ctxTopic.groupId
    };
  }
}

// ОБЪЕКТНЫЕ СПИСКИ (olist)
if(type === 'olist'){
  const topicLabel = ctxTopic.topicName || (patternNode && patternNode.name) || 'списку';
  const forward = direction !== 'reverse';
  if(forward){
    return {
      promptTitle: 'Что относится к «' + topicLabel + '»?',
      promptText: '',
      answer: raw.trim() || '(пусто)',
      explain: raw,
      poolKey: 'olist:topic2item:' + ctxTopic.groupId,
      noSamePattern: true
    };
  }else{
    return {
      promptTitle: 'К какому списку относится этот элемент?',
      promptText: raw.trim() || '(пусто)',
      answer: topicLabel,
      explain: 'Список: ' + topicLabel + '\n' + raw,
      poolKey: 'olist:item2topic:' + ctxTopic.groupId
    };
  }
}


        // generic fallback
        return {
          promptTitle: 'Выбери правильный текст:',
          promptText: (ctxTopic.topicName
            ? ('Тема: ' + ctxTopic.topicName)
            : ((patternNode && patternNode.name) ? ('Паттерн: ' + patternNode.name) : 'Паттерн')),
          answer: raw.trim() || '(пусто)',
          explain: raw,
          poolKey: type + ':full'
        };
      }

      return null;
    }

    function buildQuestionBank(scopeType, scopeId, includeSub, selectedTypes, selectedPatternIds, opts){
      const chars = collectScopeCharacteristics(scopeType, scopeId, includeSub);
      const typesSet = new Set(selectedTypes || []);
      const pattSet = new Set(selectedPatternIds || []);
      const direction = (opts && opts.direction) ? opts.direction : 'auto';

      function dirForType(t){
        if(direction === 'forward' || direction === 'reverse') return direction;
        // auto
        return 'forward';
      }

      const questions = [];
      const pools = {}; // key -> [{v, patternId}]
      const pattPools = {}; // key -> patternId -> [v]

      chars.forEach(ch=>{
        const t = ch.factType || 'assertion';
        if(!typesSet.has(t)) return;
        if(pattSet.size && !pattSet.has(ch.id)) return;

        const dir = dirForType(t);

        (ch.cards||[]).forEach(card=>{
          const qa = buildQAFromCard(ch, card, t, { direction: dir });
          if(!qa || !qa.answer || (!qa.promptText && !qa.promptTitle)) return;

          const q = {
            id: (ch.id + ':' + (card.id || '') + ':' + Math.random().toString(36).slice(2,8)),
            type: t,
            poolKey: qa.poolKey,
            promptTitle: qa.promptTitle,
            promptText: qa.promptText,
            answer: qa.answer,
            explain: qa.explain,
            patternId: ch.id,
            patternName: ch.name || '(паттерн)',
            parentCategoryId: ch.parentId || null,
            noSamePattern: !!qa.noSamePattern,
            cardId: card.id || null
          };
          questions.push(q);

          pools[q.poolKey] = pools[q.poolKey] || [];
          pools[q.poolKey].push({ v: q.answer, patternId: ch.id });

          pattPools[q.poolKey] = pattPools[q.poolKey] || {};
          pattPools[q.poolKey][ch.id] = pattPools[q.poolKey][ch.id] || [];
          pattPools[q.poolKey][ch.id].push(q.answer);
        });
      });

      // уникализируем пулы
      Object.keys(pools).forEach(k=>{
        pools[k] = __uniq(pools[k].map(x=>x.v));
      });
      Object.keys(pattPools).forEach(k=>{
        Object.keys(pattPools[k]).forEach(pid=>{
          pattPools[k][pid] = __uniq(pattPools[k][pid]);
        });
      });

      // фильтруем вопросы, где нельзя собрать 2 реальных отвлекающих
      const filtered = questions.filter(q=>{
        const pool = pools[q.poolKey] || [];
        const others = pool.filter(v=>v !== q.answer);
        return others.length >= 2;
      });

      return { questions: filtered, pools, pattPools };
    }

    function pickSmartDistractors(q, pools, pattPools, needed){
      const poolAll = (pools[q.poolKey] || []).filter(v => v !== q.answer);
      const poolSame = (q && q.noSamePattern)
        ? []
        : ((pattPools[q.poolKey] && q.patternId && pattPools[q.poolKey][q.patternId])
          ? (pattPools[q.poolKey][q.patternId].filter(v => v !== q.answer))
          : []);

      const candidates = __uniq(poolSame.concat(poolAll));
      if(!candidates.length) return [];

      // years: ближе по числу
      if(q.type === 'years'){
        const y = __parseFirstYear(q.answer);
        if(y !== null){
          const scored = candidates.map(v=>{
            const yy = __parseFirstYear(v);
            const d = (yy===null) ? 99999 : Math.abs(yy - y);
            return { v, s: -d };
          }).sort((a,b)=>b.s-a.s);
          return scored.slice(0,needed).map(x=>x.v);
        }
      }

      // остальное: похожесть текста
      const scored = candidates.map(v=>({ v, s: __stringSim(q.answer, v) + (poolSame.includes(v) ? 0.25 : 0) }))
        .sort((a,b)=>b.s-a.s);

      // чуть рандомизации, чтобы не было всегда одинаково
      const top = scored.slice(0, Math.max(needed*4, 12));
      const mixed = __shuffle(top).sort((a,b)=>b.s-a.s);
      return mixed.slice(0,needed).map(x=>x.v);
    }

    function buildChoicesForQuestion(q, pools, pattPools, mode){
      const poolAll = (pools[q.poolKey] || []);
      const realNeeded = 2;
      let distractors = [];

      if(mode === 'ordered'){
        distractors = __shuffle(poolAll.filter(v=>v !== q.answer)).slice(0, realNeeded);
      }else{
        distractors = pickSmartDistractors(q, pools, pattPools, realNeeded);
        if(distractors.length < realNeeded){
          const rest = __shuffle(poolAll.filter(v=>v !== q.answer && !distractors.includes(v))).slice(0, realNeeded - distractors.length);
          distractors = distractors.concat(rest);
        }
      }

      const fake = __makeFakeAnswer(q.type, q.answer, poolAll.concat(distractors));
      const choices = __shuffle([q.answer].concat(distractors).concat([fake]));

      const correctIndex = choices.indexOf(q.answer);
      return { choices, correctIndex, fake };
    }

    let quizSetupState = null;
    let quizSession = null;

    function openQuizSetup(scopeType, scopeId, preselectTypes){
      if(!quizSetupModalEl) return;

      const scopeNode = getNode(scopeId);
      const scopeName = scopeNode ? (scopeNode.name || (scopeNode.type==='category'?'Категория':'Паттерн')) : '...';

      quizSetupState = {
        scopeType,
        scopeId,
        selectedTypes: new Set(),
        selectedPatternIds: new Set()
      };

      // prefs
      const prefs = loadQuizPrefs() || {};
      const defIncludeSub = (scopeType === 'category') ? (prefs.includeSub !== false) : false;
      const defLimit = (typeof prefs.limit === 'number' ? prefs.limit : 20);
      const defMode = (prefs.mode === 'ordered' ? 'ordered' : 'smart');
      const defDir = (prefs.direction === 'reverse' ? 'reverse' : (prefs.direction === 'forward' ? 'forward' : 'auto'));
      const defExplain = (prefs.explain !== false);

      chkQuizIncludeSubEl.checked = !!defIncludeSub;
      chkQuizIncludeSubEl.disabled = (scopeType !== 'category');

      quizQuestionLimitEl.value = String(Math.max(5, Math.min(200, defLimit)));

      Array.from(quizModeSegEl.querySelectorAll('button')).forEach(b=>{
        b.classList.toggle('active', b.dataset.mode === defMode);
      });
      Array.from(quizDirectionSegEl.querySelectorAll('button')).forEach(b=>{
        b.classList.toggle('active', b.dataset.dir === defDir);
      });
      chkQuizShowExplainEl.checked = !!defExplain;

      // types
      const stats = computeScopeStats(scopeType, scopeId, chkQuizIncludeSubEl.checked);

      // preselect: if passed, otherwise use prefs lastTypes or mix
      let preset = preselectTypes && preselectTypes.length ? preselectTypes : (prefs.lastTypes || ['mix']);
      preset = Array.isArray(preset) ? preset : ['mix'];

      if(preset.includes('mix')){
        quizSetupState.selectedTypes = new Set(['assertion','years','olist','term']);
      }else{
        preset.forEach(t=>{ if(['assertion','years','olist','term'].includes(t)) quizSetupState.selectedTypes.add(t); });
        if(!quizSetupState.selectedTypes.size) quizSetupState.selectedTypes = new Set(['assertion','years','olist','term']);
      }

      // types UI
      updateQuizTypeButtons();

      // patterns default selected: all patterns for selected types
      const allPatterns = stats.chars.filter(ch => quizSetupState.selectedTypes.has(ch.factType || 'assertion'));
      allPatterns.forEach(ch => quizSetupState.selectedPatternIds.add(ch.id));
      // but if scope is a single pattern, lock
      if(scopeType === 'characteristic'){
        quizSetupState.selectedPatternIds = new Set([scopeId]);
      }

      quizSetupTitleEl.textContent = 'ТЕСТЫ — ' + (scopeType === 'category' ? 'отсек' : 'паттерн');
      quizSetupSubtitleEl.textContent = scopeName;

      // render pattern list
      quizPatternFilterEl.value = '';
      renderQuizPatternList();

      updateQuizSetupHint();

      quizSetupModalEl.style.display = 'flex';
      setTimeout(()=>{ quizPatternFilterEl.focus(); }, 0);
    }

    function closeQuizSetup(){
      if(quizSetupModalEl) quizSetupModalEl.style.display = 'none';
      quizSetupState = null;
    }

    function openQuizModal(){
      if(!quizModalEl) return;

      // Make quiz panel sit right under the topbar (no giant empty space)
      try{
        const host = quizModalEl.closest('.sh-app-host') || document;
        const topbar = host.querySelector('.sh-topbar');
        const h = topbar ? topbar.getBoundingClientRect().height : 56;
        // Add a tiny offset so it doesn't "kiss" the topbar border
        quizModalEl.style.setProperty('--quiz-topbar-h', (Math.round(h) + 10) + 'px');
      }catch(e){}

      quizModalEl.style.display = 'flex';
    }
    function closeQuizModal(){
      if(quizModalEl) quizModalEl.style.display = 'none';
      quizSession = null;
    }

    function updateQuizTypeButtons(){
      if(!quizTypeSegEl || !quizSetupState) return;
      const sel = quizSetupState.selectedTypes;
      Array.from(quizTypeSegEl.querySelectorAll('button')).forEach(b=>{
        const t = b.dataset.qtype;
        if(t === 'mix'){
          const on = sel.size === 4;
          b.classList.toggle('active', on);
        }else{
          b.classList.toggle('active', sel.has(t));
        }
      });
    }

    function renderQuizPatternList(){
      if(!quizSetupState || !quizPatternListEl) return;

      const includeSub = chkQuizIncludeSubEl.checked;
      const stats = computeScopeStats(quizSetupState.scopeType, quizSetupState.scopeId, includeSub);
      const filter = (quizPatternFilterEl.value || '').trim().toLowerCase();
      const selTypes = quizSetupState.selectedTypes;

      const patterns = stats.chars
        .filter(ch => selTypes.has(ch.factType || 'assertion'))
        .filter(ch => !filter || (ch.name||'').toLowerCase().includes(filter));

      quizPatternListEl.innerHTML = '';
      if(!patterns.length){
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent = 'Нет паттернов под выбранные типы.';
        quizPatternListEl.appendChild(p);
        return;
      }

      patterns.sort((a,b)=>{
        const ta = a.factType || 'assertion';
        const tb = b.factType || 'assertion';
        if(ta !== tb) return ta.localeCompare(tb);
        return (a.name||'').localeCompare((b.name||''));
      });

      patterns.forEach(ch=>{
        const row = document.createElement('div');
        row.className = 'quiz-pattern-item';
        row.dataset.id = ch.id;

        const left = document.createElement('div');
        left.className = 'quiz-pattern-left';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = quizSetupState.selectedPatternIds.has(ch.id);
        cb.onchange = () => {
          if(cb.checked) quizSetupState.selectedPatternIds.add(ch.id);
          else quizSetupState.selectedPatternIds.delete(ch.id);
          updateQuizSetupHint();
        };

        const name = document.createElement('div');
        name.className = 'quiz-pattern-name';
        name.textContent = ch.name || '(без названия)';

        left.appendChild(cb);
        left.appendChild(name);

        const meta = document.createElement('div');
        meta.className = 'quiz-pattern-meta';
        const t = ch.factType || 'assertion';
        meta.textContent = __patternTypeLabel(t) + ' · ' + ((ch.cards||[]).length);

        row.appendChild(left);
        row.appendChild(meta);

        row.onclick = (e) => {
          // allow clicking row to toggle
          if(e.target && (e.target.tagName||'').toLowerCase() === 'input') return;
          cb.checked = !cb.checked;
          cb.dispatchEvent(new Event('change'));
        };

        quizPatternListEl.appendChild(row);
      });
    }

    function updateQuizSetupHint(){
      if(!quizSetupState || !quizSetupHintEl) return;
      const includeSub = chkQuizIncludeSubEl.checked;
      const stats = computeScopeStats(quizSetupState.scopeType, quizSetupState.scopeId, includeSub);

      const selTypes = Array.from(quizSetupState.selectedTypes);
      const selPats = Array.from(quizSetupState.selectedPatternIds);

      let possible = 0;
      let dropped = 0;

      const { questions } = buildQuestionBank(
        quizSetupState.scopeType,
        quizSetupState.scopeId,
        includeSub,
        selTypes,
        selPats,
        { direction: getActiveSegValue(quizDirectionSegEl, 'dir', 'auto') }
      );

      // посчитаем всё до лимита
      possible = questions.length;

      // ограничение по лимиту
      const lim = parseInt(quizQuestionLimitEl.value,10);
      const limit = (!Number.isNaN(lim) && lim > 0) ? lim : 20;

      const show = Math.min(limit, possible);

      const typeNames = selTypes.map(t=>__patternTypeLabel(t)).join(' · ');
      quizSetupHintEl.textContent =
        'Выбрано: ' + selPats.length + ' паттернов. ' +
        'Типы: ' + typeNames + '. ' +
        'Вопросов доступно: ' + possible + '. ' +
        'В тесте будет: ' + show + '.';

      btnQuizStart.disabled = possible < 1;
    }

    function getActiveSegValue(segEl, attr, fallback){
      if(!segEl) return fallback;
      const b = segEl.querySelector('button.active');
      return b ? (b.dataset[attr] || fallback) : fallback;
    }

    function startQuizWithConfig(cfg){
      const includeSub = !!cfg.includeSub;
      const types = cfg.types || [];
      const patternIds = cfg.patternIds || [];
      const mode = cfg.mode || 'smart';
      const direction = cfg.direction || 'auto';
      const showExplain = cfg.showExplain !== false;

      const bank = buildQuestionBank(cfg.scopeType, cfg.scopeId, includeSub, types, patternIds, { direction });

      let questions = bank.questions.slice();

      if(!questions.length){
        alert('Недостаточно данных для теста. Нужно хотя бы 3 разных ответа внутри выбранных паттернов.');
        return;
      }

      if(mode === 'smart'){
        questions = __shuffle(questions);
      }

      // limit
      const lim = parseInt(cfg.limit,10);
      const limit = (!Number.isNaN(lim) && lim > 0) ? lim : 20;
      questions = questions.slice(0, Math.min(limit, questions.length));

      // build choices
      questions = questions.map(q=>{
        const built = buildChoicesForQuestion(q, bank.pools, bank.pattPools, mode);
        return {
          ...q,
          choices: built.choices,
          correctIndex: built.correctIndex,
          fakeAnswer: built.fake
        };
      });

      const scopeNode = getNode(cfg.scopeId);
      const scopeName = scopeNode ? (scopeNode.name || '') : '';
      const typeTitle = (types.length >= 4) ? 'СБОРНАЯ СОЛЯНКА' : types.map(t=>__patternTypeLabel(t)).join(' · ');

      quizSession = {
        scopeType: cfg.scopeType,
        scopeId: cfg.scopeId,
        scopeName,
        title: typeTitle,
        includeSub,
        mode,
        direction,
        showExplain,
        bank,
        config: { ...cfg },
        questions,
        idx: 0,
        answers: {}, // qid -> {selectedIndex, isCorrect}
        correct: 0,
        startedAt: Date.now()
      };

      openQuizModal();
      renderQuiz();
    }

    function startQuizQuick(scopeType, scopeId, typeOrMix){
      const includeSub = (scopeType === 'category');
      const stats = computeScopeStats(scopeType, scopeId, includeSub);

      let types = [];
      if(typeOrMix === 'mix'){
        types = ['assertion','years','olist','term'].filter(t => stats.canStart[t]);
        if(!types.length){
          alert('В этом месте пока не хватает данных для тестов.');
          return;
        }
      }else{
        types = [typeOrMix];
        if(!stats.canStart[typeOrMix]){
          alert('Для этого типа теста нужно хотя бы 3 разных ответа внутри выбранной области.');
          return;
        }
      }

      // patterns: all in scope for those types
      const chars = collectScopeCharacteristics(scopeType, scopeId, includeSub);
      const patternIds = chars.filter(ch => types.includes(ch.factType || 'assertion')).map(ch => ch.id);

      const prefs = loadQuizPrefs() || {};
      const limit = (typeof prefs.limit === 'number' ? prefs.limit : 20);
      const mode = (prefs.mode === 'ordered' ? 'ordered' : 'smart');
      const direction = (prefs.direction === 'reverse' ? 'reverse' : (prefs.direction === 'forward' ? 'forward' : 'auto'));
      const showExplain = (prefs.explain !== false);

      startQuizWithConfig({
        scopeType,
        scopeId,
        includeSub,
        types,
        patternIds,
        limit,
        mode,
        direction,
        showExplain
      });
    }

    function renderQuiz(){
      if(!quizSession || !quizModalEl) return;

      const qTotal = quizSession.questions.length;
      const idx = quizSession.idx;

      const answeredCount = Object.keys(quizSession.answers || {}).length;
      if(quizProgressFillEl){
        const p = qTotal ? Math.round((Math.min(answeredCount, qTotal) / qTotal) * 100) : 0;
        quizProgressFillEl.style.width = p + '%';
      }


      // end screen
      if(idx >= qTotal){
        const spent = Math.max(1, Math.round((Date.now() - quizSession.startedAt)/1000));
        quizTitleEl.textContent = 'РЕЗУЛЬТАТ — ' + (quizSession.scopeName || quizSession.title || 'ТЕСТ');
        quizProgressEl.textContent = quizSession.correct + '/' + qTotal + ' · ' + spent + ' сек';

        quizQuestionTitleEl.textContent = 'Готово.';
        if(quizTypeBadgeEl) quizTypeBadgeEl.textContent = 'РЕЗУЛЬТАТ';
        if(quizTopicBadgeEl) quizTopicBadgeEl.style.display = 'none';
        __quizChoiceButtons = [];

        const wrong = qTotal - quizSession.correct;
        setQuizPrompt(
          `Правильных: ${quizSession.correct} из ${qTotal}\n` +
          `Ошибок: ${wrong}\n\n` +
          `Хочешь — повтори только ошибки или начни заново.`,
          { boxed: true }
        );

        quizChoicesEl.innerHTML = '';
        const row = document.createElement('div');
        row.style.display = 'grid';
        row.style.gap = '8px';

        const btnRetryWrong = document.createElement('button');
        btnRetryWrong.className = 'btn btn-sm btn-primary';
        btnRetryWrong.textContent = 'Повторить ошибки';
        btnRetryWrong.onclick = () => {
          const wrong = quizSession.questions.filter(qq => {
            const a = quizSession.answers[qq.id];
            return a && !a.isCorrect;
          });
          if(!wrong.length){
            alert('Ошибок нет :)');
            return;
          }

          const rebuilt = wrong.map(qq => {
            const built = buildChoicesForQuestion(qq, quizSession.bank.pools, quizSession.bank.pattPools, quizSession.mode);
            return { ...qq, choices: built.choices, correctIndex: built.correctIndex, fakeAnswer: built.fake };
          });

          quizSession.questions = rebuilt;
          quizSession.idx = 0;
          quizSession.answers = {};
          quizSession.correct = 0;
          quizSession.startedAt = Date.now();
          renderQuiz();
        };
const btnRestart = document.createElement('button');
        btnRestart.className = 'btn btn-sm btn-ghost';
        btnRestart.textContent = 'Начать заново';
        btnRestart.onclick = () => {
          if(quizSession && quizSession.config){
            startQuizWithConfig(quizSession.config);
          }
        };

        row.appendChild(btnRetryWrong);
        row.appendChild(btnRestart);
        quizChoicesEl.appendChild(row);

        quizMessageEl.style.display = 'none';
        quizMetaEl.style.display = 'none';

        btnQuizPrev.disabled = true;
        btnQuizNext.textContent = 'Закрыть';
        btnQuizNext.disabled = false;
        btnQuizNext.onclick = () => closeQuizModal();
        return;
      }

      const q = quizSession.questions[idx];
      const a = quizSession.answers[q.id] || null;



      // context chips: topic (always shows "про кого/про что?", without лишних блоков)
      try{
        const patt = getNode(q.patternId);
        const topicNode = (patt && patt.parentId) ? getNode(patt.parentId) : null;
        const topicName = (topicNode && topicNode.name) ? (topicNode.name + '') : '';
        if(quizTopicBadgeEl){
          if(topicName){
            quizTopicBadgeEl.textContent = 'ТЕМА: ' + topicName;
            quizTopicBadgeEl.style.display = '';
          }else{
            quizTopicBadgeEl.style.display = 'none';
          }
        }
      }catch{
        if(quizTopicBadgeEl) quizTopicBadgeEl.style.display = 'none';
      }

      quizTitleEl.textContent = 'ТЕСТ — ' + (quizSession.scopeName || quizSession.title || '');
      quizProgressEl.textContent = (idx+1) + '/' + qTotal + ' · ' + quizSession.correct + '✔';

      quizQuestionTitleEl.textContent = q.promptTitle;

      // prompt: показываем только если есть смысл (без бесполезных повторов)
      if(quizPromptTextEl){
        const pt = (q.promptText ?? '').toString();
        if(!pt.trim()){
          quizPromptTextEl.textContent = '';
          quizPromptTextEl.style.display = 'none';
          quizPromptTextEl.classList.remove('boxed');
        }else{
          quizPromptTextEl.style.display = '';
          quizPromptTextEl.textContent = pt;
          const boxed = pt.length >= 80 || pt.includes("\n");
          quizPromptTextEl.classList.toggle('boxed', boxed);
        }
      }

      if(quizTypeBadgeEl){
        quizTypeBadgeEl.textContent = (QUIZ_LABELS[q.type] || (q.type||'')).toString();
      }


      // meta (только путь — без повторов «паттерн/факт»)
      if(quizMetaEl){
        const pathList = __getNodePathList(q.patternId);
        const pathStr = pathList.map(n=>n.name||'').filter(Boolean).join(' → ');
        quizMetaEl.textContent = pathStr ? ('Путь: ' + pathStr) : '';
        quizMetaEl.style.display = pathStr ? 'block' : 'none';
      }

      // choices
      quizChoicesEl.innerHTML = '';
      quizMessageEl.style.display = 'none';

      const buttons = [];

      q.choices.forEach((choice, i)=>{
        const b = document.createElement('button');
        b.className = 'quiz-choice';
        b.type = 'button';
        b.textContent = choice;

        b.dataset.kbd = String(i+1);
        b.setAttribute('aria-label', 'Вариант ' + (i+1) + ': ' + choice);


        const isAnswered = !!a;
        if(isAnswered) b.disabled = true;

        b.onclick = () => {
          if(quizSession.answers[q.id]) return;

          const isCorrect = (i === q.correctIndex);
          quizSession.answers[q.id] = { selectedIndex: i, isCorrect };
          if(isCorrect) quizSession.correct++;

          // paint
          buttons.forEach((bb, bi)=>{
            bb.disabled = true;
            if(bi === q.correctIndex) bb.classList.add('correct');
            if(bi === i && bi !== q.correctIndex) bb.classList.add('wrong');
          });

          // message
          if(quizSession.showExplain){
            quizMessageEl.style.display = 'block';
            quizMessageEl.textContent =
              (isCorrect ? 'Верно.' : 'Неверно.') + '\n' +
              'Правильный ответ: ' + q.choices[q.correctIndex] + '\n\n' +
              (q.explain || '');
          }else{
            quizMessageEl.style.display = 'block';
            quizMessageEl.textContent =
              (isCorrect ? 'Верно.' : 'Неверно.') + '\n' +
              'Правильный ответ: ' + q.choices[q.correctIndex];
          }

          btnQuizNext.disabled = false;
          btnQuizNext.focus();
        };

        buttons.push(b);
        quizChoicesEl.appendChild(b);
      });

      __quizChoiceButtons = buttons;

      // if revisiting answered
      if(a){
        buttons.forEach((bb, bi)=>{
          bb.disabled = true;
          if(bi === q.correctIndex) bb.classList.add('correct');
          if(bi === a.selectedIndex && bi !== q.correctIndex) bb.classList.add('wrong');
        });
        quizMessageEl.style.display = 'block';
        quizMessageEl.textContent =
          (a.isCorrect ? 'Верно.' : 'Неверно.') + '\n' +
          'Правильный ответ: ' + q.choices[q.correctIndex] + '\n\n' +
          (quizSession.showExplain ? (q.explain||'') : '');
      }

      btnQuizPrev.disabled = (idx <= 0);
      btnQuizPrev.onclick = () => {
        if(quizSession.idx > 0){
          quizSession.idx--;
          renderQuiz();
        }
      };

      btnQuizNext.textContent = (idx === qTotal-1 ? 'Результат' : 'Дальше');
      btnQuizNext.disabled = !a; // until answered
      btnQuizNext.onclick = () => {
        if(idx < qTotal){
          quizSession.idx++;
          renderQuiz();
        }
      };
    }

    // Setup modal events
    if(btnQuizSetupClose) btnQuizSetupClose.onclick = closeQuizSetup;
    if(btnQuizSetupCancel) btnQuizSetupCancel.onclick = closeQuizSetup;

    if(quizTypeSegEl){
      quizTypeSegEl.addEventListener('click', (e)=>{
        const b = e.target.closest('button');
        if(!b || !quizSetupState) return;
        const t = b.dataset.qtype;
        if(!t) return;

        if(t === 'mix'){
          quizSetupState.selectedTypes = new Set(['assertion','years','olist','term']);
        }else{
          if(quizSetupState.selectedTypes.has(t)) quizSetupState.selectedTypes.delete(t);
          else quizSetupState.selectedTypes.add(t);
          if(!quizSetupState.selectedTypes.size){
            quizSetupState.selectedTypes.add(t);
          }
          // если выбраны все 4 => считаем как mix
          if(quizSetupState.selectedTypes.size === 4){
            // nothing
          }
        }
        updateQuizTypeButtons();

        // auto adjust pattern selection: keep existing selection if still visible, else add required
        const includeSub = chkQuizIncludeSubEl.checked;
        const stats = computeScopeStats(quizSetupState.scopeType, quizSetupState.scopeId, includeSub);
        const allowed = new Set(stats.chars.filter(ch => quizSetupState.selectedTypes.has(ch.factType||'assertion')).map(ch=>ch.id));
        // remove disallowed
        Array.from(quizSetupState.selectedPatternIds).forEach(pid=>{
          if(!allowed.has(pid)) quizSetupState.selectedPatternIds.delete(pid);
        });
        // if nothing selected -> select all allowed
        if(!quizSetupState.selectedPatternIds.size){
          allowed.forEach(pid=>quizSetupState.selectedPatternIds.add(pid));
        }

        renderQuizPatternList();
        updateQuizSetupHint();
      });
    }

    if(chkQuizIncludeSubEl){
      chkQuizIncludeSubEl.addEventListener('change', ()=>{
        if(!quizSetupState) return;
        renderQuizPatternList();
        updateQuizSetupHint();
      });
    }

    if(quizPatternFilterEl){
      quizPatternFilterEl.addEventListener('input', ()=>{
        renderQuizPatternList();
      });
    }

    if(btnQuizSelectAll){
      btnQuizSelectAll.onclick = ()=>{
        if(!quizSetupState) return;
        const includeSub = chkQuizIncludeSubEl.checked;
        const stats = computeScopeStats(quizSetupState.scopeType, quizSetupState.scopeId, includeSub);
        stats.chars
          .filter(ch => quizSetupState.selectedTypes.has(ch.factType||'assertion'))
          .forEach(ch => quizSetupState.selectedPatternIds.add(ch.id));
        renderQuizPatternList();
        updateQuizSetupHint();
      };
    }
    if(btnQuizClearAll){
      btnQuizClearAll.onclick = ()=>{
        if(!quizSetupState) return;
        quizSetupState.selectedPatternIds.clear();
        renderQuizPatternList();
        updateQuizSetupHint();
      };
    }

    if(quizQuestionLimitEl){
      quizQuestionLimitEl.addEventListener('input', ()=>{
        updateQuizSetupHint();
      });
    }

    if(quizModeSegEl){
      quizModeSegEl.addEventListener('click', (e)=>{
        const b = e.target.closest('button');
        if(!b) return;
        Array.from(quizModeSegEl.querySelectorAll('button')).forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        updateQuizSetupHint();
      });
    }

    if(quizDirectionSegEl){
      quizDirectionSegEl.addEventListener('click', (e)=>{
        const b = e.target.closest('button');
        if(!b) return;
        Array.from(quizDirectionSegEl.querySelectorAll('button')).forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        updateQuizSetupHint();
      });
    }

    if(btnQuizStart){
      btnQuizStart.onclick = ()=>{
        if(!quizSetupState) return;

        const includeSub = chkQuizIncludeSubEl.checked;
        const types = Array.from(quizSetupState.selectedTypes);
        const patternIds = Array.from(quizSetupState.selectedPatternIds);

        const mode = getActiveSegValue(quizModeSegEl, 'mode', 'smart');
        const direction = getActiveSegValue(quizDirectionSegEl, 'dir', 'auto');
        const lim = parseInt(quizQuestionLimitEl.value,10);
        const limit = (!Number.isNaN(lim) && lim>0) ? lim : 20;
        const showExplain = chkQuizShowExplainEl.checked;

        // persist prefs
        const prefs = loadQuizPrefs() || {};
        prefs.includeSub = includeSub;
        prefs.limit = limit;
        prefs.mode = mode;
        prefs.direction = direction;
        prefs.explain = showExplain;
        prefs.lastTypes = (types.length >= 4 ? ['mix'] : types);
        saveQuizPrefs(prefs);

        const cfg = {
          scopeType: quizSetupState.scopeType,
          scopeId: quizSetupState.scopeId,
          includeSub,
          types,
          patternIds,
          limit,
          mode,
          direction,
          showExplain
        };
        closeQuizSetup();
        startQuizWithConfig(cfg);
      };
    }

    // Quiz modal events
    if(btnQuizExit) btnQuizExit.onclick = () => closeQuizModal();

    document.addEventListener('keydown', (e)=>{
      const ae = document.activeElement;
      const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : '';
      const isTyping = tag === 'input' || tag === 'textarea' || (ae && ae.isContentEditable);

      // ESC: close overlays
      if(e.key === 'Escape'){
        if(quizModalEl && quizModalEl.style.display === 'flex'){
          e.preventDefault();
          closeQuizModal();
          return;
        }
        if(quizSetupModalEl && quizSetupModalEl.style.display === 'flex'){
          e.preventDefault();
          closeQuizSetup();
          return;
        }
      }

      // Hotkeys inside quiz (don’t steal focus from inputs)
      if(isTyping) return;
      if(!(quizModalEl && quizModalEl.style.display === 'flex' && quizSession)) return;

      // 1–4: pick answer
      if(e.key === '1' || e.key === '2' || e.key === '3' || e.key === '4'){
        const idx = parseInt(e.key, 10) - 1;
        const b = __quizChoiceButtons && __quizChoiceButtons[idx] ? __quizChoiceButtons[idx] : null;
        if(b && !b.disabled){
          e.preventDefault();
          b.click();
        }
        return;
      }

      // Enter: next
      if(e.key === 'Enter'){
        if(btnQuizNext && !btnQuizNext.disabled){
          e.preventDefault();
          btnQuizNext.click();
        }
        return;
      }

      // Arrows: prev / next
      if(e.key === 'ArrowLeft'){
        if(btnQuizPrev && !btnQuizPrev.disabled){
          e.preventDefault();
          btnQuizPrev.click();
        }
        return;
      }
      if(e.key === 'ArrowRight'){
        if(btnQuizNext && !btnQuizNext.disabled){
          e.preventDefault();
          btnQuizNext.click();
        }
        return;
      }
    });

// ===== END QUIZ SYSTEM =====

// ===== CREATE MODAL =====

    let createDialogState = null;
    let createConfigScope = 'subject';
    let createConfigPresetSubject = 'history';
    let createConfigPresetPersonal = 'notes';
    let createPatternType = 'assertion';

    function openCreateDialog(kind, parentId) {
      createDialogState = { kind, parentId };

      if (kind === 'category') {
        createModalTitleEl.textContent = 'Новая категория';
        createModalSubtitleEl.textContent =
          parentId === state.rootId
            ? 'Это корневая категория. Можно выбрать конфигурацию (История, Англ, Личное).'
            : 'Название новой подкатегории.';
        createNameLabelEl.textContent = 'Название категории';
        createConfigBlockEl.style.display =
          parentId === state.rootId ? 'block' : 'none';
        if (createPatternTypeBlockEl) createPatternTypeBlockEl.style.display = 'none';
      } else {
        createModalTitleEl.textContent = 'Новый паттерн';
        createModalSubtitleEl.textContent =
          'Дай имя паттерну и выбери тип фактов внутри него.';
        createNameLabelEl.textContent = 'Название паттерна';
        createConfigBlockEl.style.display = 'none';
        if (createPatternTypeBlockEl) createPatternTypeBlockEl.style.display = 'block';
      }

      createNameInputEl.value = '';
      createConfigScope = 'subject';
      createConfigPresetSubject = 'history';
      createConfigPresetPersonal = 'notes';
      createPatternType = 'assertion';
      updateConfigSegUI();
      updatePatternTypeUI();

      createModalEl.style.display = 'flex';
      setTimeout(() => createNameInputEl.focus(), 0);
    }

    function closeCreateDialog() {
      createModalEl.style.display = 'none';
      createDialogState = null;
    }

    function updateConfigSegUI() {
      Array.from(segConfigScopeEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.scope === createConfigScope);
      });
      if (createConfigScope === 'subject') {
        configPresetSubjectEl.style.display = 'block';
        configPresetPersonalEl.style.display = 'none';
      } else {
        configPresetSubjectEl.style.display = 'none';
        configPresetPersonalEl.style.display = 'block';
      }
      Array.from(segConfigPresetSubjectEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.preset === createConfigPresetSubject);
      });
      Array.from(segConfigPresetPersonalEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.preset === createConfigPresetPersonal);
      });
    }


    function updatePatternTypeUI() {
      if (!segPatternTypeEl) return;
      Array.from(segPatternTypeEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.ptype === createPatternType);
      });
    }

    // ===== EXPORT / IMPORT =====

function importStateFromJsonText(jsonText) {
  try {
    const data = JSON.parse(jsonText);
    if (!data || typeof data !== 'object' || !data.nodes) {
      alert('Файл не похож на базу Помогатора.');
      return;
    }
    state = data;
    currentNodeId = state.rootId || 'root';
    sidebarViewNodeId = state.rootId || 'root';
    saveState();
    render();
  } catch (err) {
    console.error(err);
    alert('Не удалось прочитать JSON-файл.');
  }
}

if (btnExport) {
  btnExport.onclick = () => {
    const json = JSON.stringify(state, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'exam-db.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };
}

if (btnImport) {
  btnImport.onclick = () => {
    if (!fileInput) return;
    fileInput.value = '';
    fileInput.click();
  };
}

if (fileInput) {
  fileInput.onchange = (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => importStateFromJsonText(reader.result);
    reader.readAsText(file, 'utf-8');
  };
}

    // ===== EVENT BINDINGS =====

    if (segPatternTypeEl) {
      segPatternTypeEl.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn || !btn.dataset.ptype) return;
        createPatternType = btn.dataset.ptype;
        updatePatternTypeUI();
      });
    }


    if (btnImportInCreate) {
      btnImportInCreate.onclick = () => {
        closeCreateDialog();
        btnImport.click();
      };
    }

    // '+' в иерархии: панель (создать корень / импортировать базу)
function openRootPlusModal() {
  if (!rootPlusModalEl) {
    // fallback: если модалки нет — просто открываем создание корня
    openCreateDialog('category', state.rootId);
    return;
  }
  rootPlusModalEl.style.display = 'flex';
}

function closeRootPlusModal() {
  if (!rootPlusModalEl) return;
  rootPlusModalEl.style.display = 'none';
}

if (btnTreeAddRoot) {
  btnTreeAddRoot.onclick = () => openRootPlusModal();
}

if (rootPlusCloseEl) rootPlusCloseEl.onclick = () => closeRootPlusModal();
if (rootPlusCancelEl) rootPlusCancelEl.onclick = () => closeRootPlusModal();

if (rootPlusModalEl) {
  // клик по затемнению — закрыть
  rootPlusModalEl.addEventListener('click', (e) => {
    if (e.target === rootPlusModalEl) closeRootPlusModal();
  });
}

if (rootPlusCreateEl) {
  rootPlusCreateEl.onclick = () => {
    closeRootPlusModal();
    openCreateDialog('category', state.rootId);
  };
}

if (rootPlusImportEl) {
  rootPlusImportEl.onclick = () => {
    closeRootPlusModal();
    if (btnImport) btnImport.click();
  };
}

if (btnCreateRootCategory) btnCreateRootCategory.onclick = () => {
      const node = getNode(currentNodeId) || getNode(state.rootId);
      const parentId = node && node.type === 'category' ? node.id : state.rootId;
      openCreateDialog('category', parentId);
    };

    if (btnRootsAdd) {
      btnRootsAdd.onclick = () => openCreateDialog('category', state.rootId);
    }

    if (btnRootbarAdd) {
      btnRootbarAdd.onclick = () => openCreateDialog('category', state.rootId);
    }


    segConfigScopeEl.addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      createConfigScope = btn.dataset.scope;
      updateConfigSegUI();
    });

    segConfigPresetSubjectEl.addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      createConfigPresetSubject = btn.dataset.preset;
      updateConfigSegUI();
    });

    segConfigPresetPersonalEl.addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      createConfigPresetPersonal = btn.dataset.preset;
      updateConfigSegUI();
    });

    btnCreateClose.onclick = () => closeCreateDialog();
    btnCreateCancel.onclick = () => closeCreateDialog();
    btnCreateConfirm.onclick = () => {
      if (!createDialogState) {
        closeCreateDialog();
        return;
      }
      const { kind, parentId } = createDialogState;
      let name = createNameInputEl.value.trim();
      if (!name) {
        name =
          kind === 'category'
            ? parentId === state.rootId
              ? 'Новая категория'
              : 'Новая подкатегория'
            : 'Новая характеристика';
      }

      let newId = null;
      if (kind === 'category') {
        let config = null;
        if (parentId === state.rootId) {
          config = {
            scope: createConfigScope,
            preset:
              createConfigScope === 'subject'
                ? createConfigPresetSubject
                : createConfigPresetPersonal
          };
        }
        newId = createCategory(name, parentId, config);
      } else {
        newId = createCharacteristic(name, parentId, createPatternType);
      }

      if (newId) {
        currentNodeId = newId;
        if (kind === 'category') {
          sidebarViewNodeId = newId;
        } else if (parentId) {
          const parentNode = getNode(parentId);
          if (parentNode && parentNode.type === 'category') {
            sidebarViewNodeId = parentNode.id;
          }
        }
      }

      closeCreateDialog();
      render();
    };

        // (quiz / facts buttons removed)

function renderRootsScreen() {
      if (!rootsListEl) return;

      rootsListEl.innerHTML = '';

      const root = getNode(state.rootId);
      const hasUserRoot = !!root;

      // --- СЕКЦИЯ: твои корни ---
      if (hasUserRoot) {
        const userSection = document.createElement('div');
        userSection.className = 'roots-section';

        const userTitle = document.createElement('div');
        userTitle.className = 'roots-section-title';
        userTitle.textContent = 'твои корни';
        userSection.appendChild(userTitle);

        const items = (root.children || [])
          .map(id => getNode(id))
          .filter(n => n && n.type === 'category');

        if (!items.length) {
          const empty = document.createElement('div');
          empty.className = 'roots-empty';
          empty.textContent = 'Пока нет корней. Нажми «+», чтобы создать первый.';
          userSection.appendChild(empty);
        } else {
          items.forEach(node => {
            const row = document.createElement('div');
            row.className = 'root-item';
            row.dataset.id = node.id;
            row.dataset.source = 'user';

            const star = document.createElement('div');
            star.className = 'root-item-star';
            star.textContent = '✶';

            const label = document.createElement('div');
            label.className = 'root-item-label';
            label.textContent = 'ПРЕДМЕТ // ' + (node.name || '(без названия)');

            row.appendChild(star);
            row.appendChild(label);

            userSection.appendChild(row);
          });
        }

        rootsListEl.appendChild(userSection);
      }

      // --- СЕКЦИЯ: item:корни (корни разработчика) ---
      if (window.__developerState && window.__developerState.nodes) {
        const devRootId = window.__developerState.rootId;
        const devRoot = window.__developerState.nodes[devRootId];
        if (devRoot) {
          const devItems = (devRoot.children || [])
            .map(id => window.__developerState.nodes[id])
            .filter(n => n && n.type === 'category');

          if (devItems.length) {
            const devSection = document.createElement('div');
            devSection.className = 'roots-section';

            const devTitle = document.createElement('div');
            devTitle.className = 'roots-section-title';
            devTitle.textContent = 'item:корни (корни разработчика)';
            devSection.appendChild(devTitle);

            devItems.forEach(node => {
              const row = document.createElement('div');
              row.className = 'root-item';
              row.dataset.id = node.id;
              row.dataset.source = 'dev';

              const star = document.createElement('div');
              star.className = 'root-item-star';
              star.textContent = '✶';

              const label = document.createElement('div');
              label.className = 'root-item-label';
              label.textContent = 'DEV // ' + (node.name || '(без названия)');

              row.appendChild(star);
              row.appendChild(label);

              devSection.appendChild(row);
            });

            rootsListEl.appendChild(devSection);
          }
        }
      }
    }


    function findRootCategoryForNode(nodeId) {
      const root = getNode(state.rootId);
      if (!root) return null;
      let node = getNode(nodeId);
      if (!node) return null;
      while (node.parentId && node.parentId !== state.rootId) {
        node = getNode(node.parentId);
        if (!node) return null;
      }
      if (node.parentId === state.rootId) return node.id;
      return null;
    }

    function renderRootbar() {
      if (!rootbarListEl) return;

      rootbarListEl.innerHTML = '';

      const root = getNode(state.rootId);
      if (!root) {
        const empty = document.createElement('div');
        empty.className = 'hint';
        empty.style.fontSize = '9px';
        empty.textContent = 'Нет корневых категорий.';
        rootbarListEl.appendChild(empty);
        return;
      }

      const items = (root.children || [])
        .map(id => getNode(id))
        .filter(n => n && n.type === 'category');

      const title = document.createElement('div');
      title.className = 'rootbar-section-title';
      title.textContent = 'твои корни';
      rootbarListEl.appendChild(title);

      if (!items.length) {
        const empty = document.createElement('div');
        empty.className = 'hint';
        empty.style.fontSize = '9px';
        empty.textContent = 'Нажми «+», чтобы создать первый корень.';
        rootbarListEl.appendChild(empty);
        return;
      }

      const currentRootId = findRootCategoryForNode(currentNodeId);

      items.forEach(node => {
        const row = document.createElement('div');
        row.className = 'rootbar-item';
        if (currentRootId && currentRootId === node.id) {
          row.classList.add('rootbar-item-current');
        }
        const label = document.createElement('div');
        label.className = 'rootbar-item-label';
        label.textContent = node.name || '(без названия)';
        row.appendChild(label);

        row.onclick = () => {
          sidebarViewNodeId = node.id;
          currentNodeId = node.id;
          render();
        };

        rootbarListEl.appendChild(row);
      });
    }
    
    function findRootCategoryForNode(nodeId) {
      const root = getNode(state.rootId);
      if (!root) return null;
      let node = getNode(nodeId);
      if (!node) return null;
      while (node.parentId && node.parentId !== state.rootId) {
        node = getNode(node.parentId);
        if (!node) return null;
      }
      if (node.parentId === state.rootId) return node.id;
      return null;
    }

    function renderRootbar() {
      if (!rootbarListEl) return;

      rootbarListEl.innerHTML = '';

      const root = getNode(state.rootId);
      if (!root) {
        const empty = document.createElement('div');
        empty.className = 'hint';
        empty.style.fontSize = '9px';
        empty.textContent = 'Нет корневых категорий.';
        rootbarListEl.appendChild(empty);
        return;
      }

      const items = (root.children || [])
        .map(id => getNode(id))
        .filter(n => n && n.type === 'category');

      const title = document.createElement('div');
      title.className = 'rootbar-section-title';
      title.textContent = 'твои корни';
      rootbarListEl.appendChild(title);

      if (!items.length) {
        const empty = document.createElement('div');
        empty.className = 'hint';
        empty.style.fontSize = '9px';
        empty.textContent = 'Нажми «+», чтобы создать первый корень.';
        rootbarListEl.appendChild(empty);
        return;
      }

      const currentRootId = findRootCategoryForNode(currentNodeId);

      items.forEach(node => {
        const row = document.createElement('div');
        row.className = 'rootbar-item';
        if (currentRootId && currentRootId === node.id) {
          row.classList.add('rootbar-item-current');
        }
        const label = document.createElement('div');
        label.className = 'rootbar-item-label';
        label.textContent = node.name || '(без названия)';
        row.appendChild(label);

        row.onclick = () => {
          sidebarViewNodeId = node.id;
          currentNodeId = node.id;
          render();
        };

        rootbarListEl.appendChild(row);
      });
    }

        
        // ===== ГЛОБАЛЬНЫЙ ПОИСК ПО САЙТУ =====
    const globalSearchInputEl = document.getElementById('globalSearchInput');
    const globalSearchResultsEl = document.getElementById('globalSearchResults');

    function normalizeTextForSearch(str) {
      return (str || '')
        .toString()
        .toLowerCase()
        .replace(/ё/g, 'е')
        .replace(/э/g, 'е')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function tokenizeForSearch(str) {
      const s = normalizeTextForSearch(str);
      const m = s.match(/[a-zа-я0-9]+/g);
      return m ? m : [];
    }

    function isNumericQueryToken(t) {
      return /^[0-9]+$/.test(t || '');
    }

    // Очень лёгкий "стеммер" под русские окончания (пример: цехИ ~ цехА)
    function ruStem(word) {
      const w = normalizeTextForSearch(word);
      if (w.length <= 3) return w;

      const endings = [
        'иями','ями','ами',
        'ого','его','ому','ему',
        'ыми','ими',
        'ах','ях',
        'ов','ев','ёв',
        'ам','ям',
        'ая','яя',
        'ое','ее',
        'ую','юю',
        'ый','ий',
        'ые','ие',
        'а','я','ы','и','е','о','у','ю','ь','й'
      ];

      for (const end of endings) {
        if (w.endsWith(end) && w.length - end.length >= 3) {
          return w.slice(0, -end.length);
        }
      }
      return w;
    }

    function trigrams(s) {
      const t = normalizeTextForSearch(s);
      const out = new Set();
      if (t.length <= 2) {
        out.add(t);
        return out;
      }
      for (let i = 0; i < t.length - 2; i++) {
        out.add(t.slice(i, i + 3));
      }
      return out;
    }

    function jaccard(a, b) {
      if (!a.size && !b.size) return 1;
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      const union = a.size + b.size - inter;
      return union ? inter / union : 0;
    }

    // Ограниченный Левенштейн (быстро и достаточно для "цеха"~"цехи")
    function levenshtein(a, b, maxDist) {
      a = normalizeTextForSearch(a);
      b = normalizeTextForSearch(b);
      if (a === b) return 0;
      if (!a || !b) return Math.max(a.length, b.length);
      if (Math.abs(a.length - b.length) > maxDist) return maxDist + 1;

      const v0 = new Array(b.length + 1);
      const v1 = new Array(b.length + 1);

      for (let i = 0; i <= b.length; i++) v0[i] = i;

      for (let i = 0; i < a.length; i++) {
        v1[0] = i + 1;
        let rowMin = v1[0];

        for (let j = 0; j < b.length; j++) {
          const cost = a[i] === b[j] ? 0 : 1;
          v1[j + 1] = Math.min(
            v1[j] + 1,
            v0[j + 1] + 1,
            v0[j] + cost
          );
          if (v1[j + 1] < rowMin) rowMin = v1[j + 1];
        }

        if (rowMin > maxDist) return maxDist + 1;

        for (let j = 0; j <= b.length; j++) v0[j] = v1[j];
      }
      return v0[b.length];
    }

    function fuzzyTermInText(term, textNorm, tokens) {
      const t = normalizeTextForSearch(term);
      if (!t) return false;

      // Для чисел (годы и т.п.) — только точное совпадение (никаких "похожих годов")
      if (isNumericQueryToken(t)) {
        return textNorm.includes(t);
      }

      // 1) точное вхождение (быстро)
      if (textNorm.includes(t)) return true;

      // 2) сравнение по словам
      const tStem = ruStem(t);
      const tTri = trigrams(tStem);
      const tLen = t.length;

      for (const w of tokens) {
        if (!w) continue;

        // быстрые совпадения по префиксу
        if (w.startsWith(t) || t.startsWith(w)) {
          if (Math.min(w.length, tLen) >= 3) return true;
        }

        // если слово в тексте числовое — не считаем его "похожим" на не-число
        if (isNumericQueryToken(w)) continue;

        const wStem = ruStem(w);

        // совпадение стемов
        if (wStem === tStem && wStem.length >= 3) return true;

        // близость по Левенштейну (короткие слова)
        const maxDist = tLen <= 6 ? 1 : (tLen <= 10 ? 2 : 0);
        if (maxDist) {
          const d = levenshtein(wStem, tStem, maxDist);
          if (d <= maxDist) return true;
        }

        // "похожесть" по триграммам (для чуть более сложных случаев)
        const sim = jaccard(tTri, trigrams(wStem));
        if (sim >= 0.45 && Math.min(wStem.length, tStem.length) >= 4) return true;
      }

      return false;
    }

    function buildNodeRawText(node) {
      if (!node) return '';
      let parts = [node.name || ''];
      if (node.cards && node.cards.length) {
        (node.cards || []).forEach(card => {
          parts.push(formatFactDisplay(node, card));
          if (card.text) parts.push(card.text);
          if (card.event) parts.push(card.event);
          if (card.person) parts.push(card.person);
          if (card.word) parts.push(card.word);
          if (card.definition) parts.push(card.definition);
          if (card.timeRaw) parts.push(card.timeRaw);
        });
      }
      return parts.join(' • ');
    }

    function buildNodeFullText(node) {
      return normalizeTextForSearch(buildNodeRawText(node));
    }

    function buildPathForNode(node) {
      if (!node) return '';
      const parts = [node.name || '(без названия)'];
      let current = node;
      while (current && current.parentId) {
        const parent = getNode(current.parentId);
        if (!parent) break;
        parts.push(parent.name || '(без названия)');
        current = parent;
      }
      parts.reverse();
      return parts.join(' → ');
    }

    // ===== SEARCH CACHE (словарь + токены по узлам) =====
    // Нужно для "умного" автодополнения и более стабильного ранжирования.
    const __searchStopWords = new Set([
      'и','в','во','на','к','ко','с','со','по','из','у','о','об','от','до','за','для','над','под',
      'что','это','как','то','а','но','не','ни','же','ли','бы','про','при','без','между','либо',
      'так','там','тут','его','ее','её','их','мы','вы','они','он','она','оно','я','ты','вы','выше','ниже',
      'год','годы','век','века'
    ]);

    let __searchCacheRev = -1;
    let __searchCacheNodes = [];
    let __searchWordFreq = new Map();
    let __searchWordBuckets = Object.create(null);

    function __commonPrefixLen(a, b) {
      a = a || ''; b = b || '';
      const n = Math.min(a.length, b.length);
      let i = 0;
      while (i < n && a[i] === b[i]) i++;
      return i;
    }

    function rebuildSearchCache() {
      __searchCacheNodes = [];
      __searchWordFreq = new Map();
      __searchWordBuckets = Object.create(null);

      const nodes = state && state.nodes ? Object.values(state.nodes) : [];
      for (const node of nodes) {
        if (!node || !node.id) continue;

        const rawText = buildNodeRawText(node);
        const textNorm = normalizeTextForSearch(rawText);
        if (!textNorm) continue;

        const tokens = tokenizeForSearch(rawText); // уже нормализованные слова
        const tokenSet = new Set(tokens);
        const tokenStems = tokens.map(w => ruStem(w));

        const entry = {
          nodeId: node.id,
          type: node.type,
          title: node.name || '(без названия)',
          path: buildPathForNode(node),
          rawText,
          textNorm,
          tokens,
          tokenSet,
          tokenStems,
          nameNorm: normalizeTextForSearch(node.name || '')
        };
        __searchCacheNodes.push(entry);

        for (const w of tokens) {
          if (!w) continue;
          // для словаря: убираем слишком короткое и стоп-слова
          if (!isNumericQueryToken(w) && w.length < 3) continue;
          if (__searchStopWords.has(w)) continue;

          __searchWordFreq.set(w, (__searchWordFreq.get(w) || 0) + 1);
        }
      }

      // бакеты по 2 первым буквам (ускоряет автодополнение)
      for (const [w, f] of __searchWordFreq.entries()) {
        const key = (w || '').slice(0, 2);
        if (!key) continue;
        if (!__searchWordBuckets[key]) __searchWordBuckets[key] = [];
        __searchWordBuckets[key].push(w);
      }

      Object.keys(__searchWordBuckets).forEach(k => {
        __searchWordBuckets[k].sort((a, b) => {
          const fa = __searchWordFreq.get(a) || 0;
          const fb = __searchWordFreq.get(b) || 0;
          if (fa !== fb) return fb - fa;
          if (a.length !== b.length) return a.length - b.length;
          return a.localeCompare(b);
        });
      });

      __searchCacheRev = __stateRevision;
    }

    function ensureSearchCache() {
      if (__searchCacheRev !== __stateRevision) rebuildSearchCache();
    }

    function pickBestTokenForNeedle(needle, tokens) {
      const t = normalizeTextForSearch(needle);
      if (!t) return '';
      let best = '';
      let bestScore = -1;

      const tStem = ruStem(t);

      for (const w of (tokens || [])) {
        if (!w) continue;
        if (!w.includes(t)) continue;

        let s = 0;
        if (w === t) s += 400;
        if (w.startsWith(t)) s += 250;
        // ближе по длине => выше
        s += Math.max(0, 120 - Math.abs(w.length - t.length) * 8);

        const wStem = ruStem(w);
        if (wStem === tStem && wStem.length >= 3) s += 160;
        else if (wStem.startsWith(tStem) && tStem.length >= 3) s += 90;

        if (s > bestScore) {
          bestScore = s;
          best = w;
        }
      }

      return best;
    }

    function scoreTermMatch(tt, textNorm, tokens, tokenSet, tokenStems, nameNorm) {
      const t = normalizeTextForSearch(tt);
      if (!t) return { level: 0, score: 0 };

      // числа: только точное
      if (isNumericQueryToken(t)) {
        if (textNorm.includes(t)) return { level: 3, score: 260 };
        return { level: 0, score: 0 };
      }

      const tStem = ruStem(t);
      let bestLevel = 0;
      let bestScore = 0;

      // 1) точное слово
      if (tokenSet && tokenSet.has(t)) {
        bestLevel = 3;
        bestScore = 220 + t.length * 8;
      }

      // 2) префикс / подстрока
      if (bestLevel < 2) {
        let prefixHit = false;
        let containsHit = false;

        for (const w of tokens) {
          if (!w) continue;
          if (!prefixHit && w.startsWith(t)) prefixHit = true;
          if (!containsHit && t.length >= 3 && w.includes(t)) containsHit = true;
          if (prefixHit && containsHit) break;
        }

        if (prefixHit) {
          bestLevel = 2;
          bestScore = 170 + t.length * 6;
        } else if (containsHit) {
          bestLevel = 2;
          bestScore = 145 + t.length * 5;
        }
      }

      // 3) совпадение/близость стемов
      if (bestLevel < 2 && tStem.length >= 3) {
        for (let i = 0; i < tokenStems.length; i++) {
          const wStem = tokenStems[i];
          if (!wStem) continue;
          if (wStem === tStem) {
            bestLevel = 2;
            bestScore = Math.max(bestScore, 135 + tStem.length * 6);
            break;
          }
        }
      }

      if (bestLevel < 2 && tStem.length >= 3) {
        for (let i = 0; i < tokenStems.length; i++) {
          const wStem = tokenStems[i];
          if (!wStem) continue;
          if (wStem.startsWith(tStem) || tStem.startsWith(wStem)) {
            if (Math.min(wStem.length, tStem.length) >= 3) {
              bestLevel = 2;
              bestScore = Math.max(bestScore, 120 + Math.min(wStem.length, tStem.length) * 6);
              break;
            }
          }
        }
      }

      // 4) "умная" похожесть (левенштейн / триграммы)
      if (bestLevel < 1) {
        const tLen = t.length;
        const maxDist = tLen <= 6 ? 1 : (tLen <= 10 ? 2 : 0);
        const tTri = trigrams(tStem);

        let bestFuzzy = 0;

        for (let i = 0; i < tokenStems.length; i++) {
          const w = tokens[i];
          const wStem = tokenStems[i];
          if (!w || !wStem) continue;
          if (isNumericQueryToken(w)) continue;

          // быстрые совпадения по префиксу стема
          if ((wStem.startsWith(tStem) || tStem.startsWith(wStem)) && Math.min(wStem.length, tStem.length) >= 3) {
            bestFuzzy = Math.max(bestFuzzy, 95);
            continue;
          }

          if (maxDist) {
            const d = levenshtein(wStem, tStem, maxDist);
            if (d <= maxDist) {
              bestFuzzy = Math.max(bestFuzzy, 85 - d * 18);
              continue;
            }
          }

          const sim = jaccard(tTri, trigrams(wStem));
          if (sim >= 0.45 && Math.min(wStem.length, tStem.length) >= 4) {
            bestFuzzy = Math.max(bestFuzzy, 65 + sim * 40);
          }
        }

        if (bestFuzzy > 0) {
          bestLevel = 1;
          bestScore = bestFuzzy;
        }
      }

      // бонус за попадание в заголовок
      if (nameNorm && nameNorm.includes(t)) {
        if (bestLevel < 2) bestLevel = 2;
        bestScore += 90;
      }

      // небольшой бонус за длину (чуть стабилизирует ранжирование)
      bestScore += Math.min(40, t.length * 3);

      return { level: bestLevel, score: bestScore };
    }

    function scoreWordSuggestion(qTok, qStem, wTok, freq) {
      const w = normalizeTextForSearch(wTok);
      if (!w) return -1;
      if (__searchStopWords.has(w)) return -1;

      const wStem = ruStem(w);
      const lcp = __commonPrefixLen(qTok, w);
      const lcpStem = __commonPrefixLen(qStem, wStem);

      let s = 0;

      if (w === qTok) s += 4000;

      if (w.startsWith(qTok)) {
        s += 2600 + lcp * 20;
        // чуть штрафуем за слишком длинные хвосты
        s -= Math.max(0, (w.length - qTok.length)) * 8;
      } else if (wStem.startsWith(qStem) && qStem.length >= 3) {
        s += 2200 + lcpStem * 16;
      } else if (qTok.length >= 3 && w.includes(qTok)) {
        s += 1400;
      }

      const maxDist = qTok.length <= 6 ? 1 : (qTok.length <= 10 ? 2 : 0);
      if (maxDist) {
        const d = levenshtein(wStem, qStem, maxDist);
        if (d <= maxDist) s += 1000 - d * 220;
      }

      const sim = jaccard(trigrams(wStem), trigrams(qStem));
      if (sim >= 0.45 && Math.min(wStem.length, qStem.length) >= 4) {
        s += 500 + sim * 300;
      }

      const f = freq || 1;
      s += Math.log(1 + f) * 220;

      return s;
    }

    
    function getWordSuggestions(prefix, limit) {
      ensureSearchCache();
      limit = limit || 8;

      const q = normalizeTextForSearch(prefix);
      const qTok = (tokenizeForSearch(q)[0] || '');
      if (!qTok || qTok.length < 2) return [];
      if (isNumericQueryToken(qTok)) return [];

      const qStem = ruStem(qTok);
      const key = qTok.slice(0, 2);

      // пул кандидатов: сначала бакет, потом fallback на весь словарь (если бакет пуст)
      let pool = (__searchWordBuckets[key] || []);
      if (!pool.length) pool = Array.from(__searchWordFreq.keys());

      const scored = [];
      const seen = new Set();

      // ограничим пул, чтобы не тормозило на больших базах
      const maxScan = Math.min(pool.length, 2000);

      function commonPrefixLen(a, b){
        const n = Math.min(a.length, b.length);
        let i = 0;
        for (; i < n; i++){
          if (a[i] !== b[i]) break;
        }
        return i;
      }

      for (let i = 0; i < maxScan; i++) {
        const wTok = pool[i];
        if (!wTok || seen.has(wTok)) continue;
        seen.add(wTok);

        const wStem = ruStem(wTok);

        const tokPref = (wTok.startsWith(qTok) || qTok.startsWith(wTok));
        const stemPref = (qStem.length >= 3 && (wStem.startsWith(qStem) || qStem.startsWith(wStem)));
        const lcp = commonPrefixLen(wTok, qTok);

        // быстрый фильтр: по умолчанию держим только близкие по смыслу/форме варианты
        if (!tokPref && !stemPref) {
          // для русских слов: если общая приставка меньше 3 букв — слишком много мусора ("да..." для "даты")
          const need = qTok.length >= 4 ? 3 : 2;
          if (lcp < need) continue;

          // опечатки: разрешим небольшую ошибку, но только если общая приставка нормальная
          const maxDist = qTok.length <= 6 ? 1 : (qTok.length <= 10 ? 2 : 0);
          if (maxDist) {
            const d = levenshtein(wTok, qTok, maxDist);
            if (d > maxDist) continue;
          } else {
            continue;
          }
        }

        const s = scoreWordSuggestion(qTok, qStem, wTok, __searchWordFreq.get(wTok) || 1);
        if (s <= 0) continue;

        // жестко поднимаем "однокоренные" варианты
        const boost = (wStem === qStem) ? 2200 : (stemPref ? 900 : 0);
        scored.push({ w: wTok, s: s + boost });
      }

      scored.sort((a, b) => {
        if (a.s !== b.s) return b.s - a.s;
        // короче слово — обычно "основная форма"
        if (a.w.length !== b.w.length) return a.w.length - b.w.length;
        return a.w.localeCompare(b.w);
      });

      return scored.slice(0, limit).map(x => x.w);
    }



    function collectMatchInfo(terms, rawText, textNorm, tokens) {
      // Возвращаем: что нашли (точно/похоже), какое слово в тексте зацепило, и небольшой контекст
      const out = {
        foundWord: '',
        foundTerm: '',
        matchKind: 'fuzzy', // 'exact' | 'fuzzy'
        snippet: ''
      };

      if (!rawText) return out;

      // 1) "точное" вхождение как подстроки (быстро),
      // но foundWord стараемся вернуть ПОЛНЫМ словом из текста (а не тем, что набрали).
      for (const t0 of terms) {
        const t = normalizeTextForSearch(t0);
        if (!t) continue;

        // числа — только точное
        if (isNumericQueryToken(t)) {
          if (textNorm.includes(t)) {
            out.foundTerm = t0;
            out.foundWord = t;
            out.matchKind = 'exact';
            break;
          }
          continue;
        }

        if (textNorm.includes(t)) {
          out.foundTerm = t0;
          const best = pickBestTokenForNeedle(t, tokens);
          out.foundWord = best || t;
          out.matchKind = 'exact';
          break;
        }
      }

      // 2) Если точного нет — выбираем "самое похожее" слово из токенов
      if (!out.foundTerm) {
        outer: for (const t0 of terms) {
          const t = normalizeTextForSearch(t0);
          if (!t) continue;
          if (isNumericQueryToken(t)) continue;

          const tStem = ruStem(t);
          const tTri = trigrams(tStem);
          const tLen = t.length;

          let best = null;
          let bestScore = -1;

          for (const w of tokens) {
            const wNorm = normalizeTextForSearch(w);
            if (!wNorm) continue;
            if (isNumericQueryToken(wNorm)) continue;

            // чем ближе по "форме" — тем выше
            if (wNorm === t) {
              const s = 130 + wNorm.length;
              if (s > bestScore) { bestScore = s; best = wNorm; }
              continue;
            }
            if ((wNorm.startsWith(t) || t.startsWith(wNorm)) && Math.min(wNorm.length, tLen) >= 3) {
              // важный кейс: "помес" => "поместье"
              const s = 120 + __commonPrefixLen(wNorm, t) * 10 + Math.min(wNorm.length, 18);
              if (s > bestScore) { bestScore = s; best = wNorm; }
              continue;
            }

            const wStem = ruStem(wNorm);

            if (wStem === tStem && wStem.length >= 3) {
              const s = 105 + wStem.length * 3;
              if (s > bestScore) { bestScore = s; best = wNorm; }
              continue;
            }

            const maxDist = tLen <= 6 ? 1 : (tLen <= 10 ? 2 : 0);
            if (maxDist) {
              const d = levenshtein(wStem, tStem, maxDist);
              if (d <= maxDist) {
                const s = 75 - d * 12;
                if (s > bestScore) { bestScore = s; best = wNorm; }
                continue;
              }
            }

            const sim = jaccard(tTri, trigrams(wStem));
            if (sim >= 0.45 && Math.min(wStem.length, tStem.length) >= 4) {
              const s = 60 + sim * 40;
              if (s > bestScore) { bestScore = s; best = wNorm; }
              continue;
            }
          }

          if (best) {
            out.foundTerm = t0;
            out.foundWord = best;
            out.matchKind = 'fuzzy';
            break outer;
          }
        }
      }

      // 3) Сниппет вокруг foundWord (если есть)
      const baseNeedle = out.foundWord || out.foundTerm;
      if (baseNeedle) {
        const needle = (baseNeedle || '').toString().trim();
        if (needle) {
          // e/ё вариант в regex
          const n = normalizeTextForSearch(needle).replace(/е/g, '[её]');
          const re = new RegExp(n, 'i');
          const mm = rawText.match(re);
          if (mm && typeof mm.index === 'number') {
            const i = mm.index;
            const left = Math.max(0, i - 42);
            const right = Math.min(rawText.length, i + needle.length + 56);
            let snippet = rawText.slice(left, right);
            if (left > 0) snippet = '…' + snippet;
            if (right < rawText.length) snippet = snippet + '…';
            out.snippet = snippet;
          } else {
            // fallback: просто первые N символов
            out.snippet = (rawText || '').slice(0, 140);
            if ((rawText || '').length > 140) out.snippet += '…';
          }
        }
      }

      return out;
    }

    function runGlobalSearch(query) {
      const normQ = normalizeTextForSearch(query);
      if (!normQ) return [];

      // разбиваем на слова, убираем слишком короткие
      const terms = tokenizeForSearch(normQ).filter(t => t.length >= 2);
      if (!terms.length) return [];

      ensureSearchCache();

      // 0) "умные слова" (автодополнение): сверху отдельным блоком
      const out = [];
      if (terms.length === 1 && terms[0] && !isNumericQueryToken(terms[0])) {
        const sug = getWordSuggestions(terms[0], 8);
        sug.forEach((w, idx) => {
          out.push({
            kind: 'suggestion',
            type: 'suggestion',
            title: w,
            value: w,
            path: '',
            score: 1000000 - idx,
            snippet: 'Подставить в поиск'
          });
        });
      }

      const results = [];

      for (const node of __searchCacheNodes) {
        const textNorm = node.textNorm;
        if (!textNorm) continue;

        let ok = true;
        let score = 0;
        const levels = [];

        for (const t0 of terms) {
          const tt = normalizeTextForSearch(t0);
          if (!tt) { ok = false; break; }

          const si = scoreTermMatch(
            tt,
            textNorm,
            node.tokens,
            node.tokenSet,
            node.tokenStems,
            node.nameNorm
          );

          if (!si || !si.level) { ok = false; break; }

          levels.push(si.level);
          score += si.score;
        }

        if (!ok) continue;

        const allExact = levels.every(l => l >= 3);
        const allPrefix = levels.every(l => l >= 2);

        // бонус за тип: паттерн чаще интереснее по содержимому
        if (node.type === 'characteristic') score += 18;

        const mi = collectMatchInfo(terms, node.rawText, textNorm, node.tokens);

        results.push({
          nodeId: node.nodeId,
          type: node.type,
          title: node.title,
          path: node.path,
          score,
          allExact,
          allPrefix,
          foundWord: mi.foundWord,
          foundTerm: mi.foundTerm,
          matchKind: mi.matchKind,
          snippet: mi.snippet
        });
      }

      results.sort((a, b) => {
        if (a.allExact !== b.allExact) return a.allExact ? -1 : 1;
        if (a.allPrefix !== b.allPrefix) return a.allPrefix ? -1 : 1;
        if (a.matchKind !== b.matchKind) return a.matchKind === 'exact' ? -1 : 1;
        // если нашли слово — префиксное совпадение выше
        const aq = normalizeTextForSearch(terms[0] || '');
        const aw = normalizeTextForSearch(a.foundWord || '');
        const bw = normalizeTextForSearch(b.foundWord || '');
        const aPref = aq && aw && aw.startsWith(aq);
        const bPref = aq && bw && bw.startsWith(aq);
        if (aPref !== bPref) return aPref ? -1 : 1;
        return b.score - a.score;
      });

      const nodeTop = results.slice(0, 30);

      return out.concat(nodeTop);
    }

    
    // flat list for keyboard navigation (data-gs-index on items)
    let __globalSearchDisplayFlat = [];
    let __globalSearchActiveIndex = -1;

    function __escapeHtml(s){
      return (s || '').toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function __highlightInline(text, query){
      const t = (text || '').toString();
      const q = (query || '').toString().trim();
      if (!t || !q) return __escapeHtml(t);

      // match with e/ё equivalence
      const esc = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const pattern = esc.replace(/е/ig, '[её]').replace(/Е/g, '[ЕЁ]');
      const re = new RegExp(pattern, 'ig');
      const safe = __escapeHtml(t);

      // try to highlight at least once (best effort)
      try{
        // we need to run regex on original, but replace in safe is hard.
        // quick approach: if direct substring exists, highlight by index.
        const lowT = t.toLowerCase().replace(/ё/g,'е');
        const lowQ = q.toLowerCase().replace(/ё/g,'е');
        const idx = lowT.indexOf(lowQ);
        if (idx >= 0) {
          const a = __escapeHtml(t.slice(0, idx));
          const b = __escapeHtml(t.slice(idx, idx + q.length));
          const c = __escapeHtml(t.slice(idx + q.length));
          return a + '<mark class="search-highlight">' + b + '</mark>' + c;
        }
      }catch(e){}

      // fallback: no highlight
      return safe;
    }

    // Для паттернов типа "годы" — пытаемся показать конкретную дату/период прямо в быстрых результатах поиска.
    function __pickBestYearsLabelForSearch(node, queryText, item){
      if(!node) return '';
      const type = (node.factType || 'assertion');
      if(type !== 'years') return '';
      const cards = node.cards || [];
      if(!cards.length) return '';

      const q = (queryText || '').toString();
      const terms = tokenizeForSearch(q).filter(t => (t || '').length >= 2);

      const fw = normalizeTextForSearch(item && item.foundWord ? item.foundWord : '');
      const digits = q.match(/\d{1,4}/g) || [];

      let bestCard = null;
      let bestScore = -1;

      cards.forEach(c => {
        if(!c) return;
        const label = formatYears(c);
        if(!label) return;

        const hay = normalizeTextForSearch(
          ((c.person || '') + ' ' + (c.event || '') + ' ' + label + ' ' + (c.timeRaw || '') + ' ' + (c.timeExact || '') + ' ' + (c.era || ''))
        );

        let score = 0;

        // совпадения по словам запроса
        for(const term of terms){
          if(!term) continue;
          if(hay.includes(term)) score += 2;

          const st = ruStem(term);
          if(st && st.length >= 3){
            const toks = tokenizeForSearch(hay);
            for(const tk of toks){
              if(ruStem(tk) === st){ score += 1; break; }
            }
          }
        }

        // бонус, если совпало именно то, что подсветили как найденное слово
        if(fw && hay.includes(fw)) score += 4;

        // бонус за цифры (если пользователь прямо ищет год/дату)
        digits.forEach(d => {
          if((c.timeRaw || '').includes(d) || (c.timeExact || '').includes(d)) score += 3;
        });

        if(score > bestScore){
          bestScore = score;
          bestCard = c;
        }
      });

      if(bestCard) return formatYears(bestCard);
      const fallback = cards.find(c => c && formatYears(c));
      return fallback ? formatYears(fallback) : '';
    }


    function __commonPrefixLen(a, b){
      a = (a || '').toString();
      b = (b || '').toString();
      const n = Math.min(a.length, b.length);
      let i = 0;
      for (; i < n; i++){
        if (a[i] !== b[i]) break;
      }
      return i;
    }

    function setGlobalSearchActiveIndex(i){
      if (!globalSearchResultsEl) return;
      const n = __globalSearchDisplayFlat.length;
      if (!n) { __globalSearchActiveIndex = -1; return; }
      const next = Math.max(0, Math.min(n - 1, i));
      __globalSearchActiveIndex = next;

      globalSearchResultsEl.querySelectorAll('[data-gs-index]').forEach(el => {
        el.classList.toggle('active', Number(el.dataset.gsIndex) === next);
      });

      const active = globalSearchResultsEl.querySelector('[data-gs-index="' + next + '"]');
      if (active) {
        // keep active item visible inside the dropdown
        const c = globalSearchResultsEl.getBoundingClientRect();
        const r = active.getBoundingClientRect();
        if (r.bottom > c.bottom) active.scrollIntoView({ block: 'nearest' });
        if (r.top < c.top) active.scrollIntoView({ block: 'nearest' });
      }
    }

    function __applyGlobalSearchItem(item){
      if (!item) return;
      const isSug = item && (item.kind === 'suggestion' || item.type === 'suggestion');

      if (isSug) {
        if (!globalSearchInputEl) return;
        globalSearchInputEl.value = item.value || item.title || '';
        refreshGlobalSearch({ forceShow: true });
        globalSearchInputEl.focus();
        return;
      }

      const node = getNode(item.nodeId);
      if (!node) return;

      currentNodeId = node.id;
      if (node.type === 'category') {
        sidebarViewNodeId = node.id;
      } else if (node.parentId) {
        sidebarViewNodeId = node.parentId;
      }
      // подсветим найденное в деталях, но НЕ будем дергать экран при наборе текста
      const q = (globalSearchInputEl && globalSearchInputEl.value) ? globalSearchInputEl.value : '';
      __activeSearchHighlight = (q || '').trim();

      render();
      applyActiveSearchHighlight(true);
      if (globalSearchResultsEl) globalSearchResultsEl.style.display = 'none';
    }

    function renderGlobalSearchResults(list) {
      if (!globalSearchResultsEl) return;
      globalSearchResultsEl.innerHTML = '';
      __globalSearchDisplayFlat = [];
      __globalSearchActiveIndex = -1;

      const q = (globalSearchInputEl && globalSearchInputEl.value) ? globalSearchInputEl.value.trim() : '';

      if (!list || !list.length) {
        globalSearchResultsEl.style.display = 'none';
        return;
      }

      const suggestions = [];
      const results = [];

      list.forEach(item => {
        const isSug = item && (item.kind === 'suggestion' || item.type === 'suggestion');
        if (isSug) suggestions.push(item);
        else results.push(item);
      });

      let flatIndex = 0;
      let secResultsEl = null;
      let secSugEl = null;

      // Results first (main value)
      if (results.length) {
        const sec = document.createElement('div');
        sec.className = 'search-section search-section-results';

        const head = document.createElement('div');
        head.className = 'search-section-header';
        head.innerHTML =
          '<div class="search-section-title">РЕЗУЛЬТАТЫ <span class="search-section-count">(' + results.length + ')</span></div>' +
          '<div class="search-section-hints"><span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">Enter</span></div>';

        const body = document.createElement('div');
        body.className = 'search-res-body';

        results.forEach(item => {
          const row = document.createElement('div');
          row.className = 'search-item';
          row.setAttribute('role', 'option');
          row.dataset.gsIndex = String(flatIndex);

          const badge = document.createElement('div');
          badge.className = 'search-badge';

          const typeLabel =
            (item.type === 'category'
              ? 'ОТСЕК'
              : item.type === 'characteristic'
                ? 'ПАТТЕРН'
                : 'ЭЛЕМ');

          badge.textContent = typeLabel;

          const main = document.createElement('div');
          main.className = 'search-item-main';

          const title = document.createElement('div');
          title.className = 'search-item-title';

          const baseTitle = (item.title || '(без названия)').trim();

          // если это паттерн "годы", покажем конкретную дату/период прямо тут
          let yearsLabel = '';
          if (item.type === 'characteristic' && item.nodeId) {
            const n = getNode(item.nodeId);
            if (n && (n.factType || 'assertion') === 'years') {
              yearsLabel = __pickBestYearsLabelForSearch(n, q, item);
            }
          }

          if (yearsLabel) {
            title.innerHTML =
              '<span class="search-item-title-main">' + __escapeHtml(baseTitle) + '</span>' +
              '<span class="search-item-year">— ' + __escapeHtml(yearsLabel) + '</span>';
          } else {
            title.textContent = baseTitle;
          }
const sub = document.createElement('div');
          sub.className = 'search-item-sub';

          const found =
            (item.foundWord
              ? ('нашли: ' + item.foundWord + (item.matchKind === 'exact' ? ' (точно)' : ' (похоже)'))
              : ('нашли: ' + (item.foundTerm || '').trim()));

          const subText = (found + (item.snippet ? (' · ' + item.snippet) : '')).trim();
          sub.innerHTML = __highlightInline(subText, q);

          const path = document.createElement('div');
          path.className = 'search-item-path';
          path.textContent = (item.path || '').trim();

          main.appendChild(title);
          main.appendChild(sub);
          if (item.path) main.appendChild(path);

          row.appendChild(badge);
          row.appendChild(main);

          row.title = item.path || '';

          row.addEventListener('mouseenter', () => setGlobalSearchActiveIndex(Number(row.dataset.gsIndex)));

          row.addEventListener('click', () => {
            __applyGlobalSearchItem(item);
          });

          body.appendChild(row);
          __globalSearchDisplayFlat.push(item);
          flatIndex++;
        });

        sec.appendChild(head);
        sec.appendChild(body);
        secResultsEl = sec;
      }

      // Suggestions as chips (secondary)
      if (suggestions.length) {
        const sec = document.createElement('div');
        sec.className = 'search-section search-section-suggestions';

        const head = document.createElement('div');
        head.className = 'search-section-header';
        head.innerHTML =
          '<div class="search-section-title">Т9 / АВТОДОПОЛНЕНИЕ <span class="search-section-count">(' + suggestions.length + ')</span></div>' +
          '<div class="search-section-hints"><span class="kbd">Tab</span><span>вставить</span></div>';

        const body = document.createElement('div');
        body.className = 'search-sug-body';

        const chips = document.createElement('div');
        chips.className = 'search-sug-chips';

        suggestions.forEach(item => {
          const chip = document.createElement('button');
          chip.type = 'button';
          chip.className = 'search-sug-chip';
          chip.dataset.gsIndex = String(flatIndex);
          chip.title = 'Клик — вставить слово в поиск';

          const word = (item.title || item.value || '').toString().trim();
          const lowQ = (q || '').toLowerCase();
          const lowW = word.toLowerCase();
          let htmlWord = __escapeHtml(word);

          if (q && lowW.startsWith(lowQ)) {
            const pref = word.slice(0, q.length);
            const rest = word.slice(q.length);
            htmlWord = '<span class="chip-hl">' + __escapeHtml(pref) + '</span>' + __escapeHtml(rest);
          } else if (q && lowW.includes(lowQ)) {
            const idx = lowW.indexOf(lowQ);
            const a = word.slice(0, idx);
            const b = word.slice(idx, idx + q.length);
            const c = word.slice(idx + q.length);
            htmlWord = __escapeHtml(a) + '<span class="chip-hl">' + __escapeHtml(b) + '</span>' + __escapeHtml(c);
          }

          chip.innerHTML = htmlWord + ' <span class="chip-action">↩</span>';

          chip.addEventListener('mouseenter', () => setGlobalSearchActiveIndex(Number(chip.dataset.gsIndex)));

          chip.addEventListener('click', () => {
            __applyGlobalSearchItem(item);
          });

          chips.appendChild(chip);

          __globalSearchDisplayFlat.push(item);
          flatIndex++;
        });

        body.appendChild(chips);
        sec.appendChild(head);
        sec.appendChild(body);
        secSugEl = sec;
      }

      // визуально: сначала Т9/автодополнение, потом результаты
      if (secSugEl) globalSearchResultsEl.appendChild(secSugEl);
      if (secResultsEl) globalSearchResultsEl.appendChild(secResultsEl);

      globalSearchResultsEl.style.display = 'block';

      // default active: first result if exists, else first suggestion
      if (__globalSearchDisplayFlat.length) {
        setGlobalSearchActiveIndex(0);
      }
    }


    let __globalSearchLastQuery = '';
    let __globalSearchLastResults = [];
    let __globalSearchDebounce = null;

    function refreshGlobalSearch({ forceShow = false } = {}) {
      if (!globalSearchInputEl) return;
      const q = (globalSearchInputEl.value || '').trim();
      const __clr = document.getElementById('globalSearchClear');
      if (__clr) __clr.style.display = q ? 'flex' : 'none';
      __activeSearchHighlight = q;

      // подсветка в текущем экране — БЕЗ автоскролла, чтобы не дергался экран при наборе
      applyActiveSearchHighlight(false);

      if (!q || q.length < 2) {
        __globalSearchLastQuery = q;
        __globalSearchLastResults = [];
        renderGlobalSearchResults([]);
        return;
      }

      // если просто фокус — покажем прежний список, не пересчитывая
      if (!forceShow && __globalSearchLastQuery === q && __globalSearchLastResults.length) {
        renderGlobalSearchResults(__globalSearchLastResults);
        return;
      }

      const results = runGlobalSearch(q);
      __globalSearchLastQuery = q;
      __globalSearchLastResults = results;
      renderGlobalSearchResults(results);
    }

    if (globalSearchInputEl) {
      globalSearchInputEl.addEventListener('input', () => {
        if (__globalSearchDebounce) clearTimeout(__globalSearchDebounce);
        __globalSearchDebounce = setTimeout(() => refreshGlobalSearch({ forceShow: true }), 80);
      });

      // ВАЖНО: на фокус/клик показываем результаты по текущему тексту,
      // даже если пользователь ничего не вводит повторно
      globalSearchInputEl.addEventListener('focus', () => {
        refreshGlobalSearch({ forceShow: true });
      });
      globalSearchInputEl.addEventListener('click', () => {
        refreshGlobalSearch({ forceShow: true });
      });

      globalSearchInputEl.addEventListener('keydown', (e) => {
        const listVisible = globalSearchResultsEl && globalSearchResultsEl.style.display !== 'none' && __globalSearchDisplayFlat && __globalSearchDisplayFlat.length;

        if (e.key === 'Escape') {
          e.preventDefault();
          globalSearchInputEl.value = '';
          renderGlobalSearchResults([]);
          __activeSearchHighlight = '';
          applyActiveSearchHighlight(false);
          const clr = document.getElementById('globalSearchClear');
          if (clr) clr.style.display = 'none';
          return;
        }

        if (listVisible && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
          e.preventDefault();
          const n = __globalSearchDisplayFlat.length;
          if (!n) return;
          let idx = (__globalSearchActiveIndex >= 0 ? __globalSearchActiveIndex : 0);
          idx = e.key === 'ArrowDown' ? Math.min(n - 1, idx + 1) : Math.max(0, idx - 1);
          setGlobalSearchActiveIndex(idx);
          return;
        }

        if (e.key === 'Tab' && listVisible) {
          // Tab: вставить, если выбран автодополнительный вариант
          const idx = (__globalSearchActiveIndex >= 0 ? __globalSearchActiveIndex : 0);
          const item = __globalSearchDisplayFlat[idx];
          if (item && (item.kind === 'suggestion' || item.type === 'suggestion')) {
            e.preventDefault();
            __applyGlobalSearchItem(item);
          }
          return;
        }

        if (e.key === 'Enter') {
          if (listVisible) {
            e.preventDefault();
            const idx = (__globalSearchActiveIndex >= 0 ? __globalSearchActiveIndex : 0);
            const item = __globalSearchDisplayFlat[idx] || __globalSearchDisplayFlat[0];
            __applyGlobalSearchItem(item);
          }
          return;
        }
      });
    

      const globalSearchClearEl = document.getElementById('globalSearchClear');
      if (globalSearchClearEl) {
        globalSearchClearEl.addEventListener('click', () => {
          globalSearchInputEl.value = '';
          globalSearchInputEl.focus();
          renderGlobalSearchResults([]);
          __activeSearchHighlight = '';
          applyActiveSearchHighlight(false);
          globalSearchClearEl.style.display = 'none';
        });
      }

      // клик вне поисковика — просто скрыть дропдаун
      document.addEventListener('click', (ev) => {
        const t = ev.target;
        if (t && t.closest && t.closest('.topbar-search')) return;
        if (globalSearchResultsEl) globalSearchResultsEl.style.display = 'none';
      });
}

    document.addEventListener('click', (e) => {
      if (!globalSearchResultsEl || !globalSearchInputEl) return;
      if (
        e.target === globalSearchInputEl ||
        globalSearchResultsEl.contains(e.target)
      ) {
        return;
      }
      globalSearchResultsEl.style.display = 'none';
    });


    // ===== ПОДСВЕТКА НАЙДЕННОГО ТЕКСТА (как Ctrl+F) =====
    let __activeSearchHighlight = '';

    function escapeRegExp(str) {
      return (str || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function buildHighlightRegex(terms) {
      const parts = (terms || [])
        .map(t => normalizeTextForSearch(t))
        .filter(Boolean)
        .map(t => escapeRegExp(t).replace(/ё/g, '[её]').replace(/е/g, '[её]'));

      if (!parts.length) return null;
      return new RegExp('(' + parts.join('|') + ')', 'gi');
    }

    function clearSearchHighlights(rootEl) {
      const root = rootEl || document;
      const marks = root.querySelectorAll('mark.search-highlight');
      marks.forEach(m => {
        const parent = m.parentNode;
        if (!parent) return;
        parent.replaceChild(document.createTextNode(m.textContent || ''), m);
        parent.normalize();
      });
    }

    function highlightInElement(rootEl, query, opts) {
      const root = rootEl;
      opts = opts || {};
      const shouldScroll = !!opts.scroll;
      if (!root) return;

      clearSearchHighlights(root);

      const q = (query || '').trim();
      if (!q || q.length < 2) return;

      const terms = tokenizeForSearch(q).filter(t => t.length >= 2);
      if (!terms.length) return;

      function fuzzyWordMatch(term, word) {
        const t = normalizeTextForSearch(term);
        const w = normalizeTextForSearch(word);
        if (!t || !w) return false;

        // точное / частичное
        if (w === t) return true;
        if ((w.includes(t) || t.includes(w)) && Math.min(w.length, t.length) >= 3) return true;

        const tStem = ruStem(t);
        const wStem = ruStem(w);

        // совпадение стемов
        if (tStem === wStem && tStem.length >= 3) return true;

        // Левенштейн для коротких слов
        const maxDist = t.length <= 6 ? 1 : (t.length <= 10 ? 2 : 0);
        if (maxDist) {
          const d = levenshtein(wStem, tStem, maxDist);
          if (d <= maxDist) return true;
        }

        // триграммы для чуть более сложных случаев
        const sim = jaccard(trigrams(tStem), trigrams(wStem));
        if (sim >= 0.45 && Math.min(wStem.length, tStem.length) >= 4) return true;

        return false;
      }

      const wordRe = /[A-Za-zА-Яа-яЁёЭэ0-9]+/g;

      const walker = document.createTreeWalker(
        root,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: function (node) {
            if (!node || !node.nodeValue) return NodeFilter.FILTER_REJECT;
            const parent = node.parentNode;
            if (!parent) return NodeFilter.FILTER_REJECT;
            const tag = (parent.tagName || '').toLowerCase();
            if (tag === 'script' || tag === 'style' || tag === 'mark') return NodeFilter.FILTER_REJECT;
            if (tag === 'input' || tag === 'textarea') return NodeFilter.FILTER_REJECT;
            if (parent.closest && parent.closest('mark.search-highlight')) return NodeFilter.FILTER_REJECT;

            const raw = node.nodeValue;
            if (!raw || !raw.trim()) return NodeFilter.FILTER_REJECT;

            const norm = normalizeTextForSearch(raw);
            const tokens = tokenizeForSearch(norm);
            // Если хотя бы один термин приблизительно встречается в этой строке — обрабатываем её.
            const ok = terms.some(t => fuzzyTermInText(t, norm, tokens));
            return ok ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
          }
        },
        false
      );

      const textNodes = [];
      let n;
      while ((n = walker.nextNode())) textNodes.push(n);

      textNodes.forEach(node => {
        const txt = node.nodeValue;
        if (!txt) return;

        wordRe.lastIndex = 0;
        let m;
        let lastIdx = 0;
        let changed = false;
        const frag = document.createDocumentFragment();

        while ((m = wordRe.exec(txt))) {
          const idx = m.index;
          const word = m[0];

          if (idx > lastIdx) frag.appendChild(document.createTextNode(txt.slice(lastIdx, idx)));

          const shouldMark = terms.some(t => fuzzyWordMatch(t, word));
          if (shouldMark) {
            changed = true;
            const mark = document.createElement('mark');
            mark.className = 'search-highlight';
            mark.textContent = word;
            frag.appendChild(mark);
          } else {
            frag.appendChild(document.createTextNode(word));
          }

          lastIdx = idx + word.length;
        }

        if (!changed) return; // ничего не подсветили

        if (lastIdx < txt.length) frag.appendChild(document.createTextNode(txt.slice(lastIdx)));

        if (node.parentNode) node.parentNode.replaceChild(frag, node);
      });

      if (shouldScroll) {
        const first = root.querySelector('mark.search-highlight');
        if (first && first.scrollIntoView) {
          try {
            first.scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'smooth' });
          } catch (e) {
            first.scrollIntoView(true);
          }
        }
      }
    }

    function applyActiveSearchHighlight(shouldScroll) {
      // подсвечиваем только в правой панели (детали), чтобы не ломать иерархию
      highlightInElement(detailsRootEl, __activeSearchHighlight, { scroll: !!shouldScroll });
    }

// ===== MAIN RENDER =====

    function render() {
      buildBreadcrumb(currentNodeId);
      renderRootbar();
      renderTree();
      renderDetails();
      applyActiveSearchHighlight(false);
    }

    render();
  </script>

  <script>
    // Переключение экранов и микро‑логика обёртки
    (function () {
      const screens = {
        splash: document.getElementById('screen-splash'),
        brain: document.getElementById('screen-brain'),
        roots: document.getElementById('screen-roots'),
        app: document.getElementById('screen-app')
      };

      function showScreen(name) {
        Object.values(screens).forEach(function (el) {
          if (!el) return;
          el.classList.remove('screen-visible');
        });
        if (screens[name]) {
          screens[name].classList.add('screen-visible');
        }
        if (name === 'app') {
          render();
        } else if (name === 'roots') {
          renderRootsScreen();
        }
      }

       // старт сразу в «подготовка к экзаменам»
       showScreen('app');

       const btnGoToApp = document.getElementById('btnGoToApp');
      if (btnGoToApp) {
        btnGoToApp.addEventListener('click', function () {
          showScreen('app');
        });
      }

      const brainTitle = document.getElementById('brainTitle');
      if (brainTitle) {
        brainTitle.addEventListener('click', function () {
          showScreen('app');
        });
      }

      const rootsList = document.getElementById('rootsList');
      if (rootsList) {
        rootsList.addEventListener('click', function (e) {
          const item = e.target.closest('.root-item');
          if (!item) return;
          const id = item.dataset.id;
          if (!id) return;

          const source = item.dataset.source || 'user';

          // Сначала сброс тестов/фактов
          if (source === 'dev') {
            if (!window.__developerState || !window.__developerState.nodes) {
              alert('Корни разработчика ещё не загружены.');
              return;
            }
            // Подгружаем базу разработчика как основную
            state = JSON.parse(JSON.stringify(window.__developerState));
            currentNodeId = id;
            saveState();
          } else {
            currentNodeId = id;
          }

          showScreen('app');
        });
      }

      const backToBrain = document.getElementById('backToBrain');
      if (backToBrain) {
        backToBrain.addEventListener('click', function () {
          showScreen('brain');
        });
      }

      const backToBrainRoots = document.getElementById('backToBrainRoots');
      if (backToBrainRoots) {
        backToBrainRoots.addEventListener('click', function () {
          showScreen('brain');
        });
      }

      const appRoot = document.getElementById('appRoot');

      function setSidebarCollapsed(collapsed) {
        if (!appRoot) return;
        const isCollapsed = appRoot.classList.contains('sidebar-collapsed');
        const next = typeof collapsed === 'boolean' ? collapsed : !isCollapsed;
        if (next === isCollapsed) return;

        if (next) {
          if (typeof window.__sidebarWidthPx === 'undefined') {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
              window.__sidebarWidthPx = sidebar.getBoundingClientRect().width;
            }
          }
          appRoot.dataset.prevGridTemplate = appRoot.style.gridTemplateColumns || '';
          appRoot.style.gridTemplateColumns = '';
          appRoot.classList.add('sidebar-collapsed');
        } else {
          appRoot.classList.remove('sidebar-collapsed');
          const w = window.__sidebarWidthPx;
          if (w && !isNaN(w)) {
            appRoot.style.gridTemplateColumns = `${w}px 6px minmax(0, 1fr)`;
          } else if (appRoot.dataset.prevGridTemplate) {
            appRoot.style.gridTemplateColumns = appRoot.dataset.prevGridTemplate;
          }
        }
        updateSidebarToggleIcons();
      }

      function updateSidebarToggleIcons() {
        const collapsed = appRoot && appRoot.classList.contains('sidebar-collapsed');
        document.querySelectorAll('.js-sidebar-toggle').forEach(btn => {
          if (!btn) return;
          btn.textContent = collapsed ? '▶' : '◀';
          btn.title = collapsed ? 'Развернуть боковую панель' : 'Свернуть боковую панель';
        });
      }

      const sidebarToggles = document.querySelectorAll('.js-sidebar-toggle');
      if (sidebarToggles.length) {
        sidebarToggles.forEach(btn => {
          btn.addEventListener('click', function () {
            setSidebarCollapsed();
          });
        });
        updateSidebarToggleIcons();
      }

      const collapsedGoBrain = document.getElementById('collapsedGoBrain');
      if (collapsedGoBrain) {
        collapsedGoBrain.addEventListener('click', function () {
          // меню удалено — остаёмся в приложении
          showScreen('app');
        });
      }

      const collapsedAddRoot = document.getElementById('collapsedAddRoot');
      if (collapsedAddRoot) {
        collapsedAddRoot.addEventListener('click', function () {
          const btnRootbarAdd = document.getElementById('btnRootbarAdd');
          if (btnRootbarAdd) btnRootbarAdd.click();
          setSidebarCollapsed(false);
        });
      }

      const collapsedSearch = document.getElementById('collapsedSearch');
      if (collapsedSearch) {
        collapsedSearch.addEventListener('click', function () {
          setSidebarCollapsed(false);
          const input = document.getElementById('globalSearchInput');
          if (input) {
            setTimeout(() => input.focus(), 0);
          }
        });
      }

      // Текст про мозг
      const brainIcon = document.getElementById('brainIcon');
      const brainStory = document.getElementById('brainStory');
      const brainStoryClose = document.getElementById('brainStoryClose');

      if (brainIcon && brainStory && brainStoryClose) {
        brainIcon.addEventListener('click', function () {
          brainStory.classList.add('visible');
        });
        brainStoryClose.addEventListener('click', function () {
          brainStory.classList.remove('visible');
        });
      }
    })();
  </script>
<!-- ROOT "+" MODAL (иерархия: создать корень или импортировать базу) -->
<div class="modal-backdrop" id="rootPlusModal">
  <div class="modal-card">
    <div class="modal-header">
      <div class="modal-header-main">
        <div class="modal-title">КОРЕНЬ</div>
        <div class="modal-subtitle">Добавить корневую папку или загрузить базу данных.</div>
      </div>
      <button type="button" class="modal-close" id="rootPlusClose">×</button>
    </div>

    <div class="modal-body">
      <button type="button" class="btn btn-sm btn-primary btn-option" id="rootPlusCreate">Создать корневую папку</button>
      <button type="button" class="btn btn-sm btn-ghost btn-option" id="rootPlusImport">Импортировать базу (JSON)</button>
      <div class="hint" style="margin-top:6px;">Импорт заменит текущие данные в этом браузере.</div>
    </div>

    <div class="modal-footer">
      <button class="btn btn-sm btn-ghost" id="rootPlusCancel">Отмена</button>
    </div>
  </div>
</div>
      </div>
    </section>
  </main>

  <footer class="bottombar bottombar--edge">
    <span class="hint">ты учишься. значит, ты живёшь.</span>
    <span class="sep">•</span>
    <span class="hint">pre-alpha</span>
  </footer>

  <script src="../../assets/js/main.js"></script>
</body>
</html>
