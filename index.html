<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="light" />
  <meta name="theme-color" content="#ffffff" />
  <title>Item Key — Главное меню</title><style>
/* ABSOLUTE KILL OF ANY BACKGROUND CIRCLES / GRADIENTS */
html, body {
  background: #ffffff !important;
  background-image: none !important;
  filter: none !important;
}

body::before,
body::after,
html::before,
html::after {
  content: none !important;
  display: none !important;
}

/* Kill any fixed/absolute decorative layers */
[class*="circle"],
[class*="ring"],
[class*="orb"],
[class*="halo"],
[class*="glow"] {
  display: none !important;
}
</style>


<style>
  /* CENTER INTRO (glitch stage) */
  .center-stage{
    position: relative;
    min-height: calc(100vh - 160px);
    padding: 0;
    overflow: visible;
  }
  /* Fullscreen background layer */
  .intro-stage{
    position: fixed;
    inset: 0;
    z-index: 5;
    background: #fff;
    pointer-events: none; /* do not block clicks */
  }
  #introCanvas{
    width: 100vw;
    height: 100vh;
    display:block;
  }
/* respect reduced motion */
  @media (prefers-reduced-motion: reduce){
    .intro-stage{ filter:none !important; }
  }
</style>


<style>
  /* --- UNDER DEVELOPMENT OVERLAY (item-security / item-soft) --- */
  .dev-overlay{
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 24px;
    background: rgba(255,255,255,0.92);
    backdrop-filter: blur(2px);
  }
  .dev-overlay.is-open{ display:flex; }

  .dev-window{
    width: min(720px, 96vw);
    border: 2px solid #000;
    background: #fff;
    box-shadow: 0 0 0 6px rgba(0,0,0,0.06);
    border-radius: 0;
    position: relative;
  }

  .dev-window::before{
    content:"";
    position:absolute;
    inset:-2px;
    pointer-events:none;
    background:
      linear-gradient(90deg, rgba(0,0,0,0.14), rgba(0,0,0,0)) ,
      repeating-linear-gradient(0deg, rgba(0,0,0,0.08) 0 1px, rgba(0,0,0,0) 1px 5px);
    mix-blend-mode:multiply;
    opacity: .22;
  }

  .dev-inner{
    position: relative;
    padding: 18px 18px 16px;
  }

  .dev-title{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-weight: 800;
    letter-spacing: .06em;
    text-transform: uppercase;
    font-size: 14px;
    margin: 0 0 10px;
  }

  .dev-line{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 13px;
    line-height: 1.55;
    margin: 0 0 14px;
  }

  .dev-actions{
    display:flex;
    gap: 10px;
    align-items:center;
    justify-content:flex-start;
    flex-wrap: wrap;
  }

  .dev-btn{
    appearance: none;
    border: 2px solid #000;
    background: #fff;
    color:#000;
    padding: 10px 14px;
    border-radius: 0;
    cursor: pointer;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-weight: 800;
    letter-spacing: .04em;
    text-transform: uppercase;
    font-size: 12px;
  }
  .dev-btn:hover{ transform: translateY(-1px); }
  .dev-btn:active{ transform: translateY(0px); }

  .dev-hint{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    opacity: .72;
  }
</style>


<style>
  /* Center click area: toggle between item_key and manifesto text */
  .center-toggle{
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: min(520px, 92vw);
    height: min(180px, calc(100vh - 260px));
    z-index: 50;
    background: transparent;
    border: 0;
    padding: 0;
    margin: 0;
    cursor: pointer;
    pointer-events: auto;
    outline: none;
  }
  .center-toggle.is-manifesto{
    width: min(980px, 94vw);
    height: min(620px, calc(100vh - 220px));
  }
  .center-toggle:focus-visible{
    outline: 2px solid #000;
    outline-offset: 6px;
  }
</style>


<style id="__mobile_optimizations">
  /* ===== Mobile optimizations (layout + performance) ===== */
  :root{
    /* safer defaults on phones (overridden below on wider screens) */
    --rail-w: 64px;
    --safe-x: 88px;
    --top: 18px;
    --bottom: 18px;
  }

  /* Use stable viewport units on mobile browsers */
  .center-stage{
    min-height: 100svh;
    padding-top: calc(var(--top) + 52px + env(safe-area-inset-top, 0px));
    padding-bottom: calc(var(--bottom) + 52px + env(safe-area-inset-bottom, 0px));
    box-sizing: border-box;
    touch-action: manipulation;
  }

  /* Fixed bars: never overlap content on tiny screens */
  .topbar--edge, .bottombar--edge{
    width: min(980px, calc(100% - 22px));
    padding: 10px 12px;
    backdrop-filter: blur(2px);
  }
  .bottombar--edge{
    flex-wrap: wrap;
    row-gap: 6px;
  }
  .hint{ line-height: 1.25; }

  /* Better tap targets */
  .tag{
    padding: 10px 12px;
    min-height: 40px;
  }
  .center-toggle{
    width: min(560px, 94vw);
    height: min(220px, calc(100svh - 240px));
  }
  .center-toggle.is-manifesto{
    width: min(980px, 94vw);
    height: min(720px, calc(100svh - 220px));
  }

  /* Prevent accidental horizontal scroll */
  body{ overflow-x: clip; }

  /* Slightly reduce heavy filters on low-power devices */
  @media (max-width: 520px){
    #introCanvas{ image-rendering: auto; }
    .intro-stage{ filter: none !important; }
  }

  /* If user asked to reduce motion / data saver: keep UI but disable animated canvas layer */
  @media (prefers-reduced-motion: reduce){
    .intro-stage{ display:none !important; }
  }
</style>


<!-- Bundled CSS (from styles.css) -->
<style id="__bundled_styles">
@font-face {
  font-family: "Anticva";
  src: url("../fonts/Anticva.ttf") format("truetype");
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

:root{
  --bg:#fff;
  --ink:#0b0b0b;
  --muted: rgba(11,11,11,.62);

  --hair: rgba(0,0,0,.12);
  --hair2: rgba(0,0,0,.22);
  --glass: rgba(255,255,255,.9);

  --rail-w: 96px;
  --safe-x: 165px;

  --top: 28px;
  --bottom: 28px;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }

body{
  margin:0;
  background:var(--bg);
  color:var(--ink);
  font-family:"Anticva","Times New Roman",serif;
  letter-spacing:.28px;
  overflow-x:hidden;
}

/* ===== Cathedral frame: sharp, layered, not rounded ===== */
.outer-frame{
  position: fixed;
  inset: 18px;
  border: 1px solid var(--hair);
  pointer-events: none;
  z-index: 1;
}
.outer-frame::before{
  content:"";
  position:absolute;
  inset: 10px;
  border: 1px solid rgba(0,0,0,.06);
}
.outer-frame::after{
  content:"";
  position:absolute;
  inset: 28px;
  border: 1px solid rgba(0,0,0,.05);
}

/* ===== Top / Bottom: like engraved plaques ===== */
.topbar--edge, .bottombar--edge{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  width: min(860px, calc(100% - 2*var(--safe-x)));
  z-index: 5;
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 12px;

  background: transparent;
  border-top: 1px solid var(--hair);
  border-bottom: 1px solid var(--hair);
  padding: 10px 16px;
}
.topbar--edge{ top: var(--top); }
.bottombar--edge{ bottom: var(--bottom); }

.hint{ font-size: 12px; color: var(--muted); letter-spacing: 2px; text-transform: uppercase; }
.sep{ opacity:.35; }

.toplink{ color:inherit; text-decoration:none; transition: opacity .15s ease; }
.toplink:hover{ opacity:.75; }

.tag{
  display:inline-flex;
  align-items:center;
  gap: 10px;
  padding: 8px 10px;
  border: 1px solid var(--hair2);
  background: rgba(255,255,255,.6);
  text-transform: uppercase;
  letter-spacing: 2.6px;
  font-size: 11px;
}
.tag::before,.tag::after{ content:"✦"; opacity:.65; font-size: 11px; }

/* ===== Rails: buttresses at the edges ===== */
.rail{
  position: fixed;
  top: 0; bottom: 0;
  width: var(--rail-w);
  z-index: 4;
  display:flex;
  flex-direction: column;
  justify-content:center;
  gap: 18px;
  padding: 18px 10px;
  background: transparent;
}

.rail--left{ left:0; }
.rail--right{ right:0; }

/* Edge ribs (verticality) */
.rail--left::before,
.rail--right::before{
  content:"";
  position:absolute;
  top: 18px; bottom: 18px;
  width: 1px;
  background: var(--hair);
}
.rail--left::before{ left: 18px; }
.rail--right::before{ right: 18px; }

/* rail links: pointed arch “tab” */
.rail-link{
  position: relative;
  text-decoration:none;
  color:inherit;

  padding: 14px 8px 16px;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.65);
  transition: border-color .18s ease, transform .18s ease, opacity .18s ease;
  clip-path: polygon(0 10px, 50% 0, 100% 10px, 100% 100%, 0 100%);
}
.rail-link:hover{
  transform: translateY(-2px);
  border-color: var(--hair2);
  opacity: .95;
}

/* vertical title like inscriptions */
.rail-link__title{
  display:block;
  font-size: 11px;
  letter-spacing: 2.8px;
  text-transform: uppercase;
  writing-mode: vertical-rl;
  transform: rotate(180deg);
  line-height: 1;
  margin: 0 auto;
}
.rail-link__meta{ display:none; }

/* ===== Center stage: cathedral nave ===== */
.center-stage{
  min-height: 100vh;
  padding: 0 var(--safe-x);
  display: grid;
  place-items: center;
  position: relative;
  z-index: 2;
}

/* чтобы верх/низ панели не мешали визуальному центру */
.center-stage::before{
  content:"";
  position:absolute;
  inset: 0;
  pointer-events:none;
  /* компенсируем фиксированные бары: чуть “поднимаем” оптический центр */
  transform: translateY(-10px);
}

/* Buttresses inside the safe area (extra vertical push) */
.buttress{
  position:absolute;
  top: 0; bottom: 0;
  width: 1px;
  background: linear-gradient(180deg, transparent, rgba(0,0,0,.18), transparent);
  opacity: .9;
  pointer-events:none;
}
.buttress--l{ left: calc(var(--safe-x) - 24px); }
.buttress--r{ right: calc(var(--safe-x) - 24px); }

/* “Window” behind logo: tall pointed arch with tracery */
.window{
  position:absolute;
  width: min(520px, 62vw);
  height: min(860px, 78vh);
  top: 50%;
  transform: translateY(-50%);
  border: 1px solid rgba(0,0,0,.10);
  background:
    linear-gradient(180deg, rgba(0,0,0,.025), transparent 35%),
    linear-gradient(90deg, rgba(0,0,0,.02), transparent 35%, rgba(0,0,0,.02));
  clip-path: polygon(
    0 12%,
    50% 0%,
    100% 12%,
    100% 100%,
    0 100%
  );
  pointer-events:none;
  opacity: .9;
}

/* ===== CLEAN HERO GRID (ничего не ломается) ===== */

.center-stage{
  min-height: 100vh;
  padding: 0 var(--safe-x);
  display: grid;
  place-items: center;
  position: relative;
  z-index: 2;
}

/* “витраж” аккуратно по центру, без translateY(-50%) */
.window{
  position: absolute;
  width: min(640px, 72vw);
  height: min(860px, 78vh);
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  border: 1px solid rgba(0,0,0,.10);
  background: linear-gradient(180deg, rgba(0,0,0,.022), transparent 40%);
  clip-path: polygon(0 12%, 50% 0%, 100% 12%, 100% 100%, 0 100%);
  opacity: .9;
  pointer-events: none;
}

.tracery{
  position:absolute;
  inset: 14px;
  border: 1px solid rgba(0,0,0,.08);
  clip-path: polygon(0 13%, 50% 0, 100% 13%, 100% 100%, 0 100%);
  background:
    repeating-linear-gradient(90deg, rgba(0,0,0,.055) 0 1px, transparent 1px 18px),
    repeating-linear-gradient(180deg, rgba(0,0,0,.045) 0 1px, transparent 1px 24px);
  opacity: .92;
}

/* главный блок строго по центру */
.hero{
  position: relative;
  display: grid;
  gap: 18px;
  justify-items: center;
  text-align: center;
  z-index: 3;
}

/* текст сверху, как музейная табличка */
.hero-title{
  font-size: clamp(36px, 4.4vw, 64px);
  letter-spacing: 2.4px;
}

.hero-sub{
  margin-top: 6px;
  font-size: 12px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: rgba(0,0,0,.55);
}

.hero-meta{
  margin-top: 12px;
  font-size: 10px;
  letter-spacing: 5px;
  text-transform: uppercase;
  color: rgba(0,0,0,.44);
}

/* КЛИКАБЕЛЬНОЕ ЛОГО: огромное, “пол сайта” */
.logo-link{
  display: grid;
  gap: 10px;
  place-items: center;
  text-decoration: none;
  color: inherit;
  outline: none;
}

.logo-anim{
  width: min(980px, 92vw);
  height: min(62vh, 980px);
  display: grid;
  place-items: center;
}

#logoCanvas{
  width: 100%;
  height: 100%;
  display: block;
  filter: contrast(1.08);
}

/* дорогая подсказка снизу */
.logo-hint{
  font-size: 10px;
  letter-spacing: 6px;
  text-transform: uppercase;
  color: rgba(0,0,0,.40);
  opacity: .9;
}

/* hover — очень тонко (без дешёвых теней) */
.logo-link:hover #logoCanvas{ opacity: .92; }
.logo-link:focus-visible{
  outline: 1px solid rgba(0,0,0,.28);
  outline-offset: 6px;
}

/* на маленьких экранах — убираем мету, чтобы не давило */
@media (max-width: 640px){
  .hero-meta{ display:none; }
  .logo-anim{ height: min(56vh, 720px); }
}

@media (max-width: 520px){
  :root{ --rail-w: 0px; --safe-x: 16px; --top: 12px; --bottom: 12px; }
  .rail{ display:none; }
  .outer-frame{ inset: 10px; }
  .topbar--edge, .bottombar--edge{ width: calc(100% - 2*var(--safe-x)); padding: 8px 12px; gap: 10px; }
  .hint{ font-size: 11px; letter-spacing: 1.6px; }
  .tag{ font-size: 10px; letter-spacing: 2.2px; }
}



/* tracery: thin “stonework” */
.tracery{
  position:absolute;
  inset: 14px;
  border: 1px solid rgba(0,0,0,.08);
  clip-path: polygon(0 13%, 50% 0, 100% 13%, 100% 100%, 0 100%);
  background:
    repeating-linear-gradient(90deg, rgba(0,0,0,.06) 0 1px, transparent 1px 22px),
    repeating-linear-gradient(180deg, rgba(0,0,0,.045) 0 1px, transparent 1px 26px);
  opacity: .85;
}

/* Rose window vibe: radial ribs around center */
.rose{
  position:absolute;
  width: min(520px, 62vw);
  aspect-ratio: 1/1;
  border-radius: 999px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events:none;
  opacity: .55;
  background:
    radial-gradient(circle at 50% 50%, transparent 58%, rgba(0,0,0,.10) 58% 59%, transparent 59%),
    conic-gradient(from 0deg,
      rgba(0,0,0,.12) 0 2deg, transparent 2deg 18deg,
      rgba(0,0,0,.10) 18deg 20deg, transparent 20deg 36deg,
      rgba(0,0,0,.10) 36deg 38deg, transparent 38deg 54deg,
      rgba(0,0,0,.10) 54deg 56deg, transparent 56deg 72deg,
      rgba(0,0,0,.10) 72deg 74deg, transparent 74deg 90deg,
      rgba(0,0,0,.10) 90deg 92deg, transparent 92deg 108deg,
      rgba(0,0,0,.10) 108deg 110deg, transparent 110deg 126deg,
      rgba(0,0,0,.10) 126deg 128deg, transparent 128deg 144deg,
      rgba(0,0,0,.10) 144deg 146deg, transparent 146deg 162deg,
      rgba(0,0,0,.10) 162deg 164deg, transparent 164deg 180deg,
      rgba(0,0,0,.12) 180deg 182deg, transparent 182deg 198deg,
      rgba(0,0,0,.10) 198deg 200deg, transparent 200deg 216deg,
      rgba(0,0,0,.10) 216deg 218deg, transparent 218deg 234deg,
      rgba(0,0,0,.10) 234deg 236deg, transparent 236deg 252deg,
      rgba(0,0,0,.10) 252deg 254deg, transparent 254deg 270deg,
      rgba(0,0,0,.10) 270deg 272deg, transparent 272deg 288deg,
      rgba(0,0,0,.10) 288deg 290deg, transparent 290deg 306deg,
      rgba(0,0,0,.10) 306deg 308deg, transparent 308deg 324deg,
      rgba(0,0,0,.10) 324deg 326deg, transparent 326deg 342deg,
      rgba(0,0,0,.10) 342deg 344deg, transparent 344deg 360deg
    );
}

/* inner arch line */
.arch{
  position:absolute;
  top: 10px;
  left: 12px;
  right: 12px;
  height: 34px;
  border: 1px solid rgba(0,0,0,.12);
  clip-path: polygon(0 70%, 50% 0, 100% 70%, 100% 100%, 0 100%);
  opacity: .9;
  pointer-events:none;
}

.logo-core img{
  width: min(320px, 56vw);
  height:auto;
  display:block;
  filter: contrast(1.03);
}

.core-caption{
  text-align:center;
  width: min(560px, 72vw);
  border-top: 1px solid rgba(0,0,0,.10);
  padding-top: 12px;
}

.core-title{
  font-size: 34px;
  letter-spacing: 1.6px;
}

.core-sub{
  margin-top: 6px;
  font-size: 11.5px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.55);
}

/* microtext: “inscription” */
.microtext{
  position:absolute;
  bottom: 56px;
  left:50%;
  transform: translateX(-50%);
  display:flex;
  gap: 14px;
  align-items:center;

  font-size: 10px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: rgba(0,0,0,.48);
  user-select:none;
}
.microtext .dot{ opacity:.35; }

/* ===== responsive ===== */
@media (max-width: 980px){
  :root{ --rail-w: 78px; --safe-x: 120px; }
  .topbar--edge, .bottombar--edge{
    width: calc(100% - 2*var(--safe-x));
  }
}
@media (max-width: 640px){
  :root{ --rail-w: 64px; --safe-x: 96px; }
  .outer-frame{ inset: 12px; }
  .microtext{ display:none; }
  .window{ opacity: .75; }
}

/* ===== ARCHIVE ATMOSPHERE ===== */

/* бумажная “пыль” без дешёвого шума: только точечные микродефекты */
body::before{
  content:"";
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 0;
  opacity: .55;
  background:
    radial-gradient(circle at 18% 22%, rgba(0,0,0,.020), transparent 40%),
    radial-gradient(circle at 72% 64%, rgba(0,0,0,.018), transparent 42%),
    radial-gradient(circle at 52% 14%, rgba(0,0,0,.014), transparent 38%),
    radial-gradient(circle at 28% 78%, rgba(0,0,0,.016), transparent 44%);
}

/* музейный “штамп/сигиллум” */
body::after{
  content:"";
  position: fixed;
  width: min(560px, 62vw);
  aspect-ratio: 1/1;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
  pointer-events: none;
  z-index: 0;
  opacity: .085;
  background:
    radial-gradient(circle at 50% 50%, transparent 58%, rgba(0,0,0,.32) 58% 59%, transparent 59%),
    conic-gradient(from 0deg,
      rgba(0,0,0,.22) 0 1deg, transparent 1deg 14deg,
      rgba(0,0,0,.18) 14deg 15deg, transparent 15deg 28deg,
      rgba(0,0,0,.18) 28deg 29deg, transparent 29deg 42deg,
      rgba(0,0,0,.18) 42deg 43deg, transparent 43deg 56deg,
      rgba(0,0,0,.18) 56deg 57deg, transparent 57deg 70deg,
      rgba(0,0,0,.18) 70deg 71deg, transparent 71deg 84deg,
      rgba(0,0,0,.18) 84deg 85deg, transparent 85deg 98deg,
      rgba(0,0,0,.18) 98deg 99deg, transparent 99deg 112deg,
      rgba(0,0,0,.18) 112deg 113deg, transparent 113deg 126deg,
      rgba(0,0,0,.18) 126deg 127deg, transparent 127deg 140deg,
      rgba(0,0,0,.18) 140deg 141deg, transparent 141deg 154deg,
      rgba(0,0,0,.18) 154deg 155deg, transparent 155deg 168deg,
      rgba(0,0,0,.18) 168deg 169deg, transparent 169deg 182deg,
      rgba(0,0,0,.18) 182deg 183deg, transparent 183deg 196deg,
      rgba(0,0,0,.18) 196deg 197deg, transparent 197deg 210deg,
      rgba(0,0,0,.18) 210deg 211deg, transparent 211deg 224deg,
      rgba(0,0,0,.18) 224deg 225deg, transparent 225deg 238deg,
      rgba(0,0,0,.18) 238deg 239deg, transparent 239deg 252deg,
      rgba(0,0,0,.18) 252deg 253deg, transparent 253deg 266deg,
      rgba(0,0,0,.18) 266deg 267deg, transparent 267deg 280deg,
      rgba(0,0,0,.18) 280deg 281deg, transparent 281deg 294deg,
      rgba(0,0,0,.18) 294deg 295deg, transparent 295deg 308deg,
      rgba(0,0,0,.18) 308deg 309deg, transparent 309deg 322deg,
      rgba(0,0,0,.18) 322deg 323deg, transparent 323deg 336deg,
      rgba(0,0,0,.18) 336deg 337deg, transparent 337deg 360deg
    );
  filter: blur(.25px);
}

/* маргиналии как на полях архивных листов */
.marginalia{
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 190px;
  display: grid;
  gap: 8px;
  opacity: .72;
  pointer-events: none;
}
.marginalia--left{
  left: calc(var(--safe-x) - 130px);
  text-align: left;
}
.marginalia--right{
  right: calc(var(--safe-x) - 130px);
  text-align: right;
}

.m-line{
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.52);
  position: relative;
}
.m-line::before{
  content:"";
  position: absolute;
  top: 50%;
  width: 24px;
  height: 1px;
  background: rgba(0,0,0,.18);
  transform: translateY(-50%);
  opacity: .9;
}
.marginalia--left .m-line::before{ left: -34px; }
.marginalia--right .m-line::before{ right: -34px; }

/* microtext теперь внутри .logo-core — делаем как гравировку */
.logo-core .microtext{
  position: static;
  transform: none;
  margin-top: 6px;
  opacity: .85;
  justify-content: center;
}

/* ===== FREE CENTER LOGO (без рамок/конверта) ===== */

.logo-center{
  position: relative;
  display: grid;
  place-items: center;
  gap: 14px;
  transform: translateY(-6px); /* оптический центр */
  z-index: 3;
}

/* логотип крупнее, как “алтарный образ” */
.logo-anim{
  width: min(520px, 72vw);
  aspect-ratio: 1 / 1;
  display: grid;
  place-items: center;
}

#logoCanvas{
  width: 100%;
  height: 100%;
  display: block;
  /* чуть “печатный” контраст */
  filter: contrast(1.08);
}

/* подпись — как музейная табличка, без карточек */
.core-caption--free{
  text-align: center;
  width: min(720px, 84vw);
  border-top: 1px solid rgba(0,0,0,.12);
  padding-top: 14px;
}

.core-title{
  font-size: clamp(34px, 4vw, 52px);
  letter-spacing: 2.2px;
}

.core-sub{
  margin-top: 8px;
  font-size: 11.5px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: rgba(0,0,0,.55);
}

/* microtext как гравировка */
.microtext--free{
  position: static;
  transform: none;
  display: flex;
  gap: 14px;
  align-items: center;
  font-size: 10px;
  letter-spacing: 5px;
  text-transform: uppercase;
  color: rgba(0,0,0,.45);
  opacity: .9;
  user-select: none;
}

/* арка теперь “над” логотипом, без рамки */
.arch--free{
  position: absolute;
  top: -26px;
  width: min(560px, 76vw);
  height: 68px;
  border: 1px solid rgba(0,0,0,.14);
  clip-path: polygon(0 70%, 50% 0, 100% 70%, 100% 100%, 0 100%);
  opacity: .7;
  pointer-events: none;
}

/* усиление готической вертикали: тонкие ребра внутри “окна” */
.window{
  opacity: .92;
}
.tracery{
  opacity: .9;
  background:
    repeating-linear-gradient(90deg, rgba(0,0,0,.06) 0 1px, transparent 1px 18px),
    repeating-linear-gradient(180deg, rgba(0,0,0,.045) 0 1px, transparent 1px 24px);
}

/* на маленьких экранах — меньше декоративного */
@media (max-width: 640px){
  .arch--free{ display:none; }
}


/* лёгкий “скан дрейф” для линий окна — едва заметно */
.window, .tracery, .arch{
  animation: drift 9s ease-in-out infinite;
}
@keyframes drift{
  0%,100%{ transform: translateY(-50%) translateX(0px); }
  50%{ transform: translateY(-50%) translateX(.7px); }
}

/* адаптив: маргиналии прячем на узких экранах */
@media (max-width: 980px){
  .marginalia{ display:none; }
}

.logo-anim{
  width: min(340px, 60vw);
  aspect-ratio: 1 / 1;
  display: grid;
  place-items: center;
}

#logoCanvas{
  width: 100%;
  height: 100%;
  display: block;
  image-rendering: auto;
  /* лёгкая “печать” */
  filter: contrast(1.06);
}



/* =========================
   PAGE RULES
   ========================= */

/* По умолчанию на страницах можно скроллить.
   На главной (page-home) — скролл выключен. */
body{ overflow: auto; }
body.page-home{ overflow: hidden; }

/* Чтобы контент магазина не прятался за рейлами */
.page-manufacture .center-stage{
  height: auto;
  min-height: 100vh;
  align-items: flex-start;
}
.page-manufacture{
  overflow-x: hidden;
}

/* =========================
   ITEM-MANUFACTURE (SHOP)
   Gothic Archive UI
   ========================= */

.shop{
  width: 100%;
  max-width: 1240px;
  padding-top: 10px;
  padding-bottom: 28px;
  z-index: 3;
}

.shop-head{
  position: sticky;
  top: calc(var(--top) + 10px);
  z-index: 7;
  margin: 0 auto 18px;
  width: 100%;
  border: 1px solid var(--hair);
  background: rgba(255,255,255,.86);
  backdrop-filter: blur(2px);
}

.shop-head__inner{
  display: grid;
  gap: 10px;
  padding: 12px 14px;
}

.shop-title{
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 16px;
  border-bottom: 1px solid rgba(0,0,0,.06);
  padding-bottom: 10px;
}

.shop-title h1{
  margin: 0;
  font-size: 18px;
  letter-spacing: 3.2px;
  text-transform: uppercase;
}

.shop-title .sub{
  font-size: 10px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: rgba(0,0,0,.55);
}

.shop-tools{
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
}

.tabs{
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.tab{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.65);
  padding: 8px 10px;
  letter-spacing: 2.6px;
  font-size: 11px;
  text-transform: uppercase;
  cursor: pointer;
  user-select: none;
}
.tab[aria-selected="true"]{
  border-color: rgba(0,0,0,.22);
  background: rgba(255,255,255,.95);
}

.controls{
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
}
.select, .btn, .input{
  font-family: inherit;
  letter-spacing: 2.2px;
  text-transform: uppercase;
  font-size: 10.5px;
  padding: 8px 10px;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.72);
  color: var(--ink);
}
.input{
  text-transform: none;
  letter-spacing: .8px;
  font-size: 12px;
}
.btn{
  cursor: pointer;
}
.btn:hover{ border-color: rgba(0,0,0,.22); }

.btn--ghost{
  background: transparent;
}
.btn--primary{
  background: rgba(0,0,0,.04);
  border-color: rgba(0,0,0,.16);
}

.chips{
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  padding-top: 2px;
}
.chip{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.55);
  padding: 7px 10px;
  letter-spacing: 2px;
  font-size: 10.5px;
  text-transform: uppercase;
  cursor: pointer;
}
.chip[data-active="true"]{
  border-color: rgba(0,0,0,.24);
  background: rgba(255,255,255,.92);
}

/* Layout */
.shop-body{
  display: grid;
  grid-template-columns: 1fr;
  gap: 18px;
}

.panel{
  border: 1px solid rgba(0,0,0,.08);
  background: rgba(255,255,255,.80);
  padding: 16px;
}

.panel h2{
  margin: 0 0 10px;
  font-size: 12px;
  letter-spacing: 4px;
  text-transform: uppercase;
}

.bullets{
  margin: 0;
  padding-left: 18px;
  color: rgba(0,0,0,.70);
  line-height: 1.55;
}
.bullets li{ margin: 6px 0; }

.grid{
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 14px;
  align-items: stretch;
}

.card{
  grid-column: span 4;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.86);
  display: grid;
  overflow: hidden;
}

.card__media{
  aspect-ratio: 4/5;
  background: linear-gradient(180deg, rgba(0,0,0,.02), transparent 55%);
  border-bottom: 1px solid rgba(0,0,0,.08);
  display: grid;
  place-items: center;
  position: relative;
}
.card__media img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}
.card__media .placeholder{
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.45);
}

.badge{
  position: absolute;
  top: 10px;
  left: 10px;
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
  padding: 6px 8px;
  border: 1px solid rgba(0,0,0,.16);
  background: rgba(255,255,255,.85);
}

.card__body{
  padding: 12px 12px 14px;
  display: grid;
  gap: 10px;
}

.card__top{
  display: flex;
  gap: 10px;
  align-items: baseline;
  justify-content: space-between;
}
.card__name{
  margin: 0;
  font-size: 12px;
  letter-spacing: 2.2px;
  text-transform: uppercase;
}
.card__price{
  font-size: 12px;
  letter-spacing: 2.2px;
  white-space: nowrap;
}

.card__desc{
  margin: 0;
  font-size: 12px;
  color: rgba(0,0,0,.72);
  line-height: 1.45;
}

.card__meta{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.pill{
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  padding: 6px 8px;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.70);
}

.card__actions{
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  padding-top: 2px;
}

/* Empty state */
.empty{
  grid-column: 1 / -1;
  padding: 28px 16px;
  text-align: center;
  color: rgba(0,0,0,.60);
  border: 1px dashed rgba(0,0,0,.16);
  background: rgba(255,255,255,.65);
}
.empty b{
  display:block;
  margin-bottom: 6px;
  letter-spacing: 3px;
  text-transform: uppercase;
}

/* Cart drawer */
.cart{
  position: fixed;
  right: 0;
  top: 0;
  height: 100vh;
  width: min(420px, 92vw);
  background: rgba(255,255,255,.94);
  border-left: 1px solid rgba(0,0,0,.12);
  transform: translateX(105%);
  transition: transform .22s ease;
  z-index: 10;
  display: grid;
  grid-template-rows: auto 1fr auto;
}
.cart[data-open="true"]{ transform: translateX(0); }

.cart__head, .cart__foot{
  padding: 14px;
  border-bottom: 1px solid rgba(0,0,0,.08);
}
.cart__foot{
  border-top: 1px solid rgba(0,0,0,.08);
  border-bottom: none;
}
.cart__title{
  margin: 0;
  font-size: 12px;
  letter-spacing: 4px;
  text-transform: uppercase;
  display:flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}
.cart__list{
  padding: 10px 14px;
  overflow: auto;
}
.cart-item{
  display:grid;
  grid-template-columns: 1fr auto;
  gap: 10px;
  padding: 10px 0;
  border-bottom: 1px solid rgba(0,0,0,.06);
}
.cart-item:last-child{ border-bottom: none; }
.cart-item__name{
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.cart-item__meta{
  font-size: 11px;
  color: rgba(0,0,0,.60);
}
.cart-item__qty{
  display:flex;
  gap: 6px;
  align-items:center;
}
.qtybtn{
  width: 28px;
  height: 28px;
  border: 1px solid rgba(0,0,0,.12);
  background: rgba(255,255,255,.80);
  cursor: pointer;
  font-family: inherit;
}
.total{
  display:flex;
  justify-content: space-between;
  letter-spacing: 2.8px;
  text-transform: uppercase;
  font-size: 11px;
}

/* Admin modal */
.modal{
  position: fixed;
  inset: 0;
  background: rgba(255,255,255,.70);
  backdrop-filter: blur(2px);
  display: none;
  z-index: 11;
  padding: 22px;
}
.modal[data-open="true"]{ display: grid; place-items: center; }

.modal__card{
  width: min(760px, 96vw);
  border: 1px solid rgba(0,0,0,.12);
  background: rgba(255,255,255,.94);
  padding: 16px;
  display: grid;
  gap: 12px;
}

.modal__head{
  display:flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  border-bottom: 1px solid rgba(0,0,0,.08);
  padding-bottom: 10px;
}
.modal__head h3{
  margin:0;
  font-size: 12px;
  letter-spacing: 4px;
  text-transform: uppercase;
}

.form{
  display:grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 10px;
}
.form .col-6{ grid-column: span 6; }
.form .col-12{ grid-column: 1 / -1; }
.form label{
  display:grid;
  gap: 6px;
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.60);
}
.form textarea{
  min-height: 84px;
  resize: vertical;
}

.helper{
  font-size: 11px;
  color: rgba(0,0,0,.55);
  line-height: 1.45;
}

@media (max-width: 980px){
  .card{ grid-column: span 6; }
}
@media (max-width: 640px){
  .card{ grid-column: 1 / -1; }
  .shop-title{ flex-direction: column; align-items: center; }
  .shop-tools{ justify-content: center; }
  .form .col-6{ grid-column: 1 / -1; }
}



/* =========================
   item-manufacture — exact behavior + marketplace feel
   ========================= */

/* Дом: подкатегории скрываем (JS тоже следит) */
.page-manufacture #sectionChips[data-hidden="true"]{ display:none !important; }

/* Home intro — clean, дорогой, без “панельки” */
.home-panel{
  border: 1px solid rgba(0,0,0,.08);
  background: rgba(255,255,255,.86);
  padding: 18px;
  position: relative;
  overflow: hidden;
}
.home-panel::before{
  content:"";
  position:absolute;
  inset: 0;
  pointer-events:none;
  opacity: .55;
  background:
    radial-gradient(circle at 22% 18%, rgba(0,0,0,.03), transparent 45%),
    radial-gradient(circle at 78% 70%, rgba(0,0,0,.02), transparent 46%);
}
.home-panel__grid{
  position: relative;
  display: grid;
  grid-template-columns: 1.2fr .8fr;
  gap: 16px;
  z-index: 1;
}
.home-kicker{
  font-size: 10px;
  letter-spacing: 6px;
  text-transform: uppercase;
  color: rgba(0,0,0,.52);
}
.home-title{
  margin: 8px 0 10px;
  font-size: clamp(18px, 2.2vw, 28px);
  letter-spacing: 2.8px;
  text-transform: uppercase;
}
.home-lead{
  margin: 0 0 14px;
  color: rgba(0,0,0,.72);
  line-height: 1.55;
  font-size: 13px;
}
.home-cards{
  display:grid;
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap: 10px;
  margin-bottom: 14px;
}
.home-card{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.78);
  padding: 12px;
}
.home-card__h{
  font-size: 10px;
  letter-spacing: 5px;
  text-transform: uppercase;
  color: rgba(0,0,0,.55);
}
.home-card__t{
  margin-top: 8px;
  font-size: 12.5px;
  color: rgba(0,0,0,.70);
  line-height: 1.5;
}
.home-actions{
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items:center;
}
.home-note{
  margin-top: 12px;
  font-size: 11.5px;
  color: rgba(0,0,0,.60);
  line-height: 1.5;
}

/* Right: seal + stats */
.seal{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.80);
  padding: 14px;
}
.seal__title{
  font-size: 10px;
  letter-spacing: 5px;
  text-transform: uppercase;
  color: rgba(0,0,0,.55);
  margin-bottom: 10px;
}
.seal__sigil{
  width: 100%;
  aspect-ratio: 1/1;
  border: 1px solid rgba(0,0,0,.10);
  background:
    radial-gradient(circle at 50% 50%, transparent 58%, rgba(0,0,0,.16) 58% 59%, transparent 59%),
    conic-gradient(from 0deg,
      rgba(0,0,0,.12) 0 2deg, transparent 2deg 18deg,
      rgba(0,0,0,.10) 18deg 20deg, transparent 20deg 36deg,
      rgba(0,0,0,.10) 36deg 38deg, transparent 38deg 54deg,
      rgba(0,0,0,.10) 54deg 56deg, transparent 56deg 72deg,
      rgba(0,0,0,.10) 72deg 74deg, transparent 74deg 90deg,
      rgba(0,0,0,.10) 90deg 92deg, transparent 92deg 108deg,
      rgba(0,0,0,.10) 108deg 110deg, transparent 110deg 126deg,
      rgba(0,0,0,.10) 126deg 128deg, transparent 128deg 144deg,
      rgba(0,0,0,.10) 144deg 146deg, transparent 146deg 162deg,
      rgba(0,0,0,.10) 162deg 164deg, transparent 164deg 180deg
    );
  opacity: .18;
}
.seal__meta{
  margin-top: 10px;
  font-size: 10px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: rgba(0,0,0,.46);
}
.stats{
  margin-top: 14px;
  display:grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}
.stat{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.80);
  padding: 12px;
}
.stat__n{ font-size: 18px; letter-spacing: 3px; }
.stat__l{ margin-top: 6px; font-size: 10px; letter-spacing: 5px; text-transform: uppercase; color: rgba(0,0,0,.52); }

/* Toolbar inside item/guests */
.market-toolbar{
  border: 1px solid rgba(0,0,0,.08);
  background: rgba(255,255,255,.82);
  padding: 12px 14px;
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
}
.market-pill{
  font-size: 10px;
  letter-spacing: 4px;
  text-transform: uppercase;
  color: rgba(0,0,0,.58);
  border: 1px solid rgba(0,0,0,.10);
  padding: 7px 10px;
  background: rgba(255,255,255,.75);
}

/* Cards: collapsed summary like marketplace */
.card--summary .card__desc,
.card--summary .card__meta,
.card--summary .card__actions{
  display:none;
}
.card--summary .card__body{ gap: 6px; }
.card--summary .card__top{ align-items:center; }
.card--summary{
  cursor: pointer;
}
.card--summary:hover{
  border-color: rgba(0,0,0,.18);
}

/* Expanded content */
.card--open{
  grid-column: span 6;
}
.card--open .card__actions{
  display:flex;
}

/* Make media a bit more “product” */
.card__media{
  background: linear-gradient(180deg, rgba(0,0,0,.018), transparent 60%);
}

/* Modal title looks premium */
#clothModalTitle{
  letter-spacing: 4px;
  text-transform: uppercase;
}

/* Responsive home */
@media (max-width: 980px){
  .home-panel__grid{ grid-template-columns: 1fr; }
  .stats{ grid-template-columns: repeat(3, 1fr); }
}
@media (max-width: 640px){
  .home-cards{ grid-template-columns: 1fr; }
  .stats{ grid-template-columns: 1fr; }
}
.auth-box{
  width: min(420px, 90vw);
  border: 1px solid rgba(0,0,0,.15);
  padding: 28px;
  background: rgba(255,255,255,.85);
  display: grid;
  gap: 16px;
}

.auth-tabs{
  display:flex;
  gap:12px;
}

.auth-tab{
  background:none;
  border:none;
  font-family:inherit;
  letter-spacing:3px;
  text-transform:uppercase;
  cursor:pointer;
  opacity:.5;
}

.auth-tab.is-active{ opacity:1; }

.auth-form{
  display:grid;
  gap:12px;
}

.auth-form input{
  padding:10px;
  border:1px solid rgba(0,0,0,.2);
  font-family:inherit;
}

.profile-line{
  letter-spacing:2px;
}

.hidden{ display:none; }

/* ===== CENTER LOGO CIRCLE ===== */

.logo-circle{
  width: min(420px, 70vw);
  aspect-ratio: 1 / 1;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,.18);
  display: grid;
  place-items: center;
  background: rgba(255,255,255,.85);
}

.logo-circle img{
  width: 72%;
  height: auto;
  display: block;
}
.logo-circle::after{
  content:"";
  position:absolute;
  inset: 12px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,.08);
  pointer-events:none;
}




</style>

<style id="__mobile_desktop_like">
  /* Mobile should look like desktop, just scaled to fit the screen */
  html{
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
  }

  /* Keep the same “cathedral” layout on smaller screens by scaling variables smoothly,
     and do NOT hide the side rails (they were the biggest visual difference). */
  @media (max-width: 980px){
    :root{
      --rail-w: clamp(64px, 10vw, 78px);
      --safe-x: clamp(96px, 16vw, 120px);
    }
  }

  @media (max-width: 640px){
    :root{
      --rail-w: clamp(44px, 12vw, 64px);
      --safe-x: clamp(52px, 18vw, 96px);
      --top: 14px;
      --bottom: 14px;
    }

    /* prevent fixed top/bottom bars from sitting on top of the center */
    .center-stage{
      min-height: 100svh;
      padding-top: calc(var(--top) + 58px + env(safe-area-inset-top, 0px));
      padding-bottom: calc(var(--bottom) + 58px + env(safe-area-inset-bottom, 0px));
    }

    /* on phones the plaques should be wide enough (not constrained by safe-x) */
    .topbar--edge, .bottombar--edge{
      width: min(860px, calc(100% - 24px));
    }

    /* never hide the rails on mobile */
    .rail{ display:flex !important; }
  }

  @media (max-width: 520px){
    :root{
      --rail-w: clamp(40px, 14vw, 52px);
      --safe-x: clamp(44px, 20vw, 80px);
      --top: 12px;
      --bottom: 12px;
    }

    .outer-frame{ inset: 10px; }

    .rail{
      display:flex !important;
      padding: 14px 6px;
      gap: 14px;
    }
    .rail--left::before{ left: 12px; }
    .rail--right::before{ right: 12px; }

    .rail-link{ padding: 12px 6px 14px; }
    .rail-link__title{
      font-size: 10px;
      letter-spacing: 2.4px;
    }

    .topbar--edge, .bottombar--edge{
      padding: 8px 12px;
      gap: 10px;
      width: min(860px, calc(100% - 20px));
    }

    .hint{ font-size: 11px; letter-spacing: 1.6px; }
    .tag{ font-size: 10px; letter-spacing: 2.2px; }

    /* Prevent accidental horizontal scroll on mobile */
    body{ overflow-x: clip; }
  }
</style>

</head>
<body class="page page-home">


  <!-- UNDER DEVELOPMENT OVERLAY -->
  <div class="dev-overlay" id="devOverlay" role="dialog" aria-modal="true" aria-labelledby="devOverlayTitle" aria-hidden="true">
    <div class="dev-window" role="document">
      <div class="dev-inner">
        <p class="dev-title" id="devOverlayTitle">отсек в разработке</p>
        <p class="dev-line" id="devOverlayText">Этот отсек ещё не ожил. Возвращайся позже.</p>
        <div class="dev-actions">
          <button class="dev-btn" id="devOverlayBack" type="button">вернуться назад</button>
          <span class="dev-hint">Esc — выйти</span>
        </div>
      </div>
    </div>
  </div>


  <!-- тонкая рамка по краю (дорого выглядит) -->
  
  
<div class="veil" aria-hidden="true"></div>

  <!-- верхний “герб” -->
  <header class="topbar topbar--edge">
    <a class="toplink" href="item-manufacture.html?returnTo=index.html" aria-label="Item Manufacture">
      <span class="tag">item-manufacture</span>
    </a>
  </header>

<main class="center-stage" aria-label="Центр">
  <div class="intro-stage" aria-hidden="true">
    <canvas id="introCanvas"></canvas>
  </div>

  <!-- clickable center area (toggles manifesto text) -->
  <button class="center-toggle" id="centerToggle" type="button" aria-label="Открыть описание Item Key"></button>
</main>



  <footer class="bottombar bottombar--edge">
    <span class="hint">ты уже здесь был.
ты просто не помнил.</span>
    <span class="sep">•</span>
    <span class="hint">ONO-beta</span>
  </footer>

  <script id="__bundled_mainjs">
// Небольшой “живой” штрих: подсветка активной страницы и мягкий звук/эффект можно добавить позже.
(() => {
  const path = (location.pathname.split("/").pop() || "index.html").toLowerCase();

  const links = document.querySelectorAll("a[href]");
  links.forEach(a => {
    const href = (a.getAttribute("href") || "").toLowerCase();
    if (href === path) a.classList.add("is-active");
  });
})();

(() => {
  const canvas = document.getElementById("logoCanvas");
  if (!canvas) return;

  const isMobile = window.matchMedia && window.matchMedia('(max-width: 720px)').matches;
  const saveData = !!(navigator.connection && navigator.connection.saveData);
  const lowPower = isMobile || saveData;

  const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
  const DPR = lowPower ? 1.25 : Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // === НАСТРОЙКИ СЕКВЕНЦИИ ===
 const SEQ = {
  // поставь реальное число кадров, которое у тебя есть
  frameCount: 120,

  // logo01_00001.png ... logo01_00120.png
  makeSrc: (i) => `assets/img/logo_seq/logo01_${String(i).padStart(5, "0")}.png`,

  fps: 24,
  loop: true,
};


  // === НАСТРОЙКИ ГЛИТЧА (дорого, не “дешёвый мем”) ===
  const GLITCH = {
    // шанс “события” на кадр
    eventChance: 0.07,
    // интенсивность сдвига каналов
    rgbShift: 10,
    // количество “срезов”
    slicesMin: 2,
    slicesMax: 7,
    // вертикальное дрожание
    jitterY: 2,
    // редкие сильные провалы
    hardDropChance: 0.01,
  };

  // ресайз canvas под CSS size
  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * DPR);
    canvas.height = Math.round(rect.height * DPR);
  }
  fitCanvas();
  window.addEventListener("resize", fitCanvas);

  // preload frames
  const frames = new Array(SEQ.frameCount);
  let loaded = 0;
  let ready = false;

  function loadFrame(i) {
    return new Promise((resolve) => {
      const img = new Image();
      img.decoding = "async";
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = SEQ.makeSrc(i + 1);
    });
  }

  (async () => {
    // грузим последовательно, чтобы не убить память
    for (let i = 0; i < SEQ.frameCount; i++) {
      frames[i] = await loadFrame(i);
      if (frames[i]) loaded++;
    }
    ready = loaded > 0;
  })();

  // helpers
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));

  function drawContain(img) {
    const cw = canvas.width, ch = canvas.height;
    ctx.clearRect(0, 0, cw, ch);

    // фон прозрачный, но можно оставить “бумажность” через CSS тела
    if (!img) return;

    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;

    const scale = Math.min(cw / iw, ch / ih);
    const w = Math.round(iw * scale);
    const h = Math.round(ih * scale);
    const x = Math.round((cw - w) / 2);
    const y = Math.round((ch - h) / 2);

    ctx.drawImage(img, x, y, w, h);
  }

  function glitchPass() {
    const cw = canvas.width, ch = canvas.height;

    // редкий “жёсткий провал”
    const hardDrop = Math.random() < GLITCH.hardDropChance;
    const doEvent = hardDrop || Math.random() < GLITCH.eventChance;

    if (!doEvent) {
      // микродрожание очень мягко
      const jy = (Math.random() - 0.5) * GLITCH.jitterY;
      if (Math.abs(jy) > 0.2) {
        const imgData = ctx.getImageData(0, 0, cw, ch);
        ctx.clearRect(0, 0, cw, ch);
        ctx.putImageData(imgData, 0, jy);
      }
      return;
    }

    // базовый снимок
    const base = ctx.getImageData(0, 0, cw, ch);

    // “scanlines” лёгкие
    ctx.save();
    ctx.globalAlpha = hardDrop ? 0.18 : 0.08;
    for (let y = 0; y < ch; y += randi(6, 10)) {
      ctx.fillStyle = "rgba(0,0,0,1)";
      ctx.fillRect(0, y, cw, 1);
    }
    ctx.restore();

    // RGB shift (дорого: чуть-чуть, не кислотно)
    const shift = hardDrop ? GLITCH.rgbShift * 2 : GLITCH.rgbShift;
    const dxR = randi(-shift, shift);
    const dxB = randi(-shift, shift);

    ctx.clearRect(0, 0, cw, ch);

    // рисуем base как слой
    ctx.putImageData(base, 0, 0);

    // “каналы” имитируем смещением копий с небольшой прозрачностью
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = hardDrop ? 0.55 : 0.28;
    ctx.drawImage(canvas, dxR, 0);
    ctx.globalAlpha = hardDrop ? 0.45 : 0.22;
    ctx.drawImage(canvas, dxB, 0);
    ctx.restore();

    // СЛАЙСЫ (разрезы по горизонтали)
    const slices = randi(GLITCH.slicesMin, GLITCH.slicesMax) * (hardDrop ? 2 : 1);

    for (let i = 0; i < slices; i++) {
      const sh = randi(10, Math.max(18, Math.floor(ch * 0.10)));
      const sy = randi(0, ch - sh);
      const sx = 0;

      const offset = randi(-Math.floor(cw * 0.08), Math.floor(cw * 0.08)) * (hardDrop ? 2 : 1);
      const slice = ctx.getImageData(sx, sy, cw, sh);

      ctx.putImageData(slice, offset, sy);

      // тонкая “трещина”
      ctx.save();
      ctx.globalAlpha = hardDrop ? 0.25 : 0.12;
      ctx.fillStyle = "rgba(0,0,0,1)";
      ctx.fillRect(0, sy + randi(0, sh), cw, 1);
      ctx.restore();
    }

    // “архивный выпад” — чуть выцветания
    if (hardDrop) {
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.fillRect(0, 0, cw, ch);
      ctx.restore();
    }
  }

  // playback
  let frame = 0;
  let last = performance.now();
  const frameMS = 1000 / SEQ.fps;

  function tick(now) {
    requestAnimationFrame(tick);

    if (!ready) {
      // запасной вариант: пока кадры не готовы — статичное лого
      // (можно оставить пустым)
      return;
    }

    if (now - last < frameMS) return;
    last = now;

    const img = frames[frame] || frames.find(Boolean);
    drawContain(img);
    glitchPass();

    frame++;
    if (frame >= SEQ.frameCount) frame = SEQ.loop ? 0 : SEQ.frameCount - 1;
  }

  requestAnimationFrame(tick);
})();


/* =========================


/* =========================
   ITEM-MANUFACTURE STORE
   - Дом: только вступление (без подкатегорий)
   - item / guests: витрина + кнопка "add clothing"
   - карточка: в сетке только фото+название+цена, остальное при раскрытии
   - "база": seed-файл assets/js/item-manufacture.db.json + localStorage
   ========================= */

(() => {
  if (!document.body.classList.contains("page-manufacture")) return;

  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  // UI
  const tabButtons = $$(".tab");
  const chipWrap = $("#sectionChips");
  const chipButtons = $$(".chip");
  const searchInput = $("#shopSearch");
  const currencySelect = $("#currencySelect");

  const homePanel = $("#homePanel");
  const grid = $("#productGrid");

  const toolbar = $("#marketToolbar");
  const scopePill = $("#marketScope");
  const addClothBtn = $("#addClothBtn");
  const saveDbBtn = $("#saveDbBtn");

  const goItem = $("#goItem");
  const goGuests = $("#goGuests");

  // Cart UI
  const cart = $("#cart");
  const cartOpen = $("#cartOpen");
  const cartClose = $("#cartClose");
  const cartList = $("#cartList");
  const cartCount = $("#cartCount");
  const cartTotal = $("#cartTotal");

  // Modal UI
  const modal = $("#clothModal");
  const modalClose = $("#clothClose");
  const form = $("#clothForm");
  const ownerHidden = $("#clothOwner");

  const exportDbBtn = $("#exportDbBtn");
  const importDbInput = $("#importDbInput");
  const clearDbBtn = $("#clearDbBtn");

  // Stats (optional)
  const statTotal = $("#statTotal");
  const statItem = $("#statItem");
  const statGuests = $("#statGuests");

  // Keys
  const KEY_PRODUCTS = "itemkey.manufacture.products.v3";
  const KEY_CART = "itemkey.manufacture.cart.v3";
  const KEY_CURRENCY = "itemkey.manufacture.currency.v3";
  const SEED_URL = "assets/js/item-manufacture.db.json";

  const state = {
    tab: "home",        // home | item | guests
    section: "all",
    query: "",
    openCardId: null,
    currency: "BYN",
    // временные курсы (потом подключим реальные)
    rates: { BYN: 1, USD: 0.31, EUR: 0.29, RUB: 29.0 },
    products: [],
    cart: []
  };

  function uid(){
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }
  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function normCat(c){
    return (c || "").trim().toLowerCase() || "другое";
  }

  function loadJSON(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      return JSON.parse(raw);
    }catch{ return fallback; }
  }
  function saveJSON(key, value){
    localStorage.setItem(key, JSON.stringify(value));
  }
  function persist(){
    saveJSON(KEY_PRODUCTS, state.products);
    saveJSON(KEY_CART, state.cart);
    saveJSON(KEY_CURRENCY, state.currency);
  }

  function money(amountBYN){
    const cur = state.currency;
    const rate = state.rates[cur] ?? 1;
    const v = amountBYN * rate;
    const fmt = new Intl.NumberFormat("ru-RU", { maximumFractionDigits: cur==="RUB"?0:2 });
    return `${fmt.format(v)} ${cur}`;
  }

  async function loadProducts(){
    const existing = loadJSON(KEY_PRODUCTS, null);
    if (Array.isArray(existing)) return existing;

    // пробуем seed
    try{
      const res = await fetch(SEED_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("seed not found");
      const data = await res.json();
      if (Array.isArray(data)) {
        saveJSON(KEY_PRODUCTS, data);
        return data;
      }
    }catch{
      // ignore
    }
    return [];
  }

  function setTab(tab){
    state.tab = tab;
    state.openCardId = null;

    tabButtons.forEach(b => b.setAttribute("aria-selected", b.dataset.tab === tab ? "true" : "false"));

    // Дом: скрываем подкатегории и тулбар
    const isHome = (tab === "home");

    if (homePanel) homePanel.style.display = isHome ? "block" : "none";
    if (chipWrap) {
      chipWrap.style.display = isHome ? "none" : "flex";
      chipWrap.dataset.hidden = isHome ? "true" : "false";
    }
    if (toolbar) toolbar.style.display = isHome ? "none" : "flex";

    if (scopePill) scopePill.textContent = `scope: ${tab}`;
    if (ownerHidden) ownerHidden.value = tab;

    render();
  }

  function setSection(cat){
    state.section = cat;
    state.openCardId = null;
    chipButtons.forEach(c => c.dataset.active = (c.dataset.cat === cat) ? "true" : "false");
    render();
  }

  function filtered(){
    const q = state.query.trim().toLowerCase();
    return state.products
      .filter(p => state.tab === "home" ? false : (p.owner === state.tab))
      .filter(p => state.section === "all" ? true : normCat(p.category) === normCat(state.section))
      .filter(p => {
        if (!q) return true;
        const hay = `${p.name} ${p.desc} ${p.category}`.toLowerCase();
        return hay.includes(q);
      });
  }

  function renderStats(){
    if (!statTotal) return;
    const total = state.products.length;
    const item = state.products.filter(p => p.owner === "item").length;
    const guests = state.products.filter(p => p.owner === "guests").length;
    statTotal.textContent = String(total);
    statItem.textContent = String(item);
    statGuests.textContent = String(guests);
  }

  function cardHTML(p, open){
    const img = p.image
      ? `<img src="${p.image}" alt="${esc(p.name)}">`
      : `<div class="placeholder">image</div>`;

    // summary always visible: фото + название + цена
    return `
      <article class="card ${open ? "card--open" : "card--summary"}" data-id="${p.id}">
        <div class="card__media">${img}</div>
        <div class="card__body">
          <div class="card__top">
            <h3 class="card__name">${esc(p.name)}</h3>
            <div class="card__price">${money(p.priceBYN)}</div>
          </div>

          <p class="card__desc">${esc(p.desc || "")}</p>

          <div class="card__actions">
            <button class="btn btn--primary" data-act="add">add to cart</button>
            <button class="btn" data-act="close">close</button>
          </div>
        </div>
      </article>
    `;
  }

  function renderGrid(){
    if (!grid) return;

    if (state.tab === "home"){
      grid.innerHTML = "";
      return;
    }

    const list = filtered();

    if (!list.length){
      grid.innerHTML = `
        <div class="empty">
          <b>пока пусто</b>
          нажми <u>add clothing</u> и создай первую карточку.
        </div>
      `;
      return;
    }

    grid.innerHTML = list.map(p => cardHTML(p, state.openCardId === p.id)).join("");
  }

  // Cart
  function openCart(on){
    if (!cart) return;
    cart.dataset.open = on ? "true" : "false";
  }
  function cartQty(){
    return state.cart.reduce((s, x) => s + x.qty, 0);
  }
  function renderCart(){
    if (!cartCount || !cartList || !cartTotal) return;
    cartCount.textContent = String(cartQty());

    if (!state.cart.length){
      cartList.innerHTML = `<div class="helper">Корзина пуста.</div>`;
      cartTotal.textContent = money(0);
      return;
    }

    cartList.innerHTML = state.cart.map(it => {
      const p = state.products.find(x => x.id === it.id);
      if (!p) return "";
      return `
        <div class="cart-item" data-id="${it.id}">
          <div>
            <div class="cart-item__name">${esc(p.name)}</div>
            <div class="cart-item__meta">${money(p.priceBYN)} · ${esc(p.category || "—")}</div>
          </div>
          <div class="cart-item__qty">
            <button class="qtybtn" data-q="dec">−</button>
            <div>${it.qty}</div>
            <button class="qtybtn" data-q="inc">+</button>
          </div>
        </div>
      `;
    }).join("");

    const totalBYN = state.cart.reduce((sum, it) => {
      const p = state.products.find(x => x.id === it.id);
      return sum + (p ? p.priceBYN * it.qty : 0);
    }, 0);

    cartTotal.textContent = money(totalBYN);
  }

  function addToCart(id){
    const it = state.cart.find(x => x.id === id);
    if (it) it.qty += 1;
    else state.cart.push({ id, qty: 1 });
    persist();
    renderCart();
  }

  function adjustQty(id, delta){
    const it = state.cart.find(x => x.id === id);
    if (!it) return;
    it.qty += delta;
    if (it.qty <= 0) state.cart = state.cart.filter(x => x.id !== id);
    persist();
    renderCart();
  }

  // Modal
  function openModal(on){
    if (!modal) return;
    modal.dataset.open = on ? "true" : "false";
    modal.setAttribute("aria-hidden", on ? "false" : "true");
  }

  function readFileAsDataURL(file){
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(String(fr.result));
      fr.onerror = reject;
      fr.readAsDataURL(file);
    });
  }

  async function onPublish(e){
    e.preventDefault();

    const fd = new FormData(form);
    const owner = String(fd.get("owner") || state.tab || "item");
    const category = String(fd.get("category") || "другое").trim() || "другое";
    const name = String(fd.get("name") || "").trim();
    const desc = String(fd.get("desc") || "").trim();
    const priceBYN = Number(String(fd.get("price") || "0").replace(",", "."));

    if (!name || !Number.isFinite(priceBYN) || priceBYN <= 0){
      alert("Заполни название и цену (числом).");
      return;
    }

    let image = String(fd.get("imageUrl") || "").trim();
    const file = form.querySelector('input[name="imageFile"]')?.files?.[0];
    if (file){
      try{ image = await readFileAsDataURL(file); }catch{}
    }

    const product = {
      id: uid(),
      owner: owner === "guests" ? "guests" : "item",
      category,
      name,
      priceBYN,
      image,
      desc,
      createdAt: Date.now()
    };

    state.products.unshift(product);
    persist();

    // сброс и закрыть
    form.reset();
    ownerHidden.value = state.tab;
    openModal(false);

    // показать в текущей вкладке и раскрыть карточку
    state.openCardId = product.id;
    render();
  }

  // Save DB to file: try File System Access API, else download
  async function saveDbToFile(){
    const json = JSON.stringify(state.products, null, 2);

    // 1) File System Access API (Chromium)
    try{
      if (window.showSaveFilePicker){
        const handle = await window.showSaveFilePicker({
          suggestedName: "item-manufacture.db.json",
          types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
        });
        const writable = await handle.createWritable();
        await writable.write(json);
        await writable.close();
        alert("DB сохранена в файл.");
        return;
      }
    }catch{
      // ignore and fallback
    }

    // 2) Fallback: download
    const blob = new Blob([json], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "item-manufacture.db.json";
    a.click();
    URL.revokeObjectURL(a.href);
    alert("DB скачана. Положи файл в assets/js/ и замени старый.");
  }

  function exportDb(){
    const blob = new Blob([JSON.stringify(state.products, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "item-manufacture.db.json";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  async function importDb(file){
    const txt = await file.text();
    const data = JSON.parse(txt);
    if (!Array.isArray(data)) throw new Error("bad db");
    state.products = data.map(x => ({
      id: String(x.id || uid()),
      owner: (x.owner === "guests") ? "guests" : "item",
      category: String(x.category || "другое"),
      name: String(x.name || "Untitled"),
      priceBYN: Number(x.priceBYN || 0),
      image: String(x.image || ""),
      desc: String(x.desc || ""),
      createdAt: Number(x.createdAt || Date.now())
    }));
    state.openCardId = null;
    persist();
    render();
    alert("DB импортирована.");
  }

  function clearAll(){
    if (!confirm("Очистить все карточки?")) return;
    state.products = [];
    state.cart = [];
    state.openCardId = null;
    persist();
    render();
    renderCart();
  }

  function render(){
    renderGrid();
    renderCart();
    renderStats();
    if (currencySelect) currencySelect.value = state.currency;
  }

  // ===== Events wiring =====
  tabButtons.forEach(b => b.addEventListener("click", () => setTab(b.dataset.tab)));

  chipButtons.forEach(c => c.addEventListener("click", () => setSection(c.dataset.cat)));

  if (searchInput){
    searchInput.addEventListener("input", (e) => {
      state.query = e.target.value || "";
      state.openCardId = null;
      render();
    });
  }

  if (currencySelect){
    currencySelect.addEventListener("change", (e) => {
      state.currency = e.target.value;
      persist();
      render();
    });
  }

  cartOpen?.addEventListener("click", () => openCart(true));
  cartClose?.addEventListener("click", () => openCart(false));

  cart?.addEventListener("click", (e) => {
    const btn = e.target.closest(".qtybtn");
    if (!btn) return;
    const row = e.target.closest(".cart-item");
    if (!row) return;
    adjustQty(row.dataset.id, btn.dataset.q === "inc" ? 1 : -1);
  });

  // Card click: open/close + add to cart
  grid?.addEventListener("click", (e) => {
    const card = e.target.closest(".card");
    if (!card) return;
    const id = card.dataset.id;

    const act = e.target.dataset.act;
    if (act === "add"){
      e.stopPropagation();
      addToCart(id);
      return;
    }
    if (act === "close"){
      e.stopPropagation();
      state.openCardId = null;
      render();
      return;
    }

    // toggle open
    state.openCardId = (state.openCardId === id) ? null : id;
    render();
  });

  // Add clothing button (must exist in item/guests)
  addClothBtn?.addEventListener("click", () => {
    if (state.tab === "home") return;
    ownerHidden.value = state.tab;
    openModal(true);
  });

  saveDbBtn?.addEventListener("click", saveDbToFile);

  modalClose?.addEventListener("click", () => openModal(false));
  modal?.addEventListener("click", (e) => { if (e.target === modal) openModal(false); });

  form?.addEventListener("submit", onPublish);

  exportDbBtn?.addEventListener("click", exportDb);
  importDbInput?.addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try{ await importDb(f); }catch{ alert("Ошибка импорта."); }
    importDbInput.value = "";
  });
  clearDbBtn?.addEventListener("click", clearAll);

  goItem?.addEventListener("click", () => setTab("item"));
  goGuests?.addEventListener("click", () => setTab("guests"));

  // ===== init =====
  state.cart = loadJSON(KEY_CART, []);
  state.currency = loadJSON(KEY_CURRENCY, "BYN") || "BYN";

  (async () => {
    state.products = await loadProducts();
    // старт — Дом, без подкатегорий и тулбара
    setTab("home");
  })();
})();
/* =========================
   ITEM-USER HEADER LABEL
   показывает @login когда пользователь вошёл
   ========================= */
(() => {
  const CURRENT_KEY = "itemkey.currentUser";

  let current = null;
  try {
    current = JSON.parse(localStorage.getItem(CURRENT_KEY) || "null");
  } catch {
    current = null;
  }

  // Ищем ссылку в шапке на item-user.html (есть на всех твоих страницах)
  const userLink = document.querySelector('a.toplink[href="item-user.html"]');
  if (!userLink) return;

  const tag = userLink.querySelector(".tag");
  if (!tag) return;

  if (current && current.name) {
    tag.textContent = `item-user · @${current.name}`;
    userLink.setAttribute("aria-label", `Item User ${current.name}`);
  } else {
    tag.textContent = "item-user";
    userLink.setAttribute("aria-label", "Item User");
  }
})();


</script>

<script>
(function(){
  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  const canvas = document.getElementById('introCanvas');
  if(!canvas) return;

  
    const isMobile = window.matchMedia && window.matchMedia('(max-width: 720px)').matches;
    // Make phone UI look like desktop (just smaller), while keeping isMobile for performance toggles.
    const uiMobile = false;
  const saveData = !!(navigator.connection && navigator.connection.saveData);

  // Mobile should still show the intro — just lighter + sharper text.
  const HEAVY_FX = !(prefersReduced || saveData);
  // Postprocess (dither/grain/scanlines) makes text look pixelated on phones — disable it there.
  const POST_FX  = !(prefersReduced || saveData || isMobile);
  // Smooth upscaling on phones to avoid “stairs” on text.
  const OUTPUT_SMOOTH = isMobile;

  // Hint the browser: avoid overscroll jank during the intro
  document.documentElement.style.overscrollBehavior = 'none';

const centerToggle = document.getElementById('centerToggle');
  let uiState = 'intro'; // 'intro' | 'manifesto'

  const MANIFESTO_TEXT = `Item Key - архив человеческого подсознания.
Это не коллекция вещей.
Это система наблюдения за человеком через следы, которые он оставляет в материи.
Item Key создан, чтобы извлекать то, что не поддаётся прямой речи:
импульсы, искажения, страхи, память, намерения.
Здесь вещь - не объект, а вывернутое наружу внутреннее.
Каждый предмет — это зафиксированное состояние разума.
Форма мысли, ставшая материальной.
Фрагмент личности, переживший своего носителя.
Item Key - способ архивации не предмета, а человека.
Метод сохранить себя вне тела,
осмыслить собственную структуру
и передать её дальше - не словами, а присутствием.`;

  function setToggleState(){
    if(!centerToggle) return;
    centerToggle.classList.toggle('is-manifesto', uiState === 'manifesto');
    centerToggle.setAttribute('aria-label', uiState === 'manifesto' ? 'Вернуться к item_key' : 'Открыть описание Item Key');
  }
  setToggleState();

  if(centerToggle){
    centerToggle.addEventListener('click', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      toggleUI();
    });
    centerToggle.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        toggleUI();
      }
    });
  }

const ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: true });

  // Offscreen low-res scene (faster + more "digital")
  const scene = document.createElement('canvas');
  const sctx  = scene.getContext('2d', { alpha: true, willReadFrequently: true });

  // Offscreen buffers for morphing
  const bufA = document.createElement('canvas');
  const bufB = document.createElement('canvas');
  const actx = bufA.getContext('2d', { alpha: true });
  const bctx = bufB.getContext('2d', { alpha: true });

  let dprUsed = 1;
  let quality = 0.62; // low-res ratio (tweak for vibe/perf)

  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    dprUsed = dpr;

    const W = window.innerWidth;
    const H = window.innerHeight;

    canvas.width  = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);

    ctx.setTransform(dpr,0,0,dpr,0,0);

    // quality adapts a bit on small screens
    const short = Math.min(W, H);
    quality = prefersReduced ? 0.82 : (isMobile ? 0.86 : (short < 520 ? 0.70 : 0.74));

    scene.width  = Math.max(220, Math.floor(W * quality));
    scene.height = Math.max(180, Math.floor(H * quality));

    bufA.width = bufB.width = scene.width;
    bufA.height = bufB.height = scene.height;
  }

  function W(){ return canvas.width / dprUsed; }
  function H(){ return canvas.height / dprUsed; }
  function SW(){ return scene.width; }
  function SH(){ return scene.height; }

  // ---------- Utilities ----------
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // deterministic hash (for stable glitch bands)
  function hash01(n){
    const x = Math.sin(n * 127.1 + 311.7) * 43758.5453;
    return x - Math.floor(x);
  }

  const bayer4 = [
    [ 0,  8,  2, 10],
    [12,  4, 14,  6],
    [ 3, 11,  1,  9],
    [15,  7, 13,  5],
  ];

  function ditherBWSelective(imageData, strength){
    const d = imageData.data;
    const w = imageData.width;
    const h = imageData.height;
    const s = clamp(strength, 0, 1);

    for(let y=0; y<h; y++){
      for(let x=0; x<w; x++){
        const i = (y*w + x) * 4;
        const r = d[i], g = d[i+1], b = d[i+2], a = d[i+3];

        const lum = (0.2126*r + 0.7152*g + 0.0722*b);

        // keep background clean
        if(lum > 250 && a > 200){
          d[i]=d[i+1]=d[i+2]=255;
          continue;
        }
        if(a === 0) continue;

        const t = (bayer4[y & 3][x & 3] / 16) * 255;
        const k = lum + (t - 128) * (0.55 + 0.95*s);
        const out = k > (172 - s*138) ? 255 : 0;
        d[i]=d[i+1]=d[i+2]=out;
      }
    }
    return imageData;
  }

  function addGrain(imageData, amount){
    const d = imageData.data;
    const a = clamp(amount, 0, 1);
    const n = a * 58;
    for(let i=0; i<d.length; i+=4){
      if(d[i+3] === 0) continue;
      const rnd = (Math.random()*2 - 1) * n;
      const v = d[i] + rnd;
      const out = clamp(v, 0, 255);
      d[i]=d[i+1]=d[i+2]=out;
    }
    return imageData;
  }

  function sliceGlitch(ctx2d, srcCanvas, w, h, intensity, seed){
    // strong, banded, stable-ish
    const bands = 7 + Math.floor(intensity*12);
    for(let b=0; b<bands; b++){
      const r1 = hash01(seed + b*11.3);
      const r2 = hash01(seed + b*29.1);
      const y  = r1 * h;
      const sh = 1 + r2 * (8 + intensity*16);
      const dx = (hash01(seed + b*53.7)*2 - 1) * (18 + intensity*110);
      ctx2d.drawImage(srcCanvas, 0, y, w, sh, dx, y, w, sh);
    }
  }

  // rings drawn in scene space (low-res) but thick enough
  function drawRings(ctx2d, cx, cy, t, intensity){
    const w = SW(), h = SH();
    const maxR = Math.sqrt(w*w + h*h) * 0.62;
    const rings = 10;

    ctx2d.save();
    ctx2d.globalCompositeOperation = 'multiply';
    ctx2d.strokeStyle = 'rgba(0,0,0,1)';

    // thicker rings (scene-space)
    ctx2d.lineWidth = 2.3 + intensity*1.7;

    for(let i=0;i<rings;i++){
      const r = (i*maxR/rings) + 22 + Math.sin(t*0.85 + i)*12;
      ctx2d.globalAlpha = 0.05 + intensity*0.18;

      ctx2d.beginPath();
      ctx2d.arc(cx, cy, Math.max(0, r), 0, Math.PI*2);
      ctx2d.stroke();

      // ink second pass
      ctx2d.globalAlpha *= 0.55;
      ctx2d.beginPath();
      ctx2d.arc(cx + Math.sin(t*1.6+i)*0.8, cy + Math.cos(t*1.3+i)*0.8, Math.max(0, r+0.6), 0, Math.PI*2);
      ctx2d.stroke();
    }
    ctx2d.restore();
  }

  function drawCenteredImage(ctx2d, img, x, y, w, h, rot, alpha){
    if(!img || !img.complete || !img.naturalWidth) return;
    ctx2d.save();
    ctx2d.translate(x, y);
    ctx2d.rotate(rot);
    ctx2d.globalAlpha = alpha;
    ctx2d.imageSmoothingEnabled = true;
    ctx2d.drawImage(img, -w/2, -h/2, w, h);
    ctx2d.restore();
  }

  function drawText(ctx2d, text, x, y, size, alpha, skew){
    ctx2d.save();
    ctx2d.translate(x, y);
    ctx2d.globalAlpha = alpha;
    ctx2d.fillStyle = '#000';
    ctx2d.textAlign = 'center';
    ctx2d.textBaseline = 'middle';
    ctx2d.font = `900 ${size}px ui-serif, "Times New Roman", Georgia, serif`;
    ctx2d.transform(1.10, 0, skew, 1, 0, 0);
    ctx2d.fillText(text, 0, 0);
    ctx2d.restore();
  }

  function setSerifFont(ctx2d, size){
    ctx2d.font = `900 ${size}px ui-serif, "Times New Roman", Georgia, serif`;
  }

  function wrapLines(ctx2d, text, maxWidth, size){
    setSerifFont(ctx2d, size);
    const hard = String(text || '').split('\n');
    const out = [];
    for(const segRaw of hard){
      const seg = (segRaw || '').trim();
      if(!seg){
        out.push('');
        continue;
      }
      const words = seg.split(/\s+/);
      let line = '';
      for(const w of words){
        const test = line ? (line + ' ' + w) : w;
        if(ctx2d.measureText(test).width <= maxWidth || !line){
          line = test;
        }else{
          out.push(line);
          line = w;
        }
      }
      if(line) out.push(line);
    }
    return out;
  }

  function layoutBlock(ctx2d, text, maxWidth, maxHeight, baseSize){
    const lhFactor = uiMobile ? 1.28 : 1.45;
    let size = clamp(baseSize, uiMobile ? 10 : 12, 40);
    let lines = wrapLines(ctx2d, text, maxWidth, size);
    let lh = size * lhFactor;

    // shrink to fit height (fast iterative)
    for(let i=0; i<8; i++){
      const total = lines.length * lh;
      if(total <= maxHeight) break;
      const k = Math.max(0.55, (maxHeight / Math.max(1, total)) * 0.96);
      size = Math.max(12, size * k);
      lines = wrapLines(ctx2d, text, maxWidth, size);
      lh = size * lhFactor;
    }
    return { lines, size, lh };
  }

  async function loadImageWithFallback(candidates){
    for(const url of candidates){
      try{
        const img = new Image();
        img.decoding = 'async';
        img.loading = 'eager';
        img.src = url;
        await img.decode();
        return img;
      }catch(e){}
    }
    const img = new Image();
    img.src = candidates[0] || '';
    return img;
  }

  function fallbacks(name){
    return [name, `./${name}`, `assets/${name}`, `assets/img/${name}`, `assets/images/${name}`, `images/${name}`, `img/${name}`];
  }

  // ---------- Interaction ----------
  let targetPX = 0.5, targetPY = 0.5; // 0..1
  let px = 0.5, py = 0.5;            // smoothed
  let scrollBoost = 0;

  window.addEventListener('mousemove', (e)=>{
    targetPX = clamp(e.clientX / Math.max(1, window.innerWidth), 0, 1);
    targetPY = clamp(e.clientY / Math.max(1, window.innerHeight), 0, 1);
  }, { passive:true });

  window.addEventListener('touchmove', (e)=>{
    const t = e.touches && e.touches[0];
    if(!t) return;
    targetPX = clamp(t.clientX / Math.max(1, window.innerWidth), 0, 1);
    targetPY = clamp(t.clientY / Math.max(1, window.innerHeight), 0, 1);
  }, { passive:true });

  window.addEventListener('scroll', ()=>{
    scrollBoost = 1;
  }, { passive:true });

  // burst on background click (ignore buttons/links/inputs)
  document.addEventListener('pointerdown', (e)=>{
    if(e.target && e.target.closest && e.target.closest('button,a,input,textarea,select,[role="button"]')) return;
    burst(0.95);
  }, { passive:true });

  // ---------- Modes + Morph (glitch-transform) ----------
  const WEIGHTS = [
    { key:'logo', w: 0.46 },
    { key:'key',  w: 0.46 },
    { key:'01',   w: 0.04 },
    { key:'02',   w: 0.04 },
  ];
  function pickMode(){
    const sum = WEIGHTS.reduce((a,b)=>a+b.w,0);
    let r = Math.random()*sum;
    for(const it of WEIGHTS){
      r -= it.w;
      if(r <= 0) return it.key;
    }
    return 'key';
  }

  let mode = 'logo';
  let nextMode = 'key';

  let t0 = performance.now();
  let last = t0;

  // transition state
  let inTrans = false;
  let tTransStart = 0;
  let tTransDur = 0.38;
  let transSeed = Math.random()*9999;

  // jitter state (held, sharp)
  let jx=0, jy=0, jr=0, tJitNext=0;

  // extra burst intensity (decays)
  let burstPow = 0;

  function burst(p=1){
    burstPow = Math.max(burstPow, clamp(p,0,1));
    // also force a strong transition soon
    if(!inTrans && uiState === 'intro'){
      scheduleNext(performance.now());
    }
  }

  
  function scheduleTo(target, nowMs, dur){
    nextMode = target;

    transSeed = Math.random()*9999;
    inTrans = true;
    tTransStart = (nowMs - t0) / 1000;

    // quick but readable
    tTransDur = (dur != null) ? dur : (prefersReduced ? 0.50 : (0.28 + Math.random()*0.22));
  }

  function scheduleNext(nowMs){
    if(uiState === 'manifesto') return;

    // set next mode and begin transition
    let nm = pickMode();
    // avoid repeating too often
    if(nm === mode && Math.random() < 0.65) nm = (mode === 'logo') ? 'key' : 'logo';

    scheduleTo(nm, nowMs);
  }

  function setUIState(next){
    if(next !== 'intro' && next !== 'manifesto') return;
    if(next === uiState) return;

    // snap out of any running transition for instant response
    if(inTrans){
      mode = nextMode;
      inTrans = false;
    }

    uiState = next;
    setToggleState();

    const now = performance.now();
    if(uiState === 'manifesto'){
      scheduleTo('manifesto', now, prefersReduced ? 0.55 : 0.42);
      burst(1);
    }else{
      scheduleTo('key', now, prefersReduced ? 0.50 : 0.34);
      burst(0.85);
    }
  }

  function toggleUI(){
    setUIState(uiState === 'manifesto' ? 'intro' : 'manifesto');
  }



  function updateJitter(t, intensity){
    if(t >= tJitNext){
      const amp = prefersReduced ? 2.0 : (4 + intensity*14);
      jx = (Math.random()*2 - 1) * amp;
      jy = (Math.random()*2 - 1) * amp;
      jr = (Math.random()*2 - 1) * (0.018 + intensity*0.030);
      tJitNext = t + (prefersReduced ? 0.24 : (0.08 + Math.random()*0.16));
    }
  }

  function easeOutCubic(x){
    x = clamp(x,0,1);
    return 1 - Math.pow(1 - x, 3);
  }

  // Render each mode into a target ctx (scene-size)
  function renderMode(ctx2d, key, t, cx, cy, driftX, driftY, rot, intensity, imgs){
    const { imgLogo, img01, img02 } = imgs;

    // base
    ctx2d.clearRect(0,0,SW(),SH());
    ctx2d.fillStyle = '#fff';
    ctx2d.fillRect(0,0,SW(),SH());

    // rings always behind (tied to pointer)
    if(!prefersReduced){
      drawRings(ctx2d, cx, cy, t, intensity);
    }

    // Sizes in scene space
    const logoW = Math.min(SW()*0.34, 480);
    const logoH = logoW * (imgLogo && imgLogo.naturalWidth ? (imgLogo.naturalHeight/imgLogo.naturalWidth) : 1);
    const capW  = Math.min(SW()*0.66, 860);
    const capW02 = capW * 0.86; // make 02.png slightly smaller (visual balance)
    const cap01H= capW  * (img01 && img01.naturalWidth ? (img01.naturalHeight/img01.naturalWidth) : 0.18);
    const cap02H= capW02 * (img02 && img02.naturalWidth ? (img02.naturalHeight/img02.naturalWidth) : 0.18);
    const fontSize = Math.max(24, Math.min(76, SW()*0.070));

    // “interaction” layering: each mode still hints the other (ghost)
    const ghost = 0.14 + intensity*0.06;

    if(key === 'logo'){
      drawCenteredImage(ctx2d, imgLogo, cx + driftX*0.65, cy + Math.min(logoH*0.06, 38) + driftY*0.55 - 30, logoW, logoH, rot, 1);
      // faint key text behind like a signal
      drawText(ctx2d, 'item_key', cx + driftX*0.30, cy + driftY*0.30, fontSize*0.9, ghost, Math.sin(t*7)*0.02);
    }else if(key === 'key'){
      // key text main
      drawText(ctx2d, 'item_key', cx + driftX*0.75, cy + driftY*0.75, fontSize, 1, Math.sin(t*11)*0.03);
      // ghost logo behind
      drawCenteredImage(ctx2d, imgLogo, cx + driftX*0.30, cy - Math.min(logoH*0.08, 45) + driftY*0.25, logoW*0.92, logoH*0.92, rot*0.55, ghost);
    }else if(key === '01'){
      drawCenteredImage(ctx2d, img01, cx + driftX*0.9, cy + driftY*0.9, capW, cap01H, -rot*0.6, 1);
      drawCenteredImage(ctx2d, imgLogo, cx + driftX*0.10, cy - Math.min(logoH*0.06, 35) + driftY*0.10, logoW*0.78, logoH*0.78, rot*0.4, ghost);
    }else if(key === '02'){
      drawCenteredImage(ctx2d, img02, cx + driftX*0.9, cy + driftY*0.9, capW02, cap02H, -rot*0.6, 1);
      drawText(ctx2d, 'item_key', cx + driftX*0.15, cy + driftY*0.15, fontSize*0.9, ghost, Math.sin(t*8)*0.02);
    }

    else if(key === 'manifesto'){
      // Desktop-like typography on phones (it will still naturally scale down with screen width).
      const maxW = SW() * 0.86;
      const maxH = SH() * 0.72;

      const baseSize = Math.min(34, Math.max(16, SW() * 0.036));
const layout = layoutBlock(ctx2d, MANIFESTO_TEXT, maxW, maxH, baseSize);

      const lines = layout.lines;
      const fs = layout.size;
      const lh = layout.lh;

      const y0 = cy - ((lines.length - 1) * lh) / 2;

      const skew0 = Math.sin(t * 8.5) * 0.012;

      for(let i=0; i<lines.length; i++){
        const line = lines[i];
        if(!line) continue;
        const yLine = y0 + i * lh;

        // ghost passes
        drawText(ctx2d, line, cx + driftX*0.08 + 1, yLine + driftY*0.08 - 1, fs, 0.18 + intensity*0.08,  skew0*1.2);
        drawText(ctx2d, line, cx + driftX*0.08 - 1, yLine + driftY*0.08 + 1, fs, 0.10 + intensity*0.06, -skew0*1.1);

        // main
        drawText(ctx2d, line, cx + driftX*0.12, yLine + driftY*0.12, fs, 1, skew0 + Math.sin(t*14 + i)*0.010);
      }

    }
  }

  function morphTransform(p, intensity){
    // p: 0..1
    const w = SW(), h = SH();

    // start with source as base
    sctx.clearRect(0,0,w,h);
    sctx.globalAlpha = 1;
    sctx.drawImage(bufA, 0, 0);

    // glitch-reveal destination via bands + noise threshold
    const bands = 18 + Math.floor(intensity*14);
    for(let b=0; b<bands; b++){
      const r1 = hash01(transSeed + b*17.1);
      const r2 = hash01(transSeed + b*31.9);
      const r3 = hash01(transSeed + b*77.7);

      const y  = r1 * h;
      const sh = 2 + r2 * (10 + intensity*30);

      // reveal threshold - as p increases, more bands flip
      const thresh = 0.15 + r3*0.75;
      const reveal = (p > thresh) ? 1 : 0;

      // offsets collapse as p -> 1 (so it "converges" into new form)
      const dx = (hash01(transSeed + b*9.7)*2 - 1) * (22 + intensity*105) * (1 - p);
      const wob = Math.sin((p*6 + b)*2.1) * (4 + intensity*12) * (1 - p);

      if(reveal){
        // bring in destination slice
        sctx.drawImage(bufB, 0, y, w, sh, dx, y + wob, w, sh);
      }else{
        // distort source slice while waiting
        const sdx = (hash01(transSeed + b*41.4)*2 - 1) * (16 + intensity*90) * (p);
        sctx.drawImage(bufA, 0, y, w, sh, sdx, y - wob*0.6, w, sh);
      }
    }

    // add a smearing "datamosh" feel during mid-transition
    if(p < 0.92){
      sctx.save();
      sctx.globalCompositeOperation = 'multiply';
      sctx.globalAlpha = 0.08 + intensity*0.12;
      const sm = (1 - p) * (7 + intensity*45);
      for(let k=0;k<3;k++){
        const ox = (Math.random()*2-1)*sm;
        const oy = (Math.random()*2-1)*sm*0.35;
        sctx.drawImage(bufB, ox, oy);
      }
      sctx.restore();
    }

    // settle: gentle full overlay of destination near the end
    sctx.save();
    sctx.globalAlpha = clamp(Math.pow(p, 1.8), 0, 1);
    sctx.drawImage(bufB, 0, 0);
    sctx.restore();
  }

  // ---------- Main loop ----------
  let imgLogo=null, img01=null, img02=null;

  function frame(now){
    const t = (now - t0) / 1000;
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    // smooth pointer
    px += (targetPX - px) * (prefersReduced ? 0.06 : 0.10);
    py += (targetPY - py) * (prefersReduced ? 0.06 : 0.10);

    // intensity
    const breath = 0.5 + 0.5*Math.sin(t*0.9);
    const hit = (Math.sin(t*4.8) > 0.90) ? 1 : 0;
    // scroll -> short boost
    scrollBoost = Math.max(0, scrollBoost - dt*1.6);
    burstPow = Math.max(0, burstPow - dt*0.85);

    let intensity = prefersReduced ? 0.18 : (0.26 + breath*0.25 + hit*0.25 + scrollBoost*0.15 + burstPow*0.38);
    intensity = clamp(intensity, 0, 1);
    if(uiState === 'manifesto'){
      intensity = clamp(0.18 + intensity*0.55, 0, 1);
    }


    // make motion less smooth: quantize time
    const qt = prefersReduced ? t : (Math.floor(t*14) / 14);

    updateJitter(t, intensity);

    // center moves with pointer (interaction between elements/background)
    const cx = SW() * (0.5 + (px - 0.5)*0.12);
    const cy = SH() * (0.5 + (py - 0.5)*0.10);

    // base drift + jitter
    const driftX = (Math.sin(qt*1.0)*6 + Math.sin(qt*6.2)*2) + jx;
    const driftY = (Math.cos(qt*0.9)*5 + Math.cos(qt*5.9)*2) + jy;
    const rot = (Math.sin(qt*0.65)*0.02 + Math.sin(qt*3.0)*0.01) + jr;

    const imgs = { imgLogo, img01, img02 };

    // schedule mode changes periodically (logo/key often; 01/02 rare)
    // if no transition active and time since last change is large -> schedule
    if(!inTrans && uiState === 'intro'){
      // random chance to switch (more often when intensity high)
      if(HEAVY_FX && !prefersReduced && Math.random() < (0.004 + intensity*0.006)){
        scheduleNext(now);
      }
    }

    if(inTrans){
      const pRaw = (t - tTransStart) / Math.max(0.001, tTransDur);
      const p = easeOutCubic(pRaw);

      // render source and destination into buffers
      renderMode(actx, mode, qt, cx, cy, driftX, driftY, rot, intensity, imgs);
      renderMode(bctx, nextMode, qt, cx, cy, driftX, driftY, rot, intensity, imgs);

      // morph-transform into scene
      morphTransform(p, intensity);

      // heavier slice glitch during transform
      if(HEAVY_FX && !prefersReduced && Math.random() < (0.16 + intensity*0.18)){
        sliceGlitch(sctx, scene, SW(), SH(), intensity, transSeed + qt*10.0);
      }

      if(pRaw >= 1){
        mode = nextMode;
        inTrans = false;
        // short burst after settle
        burstPow = Math.max(burstPow, 0.22);
      }
    }else{
      // normal render into scene
      renderMode(sctx, mode, qt, cx, cy, driftX, driftY, rot, intensity, imgs);

      // random micro-glitches to feel alive
      if(HEAVY_FX && !prefersReduced && Math.random() < (0.06 + intensity*0.12)){
        sliceGlitch(sctx, scene, SW(), SH(), intensity, qt*19.0 + Math.random()*999);
      }
    }

    // Postprocess on scene (low-res): dither + grain + scanlines
    if(POST_FX){
      const id = sctx.getImageData(0,0,SW(),SH());
      ditherBWSelective(id, 0.52 + intensity*0.22);
      addGrain(id, 0.10 + intensity*0.18);
      sctx.putImageData(id, 0, 0);

      // scanlines (stronger, but low-res keeps it nice)
      sctx.save();
      sctx.globalCompositeOperation = 'multiply';
      sctx.globalAlpha = 0.06 + intensity*0.06;
      for(let y=0; y<SH(); y+=3){
        const a = (Math.sin(qt*22 + y*0.12) + 1) * 0.5;
        sctx.fillStyle = `rgba(0,0,0,${0.12*a})`;
        sctx.fillRect(0, y, SW(), 1);
      }
      sctx.restore();
    }

    // draw scene -> main canvas (scaled up, crisp)
    ctx.save();
    ctx.clearRect(0,0,W(),H());
    ctx.imageSmoothingEnabled = OUTPUT_SMOOTH ? true : false;
    ctx.drawImage(scene, 0, 0, SW(), SH(), 0, 0, W(), H());

    // occasional hard "frame tear"
    if(HEAVY_FX && !prefersReduced && Math.random() < (0.015 + intensity*0.025)){
      ctx.globalAlpha = 0.08 + intensity*0.06;
      ctx.globalCompositeOperation = 'multiply';
      const tearY = Math.random()*H();
      ctx.drawImage(canvas, 0, tearY, W(), 12, (Math.random()*2-1)*50, tearY, W(), 12);
    }

    ctx.restore();

    requestAnimationFrame(frame);
  }

  async function start(){
    fitCanvas();
    window.addEventListener('resize', fitCanvas, { passive:true });

    [imgLogo, img01, img02] = await Promise.all([
      loadImageWithFallback(fallbacks('logo_item.png')),
      loadImageWithFallback(fallbacks('01.png')),
      loadImageWithFallback(fallbacks('02.png')),
    ]);

    // start with an immediate morph so it feels like "birth"
    mode = 'logo';
    scheduleTo('key', performance.now(), prefersReduced ? 0.55 : 0.36);

    requestAnimationFrame(frame);
  }

  start();
})();
</script>


<script>
(function(){
  const overlay = document.getElementById('devOverlay');
  const btnBack = document.getElementById('devOverlayBack');
  const textEl = document.getElementById('devOverlayText');
  if(!overlay || !btnBack) return;

  let lastFocus = null;

  function openOverlay(forKey){
    lastFocus = document.activeElement;

    // Message can be slightly different per section (optional)
    const map = {
      'item-security': 'item-security сейчас в разработке. Доступ закован. Возвращайся позже.',
      'item-soft': 'item-soft сейчас в разработке. Инструменты ещё не заточены. Возвращайся позже.'
    };
    if(textEl) textEl.textContent = map[forKey] || 'Этот отсек ещё не ожил. Возвращайся позже.';

    overlay.classList.add('is-open');
    overlay.setAttribute('aria-hidden', 'false');

    // prevent background scroll while overlay is open
    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';

    // focus back button
    btnBack.focus({ preventScroll:true });
  }

  function closeOverlay(){
    overlay.classList.remove('is-open');
    overlay.setAttribute('aria-hidden', 'true');

    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';

    if(lastFocus && typeof lastFocus.focus === 'function'){
      lastFocus.focus({ preventScroll:true });
    }
  }

  // Close when clicking outside window
  overlay.addEventListener('pointerdown', (e)=>{
    const doc = e.target && e.target.closest ? e.target.closest('.dev-window') : null;
    if(!doc) closeOverlay();
  });

  btnBack.addEventListener('click', closeOverlay);

  window.addEventListener('keydown', (e)=>{
    if(!overlay.classList.contains('is-open')) return;
    if(e.key === 'Escape'){
      e.preventDefault();
      closeOverlay();
    }
  });

  // Intercept those menu links
  function hookLink(hrefKey){
    const link = document.querySelector(`a.rail-link[href="${hrefKey}.html"], a.rail-link[href="${hrefKey}.html#"], a.rail-link[href="${hrefKey}.html?"]`);
    // More robust: find by title text if href changes
    const link2 = link || Array.from(document.querySelectorAll('a.rail-link')).find(a=>{
      const t = a.querySelector('.rail-link__title');
      return (t && t.textContent.trim() === hrefKey) || (a.getAttribute('href') || '').includes(hrefKey);
    });
    if(!link2) return;

    link2.addEventListener('click', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      openOverlay(hrefKey);
    });
  }
})();
</script>

</body>
</html>
