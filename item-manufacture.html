<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Item Key — item-manufacture</title>
  <link rel="stylesheet" href="assets/css/styles.css" />

  <!-- extra shop polish: product modal + gallery -->
<style>
  /* ===== Product modal (details) — responsive & no-cut ===== */
  body.modal-lock { overflow: hidden; }

  .pmodal{
    position: fixed;
    inset: 0;
    z-index: 20;
    display: grid;
    place-items: center;
    padding: clamp(10px, 2.2vw, 22px);
    background: rgba(255,255,255,.70);
    backdrop-filter: blur(6px);
  
    /* subtle gothic motion */
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transition: opacity .24s ease, visibility 0s linear .24s;
  }
  .pmodal[data-open="true"]{
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transition: opacity .24s ease;
  }
  
    /* Key fix:
     The old gallery used aspect-ratio: 4/5, so on wide screens it became TOO TALL and got cut.
     Now the modal has a fixed viewport-based height, and the gallery scales INSIDE it. */
  .pmodal__card{
    width: min(1040px, 96vw);
    height: min(92vh, 780px);
    max-height: 92vh;
    overflow: hidden;
    border: 1px solid rgba(0,0,0,.14);
    background: rgba(255,255,255,.95);
    display: grid;
    grid-template-rows: auto 1fr;
    min-height: 0;
  }

  .pmodal__head{
    display:flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    padding: clamp(10px, 2vh, 14px) clamp(12px, 2.4vw, 16px);
    border-bottom: 1px solid rgba(0,0,0,.08);
  }
  .pmodal__title{
    display: grid;
    gap: 6px;
  }
  .pmodal__title h3{
    margin: 0;
    font-size: 12px;
    letter-spacing: 4px;
    text-transform: uppercase;
  }
  .pmodal__title .sub{
    font-size: 10px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: rgba(0,0,0,.55);
  }

  .pmodal__actions{
    display:flex;
    gap: 10px;
    align-items:center;
    flex: 0 0 auto;
  }

  .pmodal__body{
    padding: clamp(10px, 2.2vw, 16px);
    overflow: hidden;            /* <- no vertical scrolling in normal cases */
    display: grid;
    grid-template-columns: 1.15fr .85fr;
    gap: clamp(10px, 2vw, 16px);
    min-height: 0;
    align-items: stretch;
  }

  /* gallery */
  .gallery{
    border: 1px solid rgba(0,0,0,.10);
    background: rgba(255,255,255,.86);
    overflow: hidden;
    display: grid;
    grid-template-rows: 1fr auto; /* main takes remaining height */
    min-height: 0;
  }

  .gallery__main{
    /* IMPORTANT: removed aspect-ratio so it won't grow too tall on wide screens */
    border-bottom: 1px solid rgba(0,0,0,.08);
    background: linear-gradient(180deg, rgba(0,0,0,.018), transparent 60%);
    display:grid;
    place-items:center;
    min-height: 0;
    border-bottom: 1px solid rgba(0,0,0,.08);
    background: linear-gradient(180deg, rgba(0,0,0,.018), transparent 60%);
    display:flex;
    align-items:center;
    justify-content:center;
    min-height: 0;
    overflow: hidden;
  }
  .gallery__main img{
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    display:block;
  }
  .gallery__main .placeholder{
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: rgba(0,0,0,.45);
    padding: 24px 12px;
    text-align:center;
  }

  /* thumbs fit in 1–2 rows, without scrolling */
  .gallery__thumbs{
    --thumb: clamp(46px, 6.5vw, 64px);
    display:flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 10px;
    overflow: hidden; /* <- no scrolling */
    border-top: 1px solid rgba(0,0,0,.05);
    background: rgba(255,255,255,.78);
    max-height: calc(var(--thumb) * 2 + 8px); /* two rows */
    align-content: flex-start;
  }
  .thumb{
    flex: 0 0 auto;
    width: var(--thumb);
    height: var(--thumb);
    border: 1px solid rgba(0,0,0,.10);
    background: rgba(255,255,255,.85);
    cursor: pointer;
    display:grid;
    place-items:center;
    overflow:hidden;
    user-select:none;
  }
  .thumb img{
    width: 100%;
    height: 100%;
    object-fit: cover;
    display:block;
  }
  .thumb[data-active="true"]{
    border-color: rgba(0,0,0,.26);
    background: rgba(255,255,255,.96);
  }

  /* info */
  .pinfo{
    border: 1px solid rgba(0,0,0,.10);
    background: rgba(255,255,255,.86);
    padding: clamp(12px, 2.2vw, 14px);
    display:grid;
    gap: 12px;
    align-content: start;
    min-height: 0;
  }
  .pinfo__top{
    display:flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 10px;
    min-width: 0;
  }
  .pinfo__price{
    font-size: 12px;
    letter-spacing: 2.2px;
    white-space: nowrap;
  }

  /* clamp description so the whole modal always fits */
  .pinfo__desc{
    margin: 0;
    font-size: clamp(11px, 1.2vw, 12.5px);
    color: rgba(0,0,0,.72);
    line-height: 1.45;
    white-space: pre-wrap;

    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 9;
    line-clamp: 9;
    overflow: hidden;
  }

  .pinfo__actions{
    display:flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items:center;
    padding-top: 2px;
  }

  /* cards: strictly marketplace summary */

  /* sold out badge (grid cards) */
  .card.card--shop{ position: relative; }
  .card__badge{
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 3px 8px;
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    border: 1px solid rgba(0,0,0,.16);
    background: rgba(255,255,255,.92);
    color: rgba(0,0,0,.72);
    pointer-events: none;
  }

  /* sold out label (product modal) */
  .pinfo__soldout{
    display: none;
    align-items: center;
    justify-content: center;
    padding: 10px 12px;
    border: 1px solid rgba(0,0,0,.16);
    background: rgba(255,255,255,.92);
    font-size: 11px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: rgba(0,0,0,.72);
    user-select: none;
  }

  .card.card--shop{
    cursor: pointer;
    transition: border-color .18s ease, transform .18s ease, opacity .18s ease;
  }
  .card.card--shop:hover{
    transform: translateY(-2px);
    border-color: rgba(0,0,0,.18);
    opacity: .98;
  }
  .card.card--shop .card__desc,
  .card.card--shop .card__meta,
  .card.card--shop .card__actions{
    display:none !important;
  }
  .card.card--shop .card__body{ gap: 6px; }

  /* stock divider (in stock / sold out) */
  .stock-sep{
    grid-column: 1 / -1;
    display:flex;
    align-items:center;
    gap: 12px;
    margin: 10px 0 6px;
    padding: 6px 2px;
    color: rgba(0,0,0,.62);
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    user-select: none;
  }
  .stock-sep::before,
  .stock-sep::after{
    content:"";
    height: 1px;
    flex: 1 1 auto;
    background: rgba(0,0,0,.10);
  }
  .stock-sep .t{
    white-space: nowrap;
  }

  /* mobile modal layout */
  @media (max-width: 980px){
    .pmodal__card{
      width: min(720px, 96vw);
      height: min(94vh, 980px);
    }
    .pmodal__body{ grid-template-columns: 1fr; }
    .pinfo__desc{ -webkit-line-clamp: 7; line-clamp: 7; }
    .gallery__thumbs{ max-height: calc(var(--thumb) * 2 + 8px); }
  }

  /* ultra-short screens: allow inner scroll to avoid any “cut” */
  @media (max-height: 560px){
    .pmodal__card{ height: 96vh; }
    .pmodal__body{ overflow: auto; } /* only here */
  }

/* ===== Gothic motion add-ons (subtle, non-intrusive) ===== */
.pmodal__card{
  transform: translateY(10px) scale(.985);
  opacity: 0;
  transition: transform .24s ease, opacity .24s ease;
  will-change: transform, opacity;
}
.pmodal[data-open="true"] .pmodal__card{
  transform: translateY(0) scale(1);
  opacity: 1;
}

/* grid + category switching */
@keyframes gridIn {
  from { opacity: 0; transform: translateY(6px); filter: blur(2px); }
  to   { opacity: 1; transform: translateY(0);   filter: blur(0); }
}
.grid.grid--anim{
  animation: gridIn .24s ease;
}

@keyframes chipSelect{
  from { transform: translateY(1px); filter: blur(1px); opacity: .86; }
  to   { transform: translateY(0);   filter: blur(0);   opacity: 1; }
}
.chip[data-active="true"]{
  animation: chipSelect .22s ease;
}

/* buttons */
@keyframes btnConfirm{
  0%   { transform: scale(1);   filter: blur(0); }
  45%  { transform: scale(1.03); filter: blur(.2px); }
  100% { transform: scale(1);   filter: blur(0); }
}
.btn.btn--added{
  animation: btnConfirm .35s ease;
}

/* cart: animate whatever base styles change (transform/opacity/etc.) */
.cart{
  transition: transform .28s ease, opacity .28s ease, filter .28s ease;
  will-change: transform, opacity;
}
@keyframes cartPulse{
  0%   { filter: blur(0); }
  55%  { filter: blur(.35px); }
  100% { filter: blur(0); }
}
.cart.cart--pulse{
  animation: cartPulse .55s ease;
}

/* cart: payment channel button */
.cart__pay{
  margin-top: 10px;
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  flex-wrap: wrap;
}
@media (max-width: 520px){
  .cart__pay .btn{ width: 100%; }
}

@keyframes panelIn{
  from { opacity: 0; transform: translateY(8px); filter: blur(2px); }
  to   { opacity: 1; transform: translateY(0);  filter: blur(0); }
}
.home-panel.home--anim,
.market-toolbar.market--anim,
.chips.chips--anim{
  animation: panelIn .26s ease;
}

/* accessibility */
@media (prefers-reduced-motion: reduce){
  *, *::before, *::after{
    animation: none !important;
    transition: none !important;
    scroll-behavior: auto !important;
  }
}

/* ===== Layout immunity (no overlap with edge bars) =====
   Fixes: footer "manufacture · marketplace • pre-alpha" overlapping cards
   by reserving safe space for top/bottom edge bars on ANY screen size. */
.page-manufacture{
  --edge-top-space: clamp(56px, 7vh, 96px);
  --edge-bottom-space: clamp(56px, 7vh, 96px);
}
.page-manufacture .center-stage{
  /* keep your structure, just add safe padding so fixed bars never sit on content */
  padding-top: calc(var(--edge-top-space) + env(safe-area-inset-top, 0px)) !important;
  padding-bottom: calc(var(--edge-bottom-space) + env(safe-area-inset-bottom, 0px)) !important;
  box-sizing: border-box;
  min-height: 100svh;
}
.page-manufacture .shop-body{
  /* extra safety for long grids */
  padding-bottom: calc(var(--edge-bottom-space) + env(safe-area-inset-bottom, 0px)) !important;
}

/* If edge bars are fixed/absolute in the global CSS, keep them on top but non-destructive */
.page-manufacture .topbar.topbar--edge,
.page-manufacture .bottombar.bottombar--edge{
  z-index: 12;
}

/* Prevent text wrapping from unexpectedly growing the bottom bar into content */
.page-manufacture .bottombar .hint{
  white-space: nowrap;
}
@media (max-width: 520px){
  .page-manufacture .bottombar{
    flex-wrap: wrap;
    row-gap: 6px;
  }
  .page-manufacture .bottombar .hint{
    white-space: normal;
  }
}

/* ===== Image manager (admin) ===== */
.imgmgr{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.86);
  padding: 12px;
  display: grid;
  gap: 10px;
}
.imgmgr__head{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
  flex-wrap: wrap;
}
.imgmgr__title{
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.75);
}
.imgmgr__actions{
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items:center;
}
.imgmgr__grid{
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(86px, 1fr));
  gap: 10px;
}
.imgtile{
  position: relative;
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.90);
  overflow: hidden;
  aspect-ratio: 1 / 1;
  cursor: pointer;
  display:grid;
  place-items:center;
}
.imgtile img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display:block;
}
.imgtile__badge{
  position:absolute;
  left: 8px;
  bottom: 8px;
  padding: 2px 6px;
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  border: 1px solid rgba(0,0,0,.14);
  background: rgba(255,255,255,.92);
  color: rgba(0,0,0,.70);
}
.imgtile__remove{
  position:absolute;
  right: 6px;
  top: 6px;
  width: 26px;
  height: 26px;
  border-radius: 999px;
  border: 1px solid rgba(0,0,0,.14);
  background: rgba(255,255,255,.92);
  color: rgba(0,0,0,.75);
  display:grid;
  place-items:center;
  cursor:pointer;
}
.imgtile__remove:hover{ background: rgba(255,255,255,1); }
.imgmgr__empty{
  padding: 12px 10px;
  border: 1px dashed rgba(0,0,0,.14);
  color: rgba(0,0,0,.55);
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
}

/* ===== UI Confirm modal (site-styled, replaces browser confirm) ===== */
.uimodal{
  position: fixed;
  inset: 0;
  z-index: 30;
  display: grid;
  place-items: center;
  padding: clamp(10px, 2.2vw, 22px);
  background: rgba(255,255,255,.70);
  backdrop-filter: blur(6px);
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity .22s ease, visibility 0s linear .22s;
}
.uimodal[data-open="true"]{
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
  transition: opacity .22s ease;
}
.uimodal__card{
  width: min(560px, 94vw);
  border: 1px solid rgba(0,0,0,.14);
  background: rgba(255,255,255,.95);
  overflow: hidden;
  transform: translateY(10px) scale(.985);
  opacity: 0;
  transition: transform .22s ease, opacity .22s ease;
  will-change: transform, opacity;
}
.uimodal[data-open="true"] .uimodal__card{
  transform: translateY(0) scale(1);
  opacity: 1;
}
.uimodal__head{
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap: 10px;
  padding: 12px 14px;
  border-bottom: 1px solid rgba(0,0,0,.08);
}
.uimodal__head h3{
  margin: 0;
  font-size: 12px;
  letter-spacing: 4px;
  text-transform: uppercase;
}
.uimodal__text{
  margin: 0;
  padding: 14px;
  font-size: 12px;
  color: rgba(0,0,0,.72);
  line-height: 1.45;
}
.uimodal__actions{
  display:flex;
  justify-content: flex-end;
  gap: 10px;
  padding: 12px 14px;
  border-top: 1px solid rgba(0,0,0,.08);
  flex-wrap: wrap;
}

/* Toast (quiet, gothic) */
.uitoast{
  position: fixed;
  left: 50%;
  bottom: clamp(14px, 3.2vh, 26px);
  transform: translateX(-50%);
  z-index: 40;
  display: grid;
  gap: 8px;
  pointer-events: none;
}
.uitoast__msg{
  pointer-events: none;
  border: 1px solid rgba(0,0,0,.14);
  background: rgba(255,255,255,.92);
  padding: 10px 12px;
  font-size: 11px;
  letter-spacing: 1.2px;
  color: rgba(0,0,0,.78);
  opacity: 0;
  transform: translateY(8px);
  filter: blur(1px);
  transition: opacity .22s ease, transform .22s ease, filter .22s ease;
}
.uitoast__msg[data-show="true"]{
  opacity: 1;
  transform: translateY(0);
  filter: blur(0);
}

/* ===== SET category (special) ===== */
#setPickerWrap{ display:none; }
#clothForm.is-set-mode #setPickerWrap{ display:block; }
#clothForm.is-set-mode .set-hide{ display:none !important; }
.set-only{ display:none; }

.setpicker{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.86);
  padding: 12px;
  display: grid;
  gap: 10px;
}
.setpicker__title{
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.75);
}
.setpicker__grid{
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 10px;
}
.settile{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.90);
  overflow: hidden;
  cursor: pointer;
  user-select:none;
  display:grid;
  grid-template-rows: 96px auto;
}
.settile__img{
  background: linear-gradient(180deg, rgba(0,0,0,.018), transparent 60%);
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
.settile__img img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display:block;
}
.settile__body{
  padding: 10px;
  display:grid;
  gap: 6px;
}
.settile__name{
  font-size: 11px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: rgba(0,0,0,.78);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.settile__meta{
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: rgba(0,0,0,.55);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.settile__check{
  display:flex;
  gap: 8px;
  align-items:center;
  font-size: 11px;
  color: rgba(0,0,0,.70);
}
.settile input{ accent-color: rgba(0,0,0,.72); }

/* product modal: set items strip */
.pset{
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0,0,0,.08);
  display:grid;
  gap: 10px;
}
.pset__title{
  font-size: 11px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.70);
}
.pset__grid{
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(96px, 1fr));
  gap: 10px;
}
.pset__item{
  border: 1px solid rgba(0,0,0,.10);
  background: rgba(255,255,255,.90);
  overflow:hidden;
  cursor:pointer;
  display:grid;
  grid-template-rows: 86px auto;
}
.pset__item img{
  width: 100%;
  height: 100%;
  object-fit: cover;
  display:block;
}
.pset__item .t{
  padding: 8px;
  font-size: 10px;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: rgba(0,0,0,.72);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}



/* ===== TAPE category (video) — gothic clean (no black bars), custom controls, loop, single playback ===== */
.tape-panel{
  display:none;
  position: relative;
  background: #fff;
  border: 1px solid #000;
  padding: clamp(12px, 2.2vw, 18px);
}

/* double-frame like the rest of the site */
.tape-panel::before{
  content:"";
  position:absolute;
  inset: 7px;
  border: 1px solid rgba(0,0,0,.38);
  pointer-events:none;
}
.tape-panel > *{ position: relative; z-index: 1; }

.tape-title{
  display:flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 12px;
  padding-bottom: 10px;
  margin-bottom: 14px;
  border-bottom: 1px dashed rgba(0,0,0,.35);
}
.tape-title h2{
  margin: 0;
  font-size: 12px;
  letter-spacing: 6px;
  text-transform: uppercase;
}
.tape-title .sub{
  font-size: 10px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: rgba(0,0,0,.60);
  white-space: nowrap;
}

.tape-grid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: clamp(10px, 2vw, 16px);
  align-items: start;
}

.tape-card{
  border: 1px solid #000;
  background: #fff;
}

.tape-card__head{
  display:flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(0,0,0,.22);
  font-size: 10px;
  letter-spacing: 3.5px;
  text-transform: uppercase;
}

.tape-card__head .meta{
  font-size: 10px;
  letter-spacing: 2.8px;
  color: rgba(0,0,0,.55);
  white-space: nowrap;
}

.tape-wrap{
  --ar: 16 / 9;
}
.tape-wrap[data-orient="v"]{
  --ar: 9 / 16;
}

.tape-frame{
  position: relative;
  background: #fff;
  border-bottom: 1px solid rgba(0,0,0,.22);
  aspect-ratio: var(--ar);
  overflow: hidden;
}

/* sharp inner frame */
.tape-frame::before{
  content:"";
  position:absolute;
  inset: 10px;
  border: 1px solid rgba(0,0,0,.22);
  pointer-events:none;
}

/* video itself */
.tape-video{
  width: 100%;
  height: 100%;
  display:block;
  object-fit: contain;
  background: #fff; /* NO black */
}

/* start overlay (only while paused) */
.tape-overlay{
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  gap: 10px;
  padding: 14px;
  background: rgba(255,255,255,.82);
  border: none;
  cursor: pointer;
  color: inherit;
  font: inherit;
  transition: transform .18s ease, opacity .18s ease;
}
.tape-overlay:hover{ transform: translateY(-1px); }

.tape-overlay .seal{
  display:grid;
  place-items:center;
  width: 54px;
  height: 54px;
  border-radius: 999px;
  border: 1px solid #000;
  background: #fff;
}
.tape-overlay .seal::before{
  content:"▶";
  font-size: 18px;
  margin-left: 2px;
}
.tape-overlay .t{
  font-size: 10px;
  letter-spacing: 3.5px;
  text-transform: uppercase;
  text-align:center;
}
.tape-overlay .s{
  font-size: 10px;
  letter-spacing: 2.5px;
  color: rgba(0,0,0,.60);
  text-align:center;
}
.tape-wrap[data-playing="true"] .tape-overlay{
  opacity: 0;
  pointer-events: none;
  transform: translateY(2px);
}

/* custom controls */
.tape-controls{
  display:flex;
  align-items:center;
  gap: 8px;
  padding: 8px 10px;
  background:#fff;
  font-size: 10px;
  letter-spacing: 2.2px;
  text-transform: uppercase;
}
.tape-btn{
  border: 1px solid #000;
  background:#fff;
  padding: 6px 8px;
  cursor: pointer;
  font: inherit;
  letter-spacing: inherit;
  text-transform: inherit;
}
.tape-btn:active{ transform: translateY(1px); }

.tape-seek{
  flex: 1;
  min-width: 120px;
  accent-color: #000;
}
.tape-time{
  color: rgba(0,0,0,.65);
  white-space: nowrap;
  font-variant-numeric: tabular-nums;
}

/* note */
.tape-footnote{
  margin-top: 12px;
  padding-top: 10px;
  border-top: 1px dashed rgba(0,0,0,.35);
  font-size: 11px;
  letter-spacing: 1.2px;
  color: rgba(0,0,0,.62);
  line-height: 1.45;
}

@media (max-width: 980px){
  .tape-grid{ grid-template-columns: 1fr; }
  .tape-controls{ gap: 6px; }
  .tape-seek{ min-width: 90px; }
}

@media (prefers-reduced-motion: reduce){
  .tape-overlay{ transition: none !important; }
}


/* ===== SET cards (category: set) ===== */
.card--set .card__body{display:none !important;}
.card--set .card__top{display:none !important;}
.card--set{cursor:pointer;}
</style>

<style id="homeConsoleStyles">
  /* ========== HOME CONSOLE (дом) : full-bleed console, no рамки ========== */
  .home-console{
    position: relative;
    width: 100%;
    min-height: 70vh;
    overflow: hidden;
    background: #fff; /* clean white like the rest */
  }

  /* background FX canvas (this IS the background) */
  #homeConsoleFx{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
    pointer-events:none;
  }

  /* UI overlay (no box, no border) */
  .home-console__ui{
    position: relative;
    z-index: 2;
    height: 100%;
    padding: clamp(18px, 3.2vw, 34px);
    display:flex;
    align-items: stretch;
    justify-content: center;
  }

  .console-surface{
    width: min(1100px, 100%);
    min-height: 62vh;
    padding: 0;
    border: none;
    border-radius: 0;
    background: transparent;
    box-shadow: none;
    outline: none;

    display:flex;
    flex-direction: column;
    gap: 12px;
  }

  .console-topbar{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    flex-wrap: wrap;
    min-width: 0;
    padding: 0 0 10px 0;
    border-bottom: 1px dashed rgba(0,0,0,.16);
  }

  .console-badge,
  .console-status,
  .console-help,
  .console-hvatit,
  .cline{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    letter-spacing: .03em;
  }

  .console-badge{
    font-size: 12px;
    opacity: .95;
    text-transform: lowercase;
    min-width: 0;
    max-width: 100%;
    overflow-wrap: anywhere;
    word-break: break-word;
  }

  .console-status{
    font-size: 12px;
    opacity: .65;
    white-space: nowrap;
    min-width: 0;
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .console-lines{
    flex: 1;
    display:flex;
    flex-direction: column;
    gap: 6px;
    padding: 10px 0 6px 0;
    max-width: 100%;
  }

  .cline{
    font-size: 14px;
    line-height: 1.38;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    word-break: break-word;
    color: #000;
    opacity: .92;
    position: relative;
  }
  .cline.dim{ opacity: .72; }
  .cline.sep{ opacity: .55; }

  /* options feel like console lines (no cards) */
  .cline.option{
    cursor: pointer;
    padding: 4px 0 4px 18px;
    border: none;
    border-radius: 0;
    background: transparent;
    user-select: none;
  }
  .cline.option:hover{
    opacity: 1;
    background: rgba(0,0,0,.045);
  }
  .cline.option:hover::before{
    content: "▌";
    position: absolute;
    left: 0;
    top: 0;
    font-weight: 900;
    font-size: 18px;
    line-height: 1.05;
    opacity: 1;
  }

  .cline.option.is-selected{
    opacity: 1;
    background: rgba(0,0,0,.045);
  }
  .cline.option.is-selected::before{
    content: "▌";
    position: absolute;
    left: 0;
    top: 0;
    font-weight: 900;
    font-size: 18px;
    line-height: 1.05;
    opacity: 1;
  }

  /* ready hint for commands (does not override keyboard selection) */
  .cline.option.is-ready{
    box-shadow: inset 0 -1px 0 rgba(0,0,0,.22);
  }

  /* footer */
  .console-footer{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 12px;
    padding-top: 12px;
    border-top: none;
  }

  .console-help{
    font-size: 12px;
    opacity: .68;
  }

  .console-hvatit{
    font-size: 12px;
    padding: 6px 10px;
    border-radius: 10px;
    border: 1px solid rgba(0,0,0,.18);
    background: rgba(255,255,255,.82);
    cursor: pointer;
  }
  .console-hvatit:hover{ background: rgba(0,0,0,.03); }

  /* ===== Glitch text like intro (subtle, atmospheric) ===== */
  .gtext{ position: relative; display:inline-block; }
  .gtext::before,
  .gtext::after{
    content: attr(data-text);
    position:absolute;
    left:0; top:0;
    width:100%;
    overflow:hidden;
    pointer-events:none;
    mix-blend-mode: multiply;
    opacity: .18;
  }
  .gtext::before{ transform: translate(0.7px,-0.5px); clip-path: inset(0 0 55% 0); }
  .gtext::after { transform: translate(-0.8px,0.6px); clip-path: inset(48% 0 0 0); opacity: .14; }

  @media (prefers-reduced-motion: no-preference){
    .gtext{
      animation: gJitter 3.6s infinite steps(1,end);
    }
    .gtext::before{
      animation: gSliceA 2.7s infinite steps(1,end);
    }
    .gtext::after{
      animation: gSliceB 3.1s infinite steps(1,end);
    }

    @keyframes gJitter{
      0%{ transform: translate(0,0); }
      10%{ transform: translate(0.2px,-0.2px); }
      18%{ transform: translate(-0.4px,0.2px); }
      26%{ transform: translate(0.4px,0.0px); }
      34%{ transform: translate(-0.2px,0.3px); }
      42%{ transform: translate(0.3px,-0.1px); }
      55%{ transform: translate(0,0); }
      100%{ transform: translate(0,0); }
    }
    @keyframes gSliceA{
      0%{ clip-path: inset(0 0 58% 0); }
      16%{ clip-path: inset(0 0 70% 0); }
      33%{ clip-path: inset(12% 0 52% 0); }
      50%{ clip-path: inset(0 0 62% 0); }
      66%{ clip-path: inset(6% 0 60% 0); }
      83%{ clip-path: inset(0 0 64% 0); }
      100%{ clip-path: inset(0 0 58% 0); }
    }
    @keyframes gSliceB{
      0%{ clip-path: inset(48% 0 0 0); }
      20%{ clip-path: inset(55% 0 0 0); }
      40%{ clip-path: inset(42% 0 0 0); }
      60%{ clip-path: inset(60% 0 0 0); }
      80%{ clip-path: inset(50% 0 0 0); }
      100%{ clip-path: inset(48% 0 0 0); }
    }
  }

  /* small "kick" on menu changes */
  .home--anim .console-surface{
    animation: homeKick .28s steps(1,end);
  }
  @keyframes homeKick{
    0%{ transform: translate(0,0); filter:none; }
    35%{ transform: translate(2px,-1px); filter: contrast(1.04); }
    70%{ transform: translate(-1px,1px); filter: contrast(1.06); }
    100%{ transform: translate(0,0); filter:none; }
  }

  /* Cursor */
  .cursor{
    display:inline-block;
    width: 10px;
    height: 1.15em;
    margin-left: 6px;
    vertical-align: -0.18em;
    background: rgba(0,0,0,.72);
    border-radius: 2px;
  }
  @media (prefers-reduced-motion: no-preference){
    .cursor{ animation: blink 1.05s steps(1,end) infinite; }
    @keyframes blink{ 0%,49%{opacity:1} 50%,100%{opacity:0} }
  }

  .type-line{
    min-height: 2.7em;
    padding: 6px 0;
  }
  .type-line.fade{
    animation: fadeOut .38s ease forwards;
  }
  @keyframes fadeOut{
    to{ opacity: 0; transform: translateY(-1px); }
  }

  .console-help:empty{ display:none; }

  @media (max-width: 520px){
    .cline{ font-size: 13px; letter-spacing: .02em; }
    .console-badge, .console-status{ font-size: 11px; }
  }
</style>

<style id="noScrollStyle" disabled>
  /* lock page scrolling: console uses arrows, site should not move */
  html, body{
    height: 100%;
    overflow: hidden !important;
    overscroll-behavior: none;
    -webkit-overflow-scrolling: auto;
  }
  body{
    position: fixed;
    inset: 0;
    width: 100%;
  }
</style>

  <!-- Mobile/performance optimizations -->
  <style>
    /* Mobile fit + safe areas (iOS notch, etc.) */
    html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
    body{
      padding-top: env(safe-area-inset-top);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* Make taps easier on small screens */
    a, button, [role="button"], input, select, textarea { scroll-margin-top: 84px; }
    button, .btn, a.btn { min-height: 44px; }

    /* Viewport height fixes on mobile browsers */
    .fullvh { min-height: 100svh; }

    /* Respect accessibility/performance settings */
    @media (prefers-reduced-motion: reduce){
      * { animation: none !important; transition: none !important; scroll-behavior: auto !important; }
    }
  </style>
  <!-- Mobile layout fix for category panel (tabs) + iOS button coloring -->
  <style id="mobileManufactureFix">
    /* --- iOS/Safari default blue buttons/links override (scoped to this page) --- */
    .page-manufacture .tabs .tab,
    .page-manufacture .chips .chip,
    .page-manufacture .btn,
    .page-manufacture .tape-btn,
    .page-manufacture .tape-overlay{
      -webkit-appearance: none;
      appearance: none;
      -webkit-tap-highlight-color: transparent;
      font: inherit;
      text-decoration: none;
      color: rgba(0,0,0,.86);
      -webkit-text-fill-color: rgba(0,0,0,.86); /* iOS fix */
    }
    .page-manufacture a,
    .page-manufacture a:visited{
      color: inherit;
      -webkit-text-fill-color: currentColor;
      text-decoration: none;
    }

    /* --- Desktop/tablet: keep layout stable even when widths get tight --- */
    .page-manufacture .shop-head__inner{ width: 100%; box-sizing: border-box; }
    .page-manufacture .shop-title{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .page-manufacture .shop-title .controls{
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .page-manufacture .shop-tools{
      display: flex !important; /* override any grid rules from global css */
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      width: 100%;
      box-sizing: border-box;
    }
    .page-manufacture .shop-tools > .tabs{
      display: flex !important;
      align-items: center;
      gap: 10px;
      flex: 0 0 auto;
      flex-wrap: wrap;
      min-width: 0;
    }
    .page-manufacture .shop-tools > .controls{
      display: flex !important;
      align-items: center;
      gap: 10px;
      flex: 1 1 260px;
      min-width: 240px;
    }
    .page-manufacture #shopSearch{ width: 100%; min-width: 0; }

    /* Tabs look (force away from UA defaults) */
    .page-manufacture .tabs .tab{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 12px;
      min-height: 44px;
      border: 1px solid rgba(0,0,0,.70);
      background: rgba(255,255,255,.92);
      letter-spacing: 3px;
      text-transform: uppercase;
      font-size: 11px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .page-manufacture .tabs .tab:active{ transform: translateY(1px); }
    .page-manufacture .tabs .tab:focus-visible{
      outline: 2px solid rgba(0,0,0,.60);
      outline-offset: 2px;
    }
    .page-manufacture .tabs .tab[aria-selected="true"]{
      background: rgba(0,0,0,.06);
    }

    /* Chips: make them behave predictably */
    .page-manufacture .chips{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      width: 100%;
      box-sizing: border-box;
    }
    .page-manufacture .chip{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 12px;
      min-height: 44px;
      border: 1px solid rgba(0,0,0,.20);
      background: rgba(255,255,255,.88);
      font-size: 11px;
      letter-spacing: 2px;
      text-transform: uppercase;
      cursor: pointer;
      white-space: nowrap;
    }
    .page-manufacture .chip[data-active="true"]{
      border-color: rgba(0,0,0,.50);
      background: rgba(0,0,0,.06);
    }

    /* --- Phone: stack controls + scrollable tabs/chips (no broken "stack") --- */
    @media (max-width: 680px){
      /* Prevent iOS input zoom on focus (font-size >= 16px) */
      .page-manufacture input,
      .page-manufacture select,
      .page-manufacture textarea{
        font-size: 16px;
      }

      .page-manufacture .shop-title{
        flex-direction: column;
        align-items: stretch;
      }
      .page-manufacture .shop-title .controls{
        width: 100%;
      }
      .page-manufacture #currencySelect{ flex: 1 1 140px; min-width: 120px; }
      .page-manufacture #cartOpen{ flex: 1 1 160px; }

      .page-manufacture .shop-tools{
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      /* Tabs row: horizontal scroll, never wraps into messy multiple lines */
      .page-manufacture .shop-tools > .tabs{
        flex-wrap: nowrap;
        overflow-x: auto;
        overscroll-behavior-x: contain;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 2px;
        margin: 0 -2px;
        scroll-snap-type: x proximity;
      }
      .page-manufacture .shop-tools > .tabs::-webkit-scrollbar{ display: none; }
      .page-manufacture .tabs .tab{ flex: 0 0 auto; scroll-snap-align: start; }

      .page-manufacture .shop-tools > .controls{
        width: 100%;
        min-width: 0;
        flex: 0 0 auto;
      }
      .page-manufacture #shopSearch{ width: 100%; }

      /* Chips row: also scrollable (many categories) */
      .page-manufacture .chips{
        flex-wrap: nowrap;
        overflow-x: auto;
        overscroll-behavior-x: contain;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 2px;
        margin: 0 -2px;
        scroll-snap-type: x proximity;
      }
      .page-manufacture .chips::-webkit-scrollbar{ display: none; }
      .page-manufacture .chip{ flex: 0 0 auto; scroll-snap-align: start; }

      /* Grid: friendly cards on phones (works if .grid is CSS grid) */
      .page-manufacture #productGrid.grid{
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }
    }

    @media (max-width: 420px){
      .page-manufacture #productGrid.grid{
        grid-template-columns: 1fr;
      }
    }
  </style>

  <!-- EXTRA mobile fixes: full-width layout, no overlaps, scrollable philosophy on phones -->
  <style id="mobileManufactureExtra">
    /* Phones: stop squeezing content into narrow рамки */
    @media (max-width: 680px){
      .page-manufacture{
        --edge-top-space: 84px;
        --edge-bottom-space: 84px;
      }

      /* Let the main container breathe full width */
      .page-manufacture .center-stage{
        width: 100%;
        max-width: none !important;
        padding-left: max(12px, env(safe-area-inset-left, 0px)) !important;
        padding-right: max(12px, env(safe-area-inset-right, 0px)) !important;
      }
      .page-manufacture .shop,
      .page-manufacture .shop-head,
      .page-manufacture .shop-body,
      .page-manufacture .shop-head__inner{
        width: 100%;
        max-width: none !important;
        box-sizing: border-box;
      }

      /* Fix: top 'item-key' button overlapping H1 */
      .page-manufacture .shop-head{ padding-top: 6px; }
      .page-manufacture .shop-title h1{
        margin: 0;
        padding-top: 4px;
        overflow-wrap: anywhere;
      }

      /* Philosophy/home console: make it scrollable on phones (no cutting) */
      .page-manufacture #homePanel.home-console{
        min-height: auto;
        height: auto;
        overflow: visible;
      }
      .page-manufacture #consoleSurface.console-surface{
        max-height: calc(100svh - (var(--edge-top-space) + var(--edge-bottom-space) + 18px));
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        padding-right: 2px; /* avoid text under scrollbar */
      }
      .page-manufacture #consoleLines.console-lines{
        overflow: visible;
      }
    }

    /* Tiny phones */
    @media (max-width: 380px){
      .page-manufacture{
        --edge-top-space: 92px;
      }
    }
  </style>

</head>

<body class="page page-manufacture">
    <div class="rays" aria-hidden="true"></div>
  <div class="veil" aria-hidden="true"></div>

  <header class="topbar topbar--edge">
    <a class="toplink" href="index.html" aria-label="Item Key"><span class="tag">item-key</span></a>
  </header>

  

  

  <main class="center-stage" aria-label="Marketplace">
    <section class="shop">
      <div class="shop-head">
        <div class="shop-head__inner">
          <div class="shop-title">
            <div>
              <h1>item-manufacture</h1>
            </div>

            <div class="controls">
              <select id="currencySelect" class="select" aria-label="Валюта">
                <option value="BYN" selected>BYN</option>
                <option value="USD">USD</option>
                <option value="EUR">EUR</option>
                <option value="RUB">RUB</option>
              </select>

              <button id="cartOpen" class="btn btn--primary" type="button">
                cart (<span id="cartCount">0</span>)
              </button>
            </div>
          </div>

          <div class="shop-tools">
            <div class="tabs" role="tablist" aria-label="Категории">
              <button class="tab" type="button" role="tab" data-tab="home" aria-selected="true">Data</button>
              <button class="tab" type="button" role="tab" data-tab="item" aria-selected="false">item</button>
              <button class="tab" id="goSocial" type="button">social</button>
                                        <!-- <button class="tab" type="button" role="tab" data-tab="tape" aria-selected="false">tape</button> -->
</div>

            <div class="controls">
              <input id="shopSearch" class="input" type="search" placeholder="поиск (название / описание / теги)" />
            </div>
          </div>

          <div id="sectionChips" class="chips" aria-label="Разделы" style="display:none;" data-hidden="true">
            
            <button class="chip" type="button" data-cat="all" data-active="true">всё</button>
            <button class="chip" type="button" data-cat="верх">верх</button>
            <button class="chip" type="button" data-cat="низ">низ</button>
            <button class="chip" type="button" data-cat="мешок">мешок</button>
            <button class="chip" type="button" data-cat="на голову">на голову</button>
            <button class="chip" type="button" data-cat="аксессуары">аксессуары</button>
            <button class="chip" type="button" data-cat="set">set</button>

          </div>
        </div>
      </div>

      <div class="shop-body">
        
        <!-- HOME -->
        <div id="homePanel" class="home-console" aria-label="Дом: консоль" style="display:block;">
          <canvas id="homeConsoleFx" aria-hidden="true"></canvas>

          <div class="home-console__ui">
            <div id="consoleSurface" class="console-surface" tabindex="0" role="application" aria-label="console: item-manufacture">
              <div class="console-topbar">
                <div class="console-badge gtext" data-text="item_key :: дом">cell:\item_key\item-manufacture\</div>
                <div class="console-status" id="consoleStatus"></div>
              </div>

              <div id="consoleLines" class="console-lines" aria-live="polite"></div>

              <div class="console-footer">
</div>
            </div>
          </div>
        </div>

        <!-- TAPE -->
        <div id="tapePanel" class="tape-panel" aria-label="Tape: видео" style="display:none;">
          <div class="tape-title">
            <h2>tape</h2>
            
          </div>

          <div class="tape-grid">
            <div class="tape-card">
              <div class="tape-card__head">
                <span>Cartel_Hatchling</span>
                <span class="meta">mp4</span>
              </div>

              <div class="tape-wrap" data-tape-wrap data-playing="false" data-orient="h">
                <div class="tape-frame" data-tape-frame>
                  <video class="tape-video" preload="metadata" playsinline loop data-tape-video>
                    <source src="video/cartel1.mp4" type="video/mp4">
                    Ваш браузер не поддерживает видео.
                  </video>

                  <button class="tape-overlay" type="button" data-tape-overlay aria-label="play Cartel_Hatchling">
                    <span class="seal" aria-hidden="true"></span>
                    <span class="t">start</span>
                    </button>
                </div>

                <div class="tape-controls" data-tape-controls>
                  <button class="tape-btn" type="button" data-action="play">play</button>
                  <input class="tape-seek" type="range" min="0" max="1000" value="0" step="1" data-action="seek" aria-label="seek">
                  <span class="tape-time" data-action="time">0:00 / 0:00</span>
                  <button class="tape-btn" type="button" data-action="mute">mute</button>
                  <button class="tape-btn" type="button" data-action="fs">full</button>
                </div>
              </div>
            </div>

            <div class="tape-card">
              <div class="tape-card__head">
                <span>set1</span>
                <span class="meta">mp4</span>
              </div>

              <div class="tape-wrap" data-tape-wrap data-playing="false" data-orient="h">
                <div class="tape-frame" data-tape-frame>
                  <video class="tape-video" preload="metadata" playsinline loop data-tape-video data-default-volume="0.25">
                    <source src="video/set1.mp4" type="video/mp4">
                    Ваш браузер не поддерживает видео.
                  </video>

                  <button class="tape-overlay" type="button" data-tape-overlay aria-label="play set1">
                    <span class="seal" aria-hidden="true"></span>
                    <span class="t">start</span>
                    </button>
                </div>

                <div class="tape-controls" data-tape-controls>
                  <button class="tape-btn" type="button" data-action="play">play</button>
                  <input class="tape-seek" type="range" min="0" max="1000" value="0" step="1" data-action="seek" aria-label="seek">
                  <span class="tape-time" data-action="time">0:00 / 0:00</span>
                  <button class="tape-btn" type="button" data-action="mute">mute</button>
                  <button class="tape-btn" type="button" data-action="fs">full</button>
                </div>
              </div>
            </div>
          </div>
        </div>


<!-- TOOLBAR visible only for item/guests -->


        <!-- GRID -->
        <div class="grid" id="productGrid"></div>
      </div>
    </section>
  </main>

  <footer class="bottombar bottombar--edge">
    <span class="hint">ты ни менше меня урод</span>
    <span class="sep">•</span>
    <span class="hint">ONO-beta</span>
  </footer>

  <!-- CART -->
  <aside class="cart" id="cart" data-open="false" aria-label="Корзина">
    <div class="cart__head">
      <div class="cart__title">
        <span>cart</span>
        <button id="cartClose" class="btn" type="button">close</button>
      </div>
    </div>
    <div class="cart__list" id="cartList"></div>
    <div class="cart__foot">
      <div class="total">
        <span>total</span>
        <span id="cartTotal">0 BYN</span>
      </div>
          <div class="cart__pay">
        <a class="btn btn--primary" href="https://t.me/item_mngr" target="_blank" rel="noopener">Payment Channel</a>
      </div>
</div>
  </aside>

  <!-- ADD CLOTHING MODAL (admin) -->
  <div class="modal" id="clothModal" data-open="false" aria-hidden="true">
    <div class="modal__card" role="dialog" aria-label="Add clothing">
      <div class="modal__head">
        <h3 id="clothModalTitle">add clothing</h3>
        <button id="clothClose" class="btn" type="button">close</button>
      </div>

      <p class="helper">
        Сейчас аккаунтов нет — считаем, что все админы. Данные пишутся в локальную базу и сохраняются между перезагрузками.
        Для “сохранения в файл” используй кнопку <b>export json</b> (скачает JSON).
      </p>

      <form id="clothForm" class="form">
        <input type="hidden" name="owner" id="clothOwner" value="item" />
        <input type="hidden" name="id" id="clothId" value="" />

        <label class="col-6">
          category
          <select class="select" name="category">
            
            <option value="верх">верх</option>
            <option value="низ">низ</option>
            <option value="set">set</option>
            <option value="мешок">мешок</option>
            <option value="аксессуары">аксессуары</option>
            <option value="на голову">на голову</option>
            <option value="другое">другое</option>
          
          </select>
        </label>

        <!-- SET: pick existing items (only when category=set) -->
        <div class="col-12 set-only" id="setPickerWrap">
          <div class="setpicker">
            <div class="setpicker__title">set items (choose existing products)</div>
            <div class="helper">Отметь вещи, которые входят в этот set. В set показываются первые фотки выбранных вещей — кликабельные (переход в карточку).</div>
            <div class="setpicker__grid" id="setPickerList"></div>
          </div>
        </div>

        <label class="col-6 set-hide">
          price (BYN)
          <input class="input" name="price" placeholder="например: 150" />
        </label>

        <label class="col-6 set-hide">
          stock
          <select class="select" name="stock">
            <option value="in" selected>in stock</option>
            <option value="soldout">archived</option>
          </select>
        </label>

        <label class="col-12 set-hide">
          name
          <input class="input" name="name" placeholder="например: KEY COAT" />
        </label>

        <label class="col-12 set-hide">
          description
          <textarea class="input" name="desc" placeholder="детали, материал, посадка, смысл"></textarea>
        </label>

        <label class="col-12">
          image urls (optional, через запятую / перенос строки)
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <input id="imageUrlsInput" class="input" name="imageUrls" placeholder="https://... , https://...">
            <button id="addUrlsBtn" class="btn" type="button">add urls</button>
          </div>
        </label>

        <div class="col-12">
          <div class="imgmgr" id="imgMgr" aria-label="Image files manager">
            <div class="imgmgr__head">
              <div class="imgmgr__title">image files</div>
              <div class="imgmgr__actions">
                <button id="imgBrowseBtn" class="btn" type="button">browse</button>
                <input id="imgFileInput" type="file" accept="image/*" multiple style="display:none;">
                <button id="imgClearBtn" class="btn btn--ghost" type="button">clear</button>
              </div>
            </div>
            <div class="imgmgr__hint helper">
              Можно добавлять файлы частями: нажимай <b>browse</b> сколько угодно раз.
              Нажми на превью — сделаешь его первой фоткой (cover). Крестик — удалить.
            </div>
            <div class="imgmgr__grid" id="imgPreviewGrid"></div>
          </div>
        </div>

        <div class="col-12" style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn btn--primary" type="submit">publish</button>
          <button id="exportDbBtn" class="btn" type="button">export json</button>
          <label class="btn" style="display:inline-flex; align-items:center; gap:8px; cursor:pointer;">
            import json
            <input id="importDbInput" type="file" accept="application/json" style="display:none;" />
          </label>
          <button id="deleteCardBtn" class="btn btn--ghost" type="button" disabled>delete</button>
        </div>
      </form>
    </div>
  </div>

  <!-- PRODUCT DETAILS MODAL (buyers) -->
  <div class="pmodal" id="productModal" data-open="false" aria-hidden="true">
    <div class="pmodal__card" role="dialog" aria-label="Product details">
      <div class="pmodal__head">
        <div class="pmodal__title">
          <h3 id="pName">product</h3>
          <div class="sub" id="pMeta">—</div>
        </div>
        <div class="pmodal__actions">
          <button id="pEdit" class="btn" type="button">edit</button>
          <button id="pClose" class="btn" type="button">close</button>
        </div>
      </div>

      <div class="pmodal__body">
        <div class="gallery" aria-label="Gallery">
          <div class="gallery__main" id="pMainWrap">
            <div class="placeholder">image</div>
          </div>
          <div class="gallery__thumbs" id="pThumbs"></div>
        </div>

        <div class="pinfo" aria-label="Info">
          <div class="pinfo__top">
            <div class="pinfo__price" id="pPrice">0 BYN</div>
            <div class="pill" id="pCategory">—</div>
          </div>

          <p class="pinfo__desc" id="pDesc"></p>

          <div id="pSetBlock" class="pset" style="display:none;">
            <div class="pset__title">set items</div>
            <div class="pset__grid" id="pSetGrid"></div>
          </div>

          <div class="pinfo__actions">
            <button id="pAdd" class="btn btn--primary" type="button">add to cart</button>
            <div id="pSold" class="pinfo__soldout">archived</div>
          </div>

          <div class="helper">
            Нажми на карточку в сетке — откроется это окно. Вся страница под ним не кликается и размыта.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- UI CONFIRM MODAL (site-styled) -->
  <div class="uimodal" id="uiConfirm" data-open="false" aria-hidden="true">
    <div class="uimodal__card" role="dialog" aria-modal="true" aria-label="Confirm">
      <div class="uimodal__head">
        <h3 id="uiConfirmTitle">confirm</h3>
        <button id="uiConfirmClose" class="btn" type="button">close</button>
      </div>
      <p class="uimodal__text" id="uiConfirmText"></p>
      <div class="uimodal__actions">
        <button id="uiConfirmCancel" class="btn" type="button">cancel</button>
        <button id="uiConfirmOk" class="btn btn--primary" type="button">ok</button>
      </div>
    </div>
  </div>

  <!-- UI TOAST -->
  <div class="uitoast" id="uiToast" aria-live="polite" aria-atomic="true"></div>

  <script>
    // Active page highlight (simple)
    (() => {
      const path = (location.pathname.split("/").pop() || "index.html").toLowerCase();
      document.querySelectorAll("a[href]").forEach(a => {
        const href = (a.getAttribute("href") || "").toLowerCase();
        if (href === path) a.classList.add("is-active");
      });
    })();

    /* =========================
      ITEM-MANUFACTURE STORE
      - grid: ONLY (first image + name + price)
      - click card -> product modal (all images + desc + add to cart)
      - localStorage db + cart
      ========================= */
    (() => {
      if (!document.body.classList.contains("page-manufacture")) return;

      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

      // UI
      const tabButtons = $$(".tab[data-tab]");
      const chipWrap = $("#sectionChips");
      const chipButtons = $$(".chip");
      const searchInput = $("#shopSearch");
      const currencySelect = $("#currencySelect");

      const homePanel = $("#homePanel");
      const tapePanel = $("#tapePanel");
      const grid = $("#productGrid");

      const toolbar = $("#marketToolbar");
      const scopePill = $("#marketScope");
      const addClothBtn = $("#addClothBtn");
      const saveDbBtn = $("#saveDbBtn");

      const goItem = $("#goItem");
      const goGuests = $("#goGuests");
      const goSocial = $("#goSocial");

      // Cart UI
      const cart = $("#cart");
      const cartOpen = $("#cartOpen");
      const cartClose = $("#cartClose");
      const cartList = $("#cartList");
      const cartCount = $("#cartCount");
      const cartTotal = $("#cartTotal");

      // Admin modal UI
      const modal = $("#clothModal");
      const modalClose = $("#clothClose");
      const form = $("#clothForm");
      const ownerHidden = $("#clothOwner");
      const clothIdHidden = $("#clothId");
      const exportDbBtn = $("#exportDbBtn");
      const importDbInput = $("#importDbInput");
      const deleteCardBtn = $("#deleteCardBtn");

      // Image manager (admin) UI
      const imageUrlsInput = $("#imageUrlsInput");
      const addUrlsBtn = $("#addUrlsBtn");
      const imgMgr = $("#imgMgr");
      const imgBrowseBtn = $("#imgBrowseBtn");
      const imgFileInput = $("#imgFileInput");
      const imgClearBtn = $("#imgClearBtn");
      const imgPreviewGrid = $("#imgPreviewGrid");

      // SET (special category) UI
      const setPickerWrap = $("#setPickerWrap");
      const setPickerList = $("#setPickerList");
      const catSelect = form?.querySelector('[name="category"]');

      // Product modal UI
      const pModal = $("#productModal");
      const pClose = $("#pClose");
      const pEdit = $("#pEdit");
      const pClose2 = $("#pClose2");
      const pName = $("#pName");
      const pMeta = $("#pMeta");
      const pPrice = $("#pPrice");
      const pCategory = $("#pCategory");
      const pDesc = $("#pDesc");
      const pThumbs = $("#pThumbs");
      const pMainWrap = $("#pMainWrap");
      const pAdd = $("#pAdd");
      const pSold = $("#pSold");
      const pSetBlock = $("#pSetBlock");
      const pSetGrid = $("#pSetGrid");

      // Stats
      const statTotal = $("#statTotal");
      const statItem = $("#statItem");
      const statGuests = $("#statGuests");

      // Keys
      const KEY_PRODUCTS = "itemkey.manufacture.products.v4";
      const KEY_CART = "itemkey.manufacture.cart.v4";
      const KEY_CURRENCY = "itemkey.manufacture.currency.v4";
      const SEED_URL = "assets/js/item-manufacture.db.json";

      const state = {
        tab: "home",
        section: "all",
        query: "",
        currency: "BYN",
        // временные курсы
        rates: { BYN: 1, USD: 0.31, EUR: 0.29, RUB: 29.0 },
        products: [],
        loadingProducts: true,
        cart: [],
        openProductId: null,
        editProductId: null,
        galleryIndex: 0,
        draftImages: []
      };
      // prevent first-load animation flicker
      let booted = false;

      // ===== Scroll lock only for HOME (дом) =====
      const noScrollStyle = document.getElementById("noScrollStyle");
      const mqMobile = window.matchMedia("(max-width: 680px), (pointer: coarse)");
      function applyHomeScrollLock(isHome){
        // Desktop: lock page scroll on HOME so console arrows don't move the page.
        // Phone/tablet: DO NOT lock (people must be able to scroll long philosophy text).
        if (!noScrollStyle) return;
        const isMobile = !!mqMobile.matches;
        noScrollStyle.disabled = !(isHome && !isMobile);
      }
      // init + keep correct on rotate/resize
      applyHomeScrollLock(true);
      try{ mqMobile.addEventListener("change", () => applyHomeScrollLock(state?.tab === "home")); }catch{ mqMobile.addListener?.(() => applyHomeScrollLock(state?.tab === "home")); }

      /* init search visibility */
      try{
        const _searchWrap = searchInput ? searchInput.closest('.shop-tools .controls') : null;
        if (_searchWrap) _searchWrap.style.display = 'none';
      }catch{}


      // ===== TAPE (video) — custom UI, loop, single playback =====
      let _tapeBound = false;

      function _tapeFmtTime(sec){
        if (!isFinite(sec) || sec < 0) sec = 0;
        sec = Math.floor(sec);
        const m = Math.floor(sec / 60);
        const s = sec % 60;
        return m + ":" + String(s).padStart(2, "0");
      }

      function _tapeSetWrap(video, playing){
        const w = video?.closest?.("[data-tape-wrap]") || video?.closest?.(".tape-wrap");
        if (w) w.dataset.playing = playing ? "true" : "false";
      }

      function _tapeUpdateControls(wrap){
        const v = wrap.querySelector("video");
        const playBtn = wrap.querySelector('[data-action="play"]');
        const muteBtn = wrap.querySelector('[data-action="mute"]');
        const seek = wrap.querySelector('[data-action="seek"]');
        const time = wrap.querySelector('[data-action="time"]');

        if (!v) return;

        if (playBtn) playBtn.textContent = v.paused ? "play" : "pause";
        if (muteBtn) muteBtn.textContent = v.muted ? "unmute" : "mute";

        const dur = isFinite(v.duration) ? v.duration : 0;
        const cur = isFinite(v.currentTime) ? v.currentTime : 0;

        if (seek){
          const val = dur > 0 ? Math.round((cur / dur) * 1000) : 0;
          if (!seek._dragging) seek.value = String(val);
        }
        if (time){
          time.textContent = _tapeFmtTime(cur) + " / " + _tapeFmtTime(dur);
        }
      }

      function bindTapeOnce(){
        if (_tapeBound) return;
        _tapeBound = true;
        if (!tapePanel) return;

        const wraps = Array.from(tapePanel.querySelectorAll("[data-tape-wrap]"));

        wraps.forEach(w => {
          const v = w.querySelector("video");
          if (!v) return;

          // remove native controls (to avoid black bars)
          try{ v.removeAttribute("controls"); }catch{}
          // defensive loop
          try{ v.loop = true; }catch{}


          // default volume (optional, for quiet videos)
          const dv = parseFloat(v.getAttribute("data-default-volume") || "");
          if (isFinite(dv)){
            try{ v.volume = Math.max(0, Math.min(1, dv)); }catch{}
          }

          // set orientation on metadata
          v.addEventListener("loadedmetadata", () => {
            try{
              if (v.videoHeight > v.videoWidth) w.dataset.orient = "v";
              else w.dataset.orient = "h";
            }catch{}
            _tapeUpdateControls(w);
          });

          // overlay click => play/pause
          const overlay = w.querySelector("[data-tape-overlay]");
          if (overlay){
            overlay.addEventListener("click", () => {
              if (v.paused) v.play();
              else v.pause();
            });
          }

          // play button
          const playBtn = w.querySelector('[data-action="play"]');
          if (playBtn){
            playBtn.addEventListener("click", () => {
              if (v.paused) v.play();
              else v.pause();
            });
          }

          // seek slider
          const seek = w.querySelector('[data-action="seek"]');
          if (seek){
            seek.addEventListener("pointerdown", () => { seek._dragging = true; });
            seek.addEventListener("pointerup", () => { seek._dragging = false; });
            seek.addEventListener("input", () => {
              const dur = isFinite(v.duration) ? v.duration : 0;
              if (dur <= 0) return;
              const p = (Number(seek.value) || 0) / 1000;
              try{ v.currentTime = Math.max(0, Math.min(dur, p * dur)); }catch{}
              _tapeUpdateControls(w);
            });
          }

          // mute
          const muteBtn = w.querySelector('[data-action="mute"]');
          if (muteBtn){
            muteBtn.addEventListener("click", () => {
              v.muted = !v.muted;
              _tapeUpdateControls(w);
            });
          }

          // fullscreen
          const fsBtn = w.querySelector('[data-action="fs"]');
          if (fsBtn){
            fsBtn.addEventListener("click", () => {
              const frame = w.querySelector("[data-tape-frame]") || v;
              try{
                if (document.fullscreenElement) document.exitFullscreen();
                else frame.requestFullscreen?.();
              }catch{}
            });
          }

          // state updates
          v.addEventListener("timeupdate", () => _tapeUpdateControls(w));
          v.addEventListener("pause", () => { _tapeSetWrap(v, false); _tapeUpdateControls(w); });
          v.addEventListener("play", () => { _tapeSetWrap(v, true); _tapeUpdateControls(w); });

          // initial
          _tapeUpdateControls(w);
        });

        // single-playback: starting one pauses the others
        const vids = wraps.map(w => w.querySelector("video")).filter(Boolean);
        vids.forEach(v => {
          v.addEventListener("play", () => {
            vids.forEach(o => {
              if (o !== v && !o.paused){
                try{ o.pause(); }catch{}
                try{ o.currentTime = 0; }catch{}
                _tapeSetWrap(o, false);
                const ow = o.closest("[data-tape-wrap]");
                if (ow) _tapeUpdateControls(ow);
              }
            });
          });
        });
      }

      function stopTapeVideos(reset = false){
        if (!tapePanel) return;
        const wraps = Array.from(tapePanel.querySelectorAll("[data-tape-wrap]"));
        wraps.forEach(w => {
          const v = w.querySelector("video");
          if (!v) return;
          try{ v.pause(); }catch{}
          if (reset){
            try{ v.currentTime = 0; }catch{}
          }
          _tapeSetWrap(v, false);
          _tapeUpdateControls(w);
        });
      }

// ===== Site-styled confirm + toast (replaces browser alert/confirm for delete) =====
      const uiConfirmEl = $("#uiConfirm");
      const uiConfirmTitle = $("#uiConfirmTitle");
      const uiConfirmText = $("#uiConfirmText");
      const uiConfirmOk = $("#uiConfirmOk");
      const uiConfirmCancel = $("#uiConfirmCancel");
      const uiConfirmClose = $("#uiConfirmClose");
      const uiConfirmActions = uiConfirmEl?.querySelector(".uimodal__actions");
      const uiToastEl = $("#uiToast");

      let _uiConfirmResolver = null;

      function uiToast(msg, ttl = 1600){
        if (!uiToastEl) return;
        const node = document.createElement("div");
        node.className = "uitoast__msg";
        node.textContent = String(msg || "");
        uiToastEl.appendChild(node);

        // show
        requestAnimationFrame(() => node.dataset.show = "true");

        // hide + remove
        setTimeout(() => {
          node.dataset.show = "false";
          setTimeout(() => node.remove(), 260);
        }, Math.max(600, ttl));
      }

      function closeUiConfirm(result){
        if (!uiConfirmEl) return;
        uiConfirmEl.dataset.open = "false";
        uiConfirmEl.setAttribute("aria-hidden", "true");
        document.body.classList.remove("modal-lock");
        const r = _uiConfirmResolver;
        _uiConfirmResolver = null;
        if (typeof r === "function") r(!!result);
      }

      function uiConfirm({ title = "confirm", text = "", okText = "ok", cancelText = "cancel" } = {}){
        return new Promise((resolve) => {
          if (!uiConfirmEl){
            // fallback (shouldn't happen)
            resolve(false);
            return;
          }

          _uiConfirmResolver = resolve;

          if (uiConfirmTitle) uiConfirmTitle.textContent = String(title || "confirm");
          if (uiConfirmText) uiConfirmText.textContent = String(text || "");
          const _ok = (okText === undefined) ? "ok" : String(okText);
          const _cancel = (cancelText === undefined) ? "cancel" : String(cancelText);
          if (uiConfirmOk) uiConfirmOk.textContent = _ok;
          if (uiConfirmCancel) uiConfirmCancel.textContent = _cancel;
          const single = (_cancel === "" || cancelText === null);
          if (uiConfirmCancel) uiConfirmCancel.style.display = single ? "none" : "";
          if (uiConfirmActions) uiConfirmActions.style.justifyContent = single ? "flex-end" : "";

          uiConfirmEl.dataset.open = "true";
          uiConfirmEl.setAttribute("aria-hidden", "false");
          document.body.classList.add("modal-lock");

          // focus
          setTimeout(() => uiConfirmCancel?.focus?.(), 0);
        });
      }

      // confirm modal events (once)
      (() => {
        if (!uiConfirmEl) return;

        uiConfirmOk?.addEventListener("click", () => closeUiConfirm(true));
        uiConfirmCancel?.addEventListener("click", () => closeUiConfirm(false));
        uiConfirmClose?.addEventListener("click", () => closeUiConfirm(false));

        uiConfirmEl.addEventListener("click", (e) => {
          if (e.target === uiConfirmEl) closeUiConfirm(false);
        });

        document.addEventListener("keydown", (e) => {
          if (uiConfirmEl.dataset.open !== "true") return;
          if (e.key === "Escape") closeUiConfirm(false);
        });
      })();

      // UI Alert (site-styled) — replaces browser alert()
      function uiAlert({ title = "notice", text = "", okText = "ok" } = {}){
        // Uses the same modal, but with a single action button
        return uiConfirm({ title, text, okText, cancelText: "" }).then(() => {});
      }

      function uid(){
        return Math.random().toString(16).slice(2) + Date.now().toString(16);
      }
      function esc(s){
        return String(s ?? "")
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#039;");
      }
      function normCat(c){
        return (c || "").trim().toLowerCase() || "другое";
      }

      function isSetCat(c){
        return normCat(c) === "set";
      }
      function isSetProduct(p){
        if (!p) return false;
        return isSetCat(p.category) || String(p.type || "").toLowerCase() === "set" || p.isSet === true;
      }

      function loadJSON(key, fallback){
        try{
          const raw = localStorage.getItem(key);
          if (!raw) return fallback;
          return JSON.parse(raw);
        }catch{ return fallback; }
      }
      function saveJSON(key, value){
        localStorage.setItem(key, JSON.stringify(value));
      }
      function isQuotaError(err){
        return !!(err && (
          err.name === "QuotaExceededError" ||
          err.code === 22 ||
          err.code === 1014 ||
          /quota/i.test(String(err.message || ""))
        ));
      }

      function leanProductsForStorage(list){
        // localStorage quota is small (~5–10MB). If images are data: URLs, it can overflow fast.
        // We keep the products, but strip data: URLs so publishing doesn't silently fail.
        return (Array.isArray(list) ? list : []).map(p => {
          const imgs = Array.isArray(p?.images) ? p.images.map(String) : [];
          const filtered = imgs.filter(src => !(src || "").trim().startsWith("data:"));
          return {
            ...p,
            images: filtered,
            image: filtered[0] || ""
          };
        });
      }

      function persist(){
        // products
        try{
          saveJSON(KEY_PRODUCTS, state.products);
        }catch(err){
          if (isQuotaError(err)){
            try{
              saveJSON(KEY_PRODUCTS, leanProductsForStorage(state.products));
}catch(err2){
              console.error(err2);
              setTimeout(() => {
                uiAlert({
                  title: "Ошибка сохранения",
                  text: "Карточка опубликована, но база не сохранилась (даже после попытки урезать изображения). Экспортируй DB в файл.",
                  okText: "ok"
                });
              }, 0);
            }
          } else {
            console.error(err);
          }
        }

        // cart + currency (small) — best-effort
        try{ saveJSON(KEY_CART, state.cart); }catch{}
        try{ saveJSON(KEY_CURRENCY, state.currency); }catch{}
      }

      function money(amountBYN){
        const cur = state.currency;
        const rate = state.rates[cur] ?? 1;
        const v = (Number(amountBYN) || 0) * rate;
        const fmt = new Intl.NumberFormat("ru-RU", { maximumFractionDigits: cur==="RUB"?0:2 });
        return `${fmt.format(v)} ${cur}`;
      }

      function normalizeProduct(x){
        const images = Array.isArray(x?.images) ? x.images.map(String).filter(Boolean) : [];
        const legacy = String(x?.image || "").trim();
        const finalImages = images.length ? images : (legacy ? [legacy] : []);

        const category = String(x?.category || "другое");
        const _isSet = isSetCat(category) || String(x?.type || "").toLowerCase() === "set" || x?.isSet === true;

        // stock: default in stock for old DBs (sets are always "in" as they are not directly purchasable here)
        let inStock = true;
        if (!_isSet){
          if (typeof x?.inStock === "boolean") inStock = x.inStock;
          else if (typeof x?.stock === "string"){
            const s = x.stock.trim().toLowerCase();
            inStock = !(s === "soldout" || s === "sold out" || s === "out" || s === "0");
          } else if (typeof x?.status === "string"){
            const s = x.status.trim().toLowerCase();
            inStock = !(s === "soldout" || s === "sold out" || s === "out");
          }
        }

        const setItemsRaw = Array.isArray(x?.setItems) ? x.setItems : (Array.isArray(x?.items) ? x.items : []);
        const setItems = (setItemsRaw || []).map(v => String(v || "").trim()).filter(Boolean);

        const name = _isSet ? (String(x?.name || "").trim() || "set") : (String(x?.name || "Untitled"));
        const priceBYN = Number(x?.priceBYN || 0) || 0;
        const desc = _isSet ? "" : String(x?.desc || "");

        return {
          id: String(x?.id || uid()),
          owner: (x?.owner === "guests") ? "guests" : "item",
          category,
          type: _isSet ? "set" : "product",
          isSet: _isSet,
          setItems,
          name,
          priceBYN: _isSet ? 0 : priceBYN,
          inStock: _isSet ? true : !!inStock,
          images: finalImages,
          // keep legacy too (optional)
          image: finalImages[0] || "",
          desc,
          createdAt: Number(x?.createdAt || Date.now())
        };
      }

      function loadProducts() {
      try {
        // 1. Пытаемся загрузить JSON-файл (работает через сервер)
        if (location.protocol !== "file:") {
          return fetch("assets/js/item-manufacture.db.json")
            .then(res => {
              if (!res.ok) throw new Error("DB not found");
              return res.json();
            })
            .then(data => Array.isArray(data) ? data.map(normalizeProduct) : [])
            .catch(() => {
              // fallback ниже
              const existing = loadJSON(KEY_PRODUCTS, null);
              if (Array.isArray(existing)) return existing.map(normalizeProduct);
              return [];
            });
        }

        // 2. Fallback: localStorage (если file://)
        const existing = loadJSON(KEY_PRODUCTS, null);
        if (Array.isArray(existing)) return existing.map(normalizeProduct);

        return [];
      } catch (e) {
        console.warn("loadProducts error:", e);
        return [];
      }
    }

      function setTab(tab, opts = {}){
        // Smart no-op: clicking the active tab again does nothing
        if (!opts.force && tab === state.tab) return;
        state.tab = tab;
        state.section = "all";
        state.query = state.query || "";
        closeProductModal();

        tabButtons.forEach(b => b.setAttribute("aria-selected", b.dataset.tab === tab ? "true" : "false"));

        const isHome = (tab === "home");
        const isTape = (tab === "tape");
        const isItemTab = (tab === "item");
        const _searchWrap = searchInput ? searchInput.closest(".shop-tools .controls") : null;
        if (_searchWrap) _searchWrap.style.display = isItemTab ? "" : "none";
        if (!isItemTab){
          state.query = "";
          if (searchInput) searchInput.value = "";
        }

        bindTapeOnce();
        if (!isTape) stopTapeVideos(false);
        applyHomeScrollLock(isHome);
        if (homePanel) homePanel.style.display = isHome ? "block" : "none";
        if (tapePanel) tapePanel.style.display = isTape ? "block" : "none";
        if (grid) grid.style.display = (isHome || isTape) ? "none" : "";
        if (chipWrap) {
          const hideChips = (isHome || isTape);
          chipWrap.style.display = hideChips ? "none" : "flex";
          chipWrap.dataset.hidden = hideChips ? "true" : "false";
        }
        if (toolbar) toolbar.style.display = (isHome || isTape) ? "none" : "flex";
        if (scopePill) scopePill.textContent = `scope: ${tab}`;
        if (ownerHidden) ownerHidden.value = (tab === "guests" ? "guests" : "item");

        chipButtons.forEach(c => c.dataset.active = (c.dataset.cat === "all") ? "true" : "false");

        // subtle transitions on tab switch (skip on first load)
        if (booted && !opts.silent) {
          if (isHome) {
            kickAnim(homePanel, "home--anim");
          } else if (isTape) {
            kickAnim(tapePanel, "tape--anim");
          } else {
            kickAnim(chipWrap, "chips--anim");
            kickAnim(toolbar, "market--anim");
          }
        }

        render();
      }

      function setSection(cat, opts = {}){
        // Smart no-op: clicking the active section again does nothing
        if (!opts.force && cat === state.section) return;
        state.section = cat;
        closeProductModal();
        chipButtons.forEach(c => c.dataset.active = (c.dataset.cat === cat) ? "true" : "false");
        kickAnim(chipWrap, "chips--anim");
        render();
      }

      function filtered(){
        const q = state.query.trim().toLowerCase();
        const sec = normCat(state.section);

        return state.products
          .filter(p => state.tab === "home" ? false : (p.owner === state.tab))
          // IMPORTANT: "all" excludes SET — sets live only inside the "set" section
          .filter(p => {
            if (sec === "all") return !isSetProduct(p);
            if (sec === "set") return isSetProduct(p);
            return normCat(p.category) === sec;
          })
          .filter(p => {
            if (!q) return true;
            const hay = `${p.name} ${p.desc} ${p.category}`.toLowerCase();
            return hay.includes(q);
          });
      }
function renderStats(){
        if (!statTotal) return;
        const total = state.products.length;
        const item = state.products.filter(p => p.owner === "item").length;
        const guests = state.products.filter(p => p.owner === "guests").length;
        statTotal.textContent = String(total);
        statItem.textContent = String(item);
        statGuests.textContent = String(guests);
      }

function kickAnim(el, cls){
  if (!el) return;
  el.classList.remove(cls);
  // force reflow to restart CSS animation
  void el.offsetWidth;
  el.classList.add(cls);
}

function animateGrid(){
  kickAnim(grid, "grid--anim");
}

function pulseCart(){
  kickAnim(cart, "cart--pulse");
}

      function cardHTML(p){
        const first = (p.images && p.images[0]) ? p.images[0] : "";
        const img = first
          ? `<img src="${esc(first)}" alt="${esc(p.name)}">`
          : `<div class="placeholder">image</div>`;

        const isSet = isSetProduct(p);

        const badge = (!isSet && p.inStock === false)
          ? `<div class="card__badge">archived</div>`
          : ``;

        // If set or sold out — hide price on the grid card
        const price = (isSet || p.inStock === false)
          ? ``
          : `<div class="card__price">${money(p.priceBYN)}</div>`;

        const inner = isSet
  ? `
      ${badge}
      <div class="card__media">${img}</div>
    `
  : `
      ${badge}
      <div class="card__media">${img}</div>
      <div class="card__body">
        <div class="card__top">
          <h3 class="card__name">${esc(p.name)}</h3>
          ${price}
        </div>
      </div>
    `;

return `
  <article class="card card--shop ${isSet ? "card--set" : ""}" data-id="${esc(p.id)}" tabindex="0" role="button" aria-label="${esc(isSet ? "set" : p.name)}">
    ${inner}
  </article>
`;
      }

      function renderGrid(){
        if (!grid) return;
        if (state.tab === "home" || state.tab === "tape"){
          grid.innerHTML = "";
          return;
        }

        if (state.loadingProducts){
          grid.innerHTML = `
            <div class="empty">
              <b>загрузка…</b>
              подгружаю карточки.
            </div>
          `;
          return;
        }

        const list = filtered();
        if (!list.length){
          grid.innerHTML = `
            <div class="empty">
              <b>пока пусто</b>
              создай первую карточку через режим добавления.
            </div>
          `;
          
          return;
        }

        // in-stock first, then sold out (with a divider)
        const inList = list.filter(p => p.inStock !== false);
        const outList = list.filter(p => p.inStock === false);

        let html = "";
        if (inList.length) html += inList.map(cardHTML).join("");
        if (inList.length && outList.length){
          html += `<div class="stock-sep" aria-hidden="true"><span class="t">archive</span></div>`;
        }
        if (outList.length) html += outList.map(cardHTML).join("");

        grid.innerHTML = html;
        
      }

      // Cart
      function openCart(on, opts = {}){
  if (!cart) return;
  const cur = cart.dataset.open === "true";
  // Smart no-op: clicking open/close when already in that state does nothing
  if (on === cur) return;

  cart.dataset.open = on ? "true" : "false";
  if (on && opts.pulse !== false) pulseCart();
}
      function cartQty(){
        return state.cart.reduce((s, x) => s + x.qty, 0);
      }
      function renderCart(){
        if (!cartCount || !cartList || !cartTotal) return;
        cartCount.textContent = String(cartQty());

        if (!state.cart.length){
          cartList.innerHTML = `<div class="helper">Корзина пуста.</div>`;
          cartTotal.textContent = money(0);
          return;
        }

        cartList.innerHTML = state.cart.map(it => {
          const p = state.products.find(x => x.id === it.id);
          if (!p) return "";
          return `
            <div class="cart-item" data-id="${esc(it.id)}">
              <div>
                <div class="cart-item__name">${esc(p.name)}</div>
                <div class="cart-item__meta">${money(p.priceBYN)} · ${esc(p.category || "—")}</div>
              </div>
              <div class="cart-item__qty">
                <button class="qtybtn" data-q="dec" type="button">−</button>
                <div>${it.qty}</div>
                <button class="qtybtn" data-q="inc" type="button">+</button>
              </div>
            </div>
          `;
        }).join("");

        const totalBYN = state.cart.reduce((sum, it) => {
          const p = state.products.find(x => x.id === it.id);
          return sum + (p ? p.priceBYN * it.qty : 0);
        }, 0);

        cartTotal.textContent = money(totalBYN);
      }

      function addToCart(id){
        const it = state.cart.find(x => x.id === id);
        if (it) it.qty += 1;
        else state.cart.push({ id, qty: 1 });
        persist();
        renderCart();
      }

      function adjustQty(id, delta){
        const it = state.cart.find(x => x.id === id);
        if (!it) return;
        it.qty += delta;
        if (it.qty <= 0) state.cart = state.cart.filter(x => x.id !== id);
        persist();
        renderCart();
      }

      // Admin modal
      function openAdminModal(on){
        if (!modal) return;
        modal.dataset.open = on ? "true" : "false";
        modal.setAttribute("aria-hidden", on ? "false" : "true");
        // lock page behind (prevents accidental clicks that могли бы менять state во время редактирования)
        document.body.classList.toggle("modal-lock", !!on);
      }

      function setAdminMode(mode, product){
        // IMPORTANT: modal hidden field `id` is the single source of truth for edit/create
        if (mode !== "edit"){
          state.editProductId = null;
          if (clothIdHidden) clothIdHidden.value = "";
        } else if (product?.id){
          state.editProductId = product.id;
          if (clothIdHidden) clothIdHidden.value = product.id;
        }

        const titleEl = $("#clothModalTitle");
        if (titleEl){
          titleEl.textContent = (mode === "edit") ? "edit clothing" : "add clothing";
        }

        if (clothIdHidden) clothIdHidden.value = (mode === "edit" && product?.id) ? String(product.id) : "";

        updateDeleteButton();
      }

      function setSelectValue(selectEl, value, fallback){
        if (!selectEl) return;
        const v = String(value ?? "").trim();
        const has = Array.from(selectEl.options || []).some(o => o.value === v);
        selectEl.value = has ? v : (fallback ?? selectEl.value);
      }

      function openEditorForProduct(id){
        const p = state.products.find(x => x.id === id);
        if (!p) return;

        // switch to editor mode
        setAdminMode("edit", p);

        // fill form with existing values
        try { form?.reset(); } catch {}
        if (ownerHidden) ownerHidden.value = p.owner;

        const catSel = form?.querySelector('[name="category"]');
        const stockSel = form?.querySelector('[name="stock"]');
        const priceIn = form?.querySelector('[name="price"]');
        const nameIn = form?.querySelector('[name="name"]');
        const descIn = form?.querySelector('[name="desc"]');

        // Image manager
        if (imageUrlsInput) imageUrlsInput.value = "";
        setDraftImages(Array.isArray(p.images) ? p.images : []);

        setSelectValue(catSel, p.category, "другое");

        // SET: fill picker
        renderSetPicker(p.owner, Array.isArray(p.setItems) ? p.setItems : []);
        applySetMode();
        setSelectValue(stockSel, (p.inStock === false) ? "soldout" : "in", "in");
        if (priceIn) priceIn.value = String(p.priceBYN ?? "");
        if (nameIn) nameIn.value = String(p.name ?? "");
        if (descIn) descIn.value = String(p.desc ?? "");

        openAdminModal(true);
      }

      function resetAdminModal(){
        setAdminMode("create");
        if (clothIdHidden) clothIdHidden.value = "";
        try { form?.reset(); } catch {}
        if (ownerHidden) ownerHidden.value = state.tab;
        const stockSel = form?.querySelector('[name="stock"]');
        setSelectValue(stockSel, "in", "in");
        if (imageUrlsInput) imageUrlsInput.value = "";
        setDraftImages([]);

        // SET: reset picker
        renderSetPicker(state.tab, []);
        applySetMode();
        
        updateDeleteButton();
      }

      function readFileAsDataURL(file){
        return new Promise((resolve, reject) => {
          const fr = new FileReader();
          fr.onload = () => resolve(String(fr.result));
          fr.onerror = reject;
          fr.readAsDataURL(file);
        });
      }

      // ===== Image manager (admin) =====
      const IMG_LIMIT = 12;

      function uniqImages(arr){
        const out = [];
        const seen = new Set();
        for (const raw of (arr || [])){
          const s = String(raw || "").trim();
          if (!s) continue;
          if (seen.has(s)) continue;
          seen.add(s);
          out.push(s);
          if (out.length >= IMG_LIMIT) break;
        }
        return out;
      }

      function setDraftImages(images){
        state.draftImages = uniqImages(images);
        renderDraftImages();
      }

      function renderDraftImages(){
        if (!imgPreviewGrid) return;
        const imgs = state.draftImages || [];
        if (!imgs.length){
          imgPreviewGrid.innerHTML = `<div class="imgmgr__empty">no images</div>`;
          return;
        }
        imgPreviewGrid.innerHTML = imgs.map((src, i) => `
          <div class="imgtile" data-i="${i}" tabindex="0" role="button" aria-label="image ${i+1}">
            <img src="${esc(src)}" alt="image ${i+1}">
            ${i === 0 ? `<div class="imgtile__badge">cover</div>` : ``}
            <button class="imgtile__remove" type="button" data-remove="${i}" aria-label="remove">×</button>
          </div>
        `).join("");
      }

      function addUrlsToDraft(raw){
        const urls = String(raw || "")
          .split(/[,\n]+/)
          .map(s => s.trim())
          .filter(Boolean);
        if (!urls.length) return;
        setDraftImages([...(state.draftImages || []), ...urls]);
      }

      async function addFilesToDraft(fileList){
        const files = Array.from(fileList || []).filter(Boolean);
        if (!files.length) return;

        const imgs = [...(state.draftImages || [])];
        for (const f of files){
          if (imgs.length >= IMG_LIMIT) break;
          try{ imgs.push(await readFileAsDataURL(f)); }catch{}
        }
        setDraftImages(imgs);
      }

      function removeDraftImage(i){
        const imgs = [...(state.draftImages || [])];
        imgs.splice(i, 1);
        setDraftImages(imgs);
      }

      function makeCover(i){
        const imgs = [...(state.draftImages || [])];
        if (i <= 0 || i >= imgs.length) return;
        const [x] = imgs.splice(i, 1);
        imgs.unshift(x);
        setDraftImages(imgs);
      }

      async function onPublish(e){
        e.preventDefault();

        const fd = new FormData(form);
        const owner = String(fd.get("owner") || state.tab || "item");
        const category = String(fd.get("category") || "другое").trim() || "другое";
        const name = String(fd.get("name") || "").trim();
        const desc = String(fd.get("desc") || "").trim();
        const priceBYN = Number(String(fd.get("price") || "0").replace(",", "."));
        const stockRaw = String(fd.get("stock") || "in").trim().toLowerCase();
        const inStock = (stockRaw !== "soldout" && stockRaw !== "sold out" && stockRaw !== "out");

        const isSet = isSetCat(category);
        const setItems = isSet
          ? Array.from(form.querySelectorAll('input[name="setItems"]:checked')).map(x => String(x.value || "").trim()).filter(Boolean)
          : [];

        if (isSet){
          if (!setItems.length){
            await uiAlert({ title: "SET пуст", text: "Выбери хотя бы одну вещь, которая входит в set.", okText: "ok" });
            return;
          }
        } else {
          if (!name || !Number.isFinite(priceBYN) || priceBYN <= 0){
            await uiAlert({ title: "Проверь данные", text: "Заполни название и цену (числом).", okText: "ok" });
            return;
          }
        }

        const nameFinal = isSet ? "set" : name;
        const priceFinal = isSet ? 0 : priceBYN;
        const descFinal = isSet ? "" : desc;
        const inStockFinal = isSet ? true : inStock;

        // urls (comma/newline separated) — if user typed urls and didn't press "add urls", we still take them
        const urlsRaw = String(fd.get("imageUrls") || "");
        const urlImages = urlsRaw
          ? urlsRaw.split(/[,\n]+/).map(s => s.trim()).filter(Boolean)
          : [];

        // final images = (files added via manager) + urls
        const images = uniqImages([...(state.draftImages || []), ...urlImages]); // capped in uniqImages

        // safety cap

        const editId = String(fd.get("id") || "").trim(); // only hidden field decides edit/create

        const isEdit = !!editId;
        if (isEdit){
          const idx = state.products.findIndex(x => x.id === editId);
          const prev = idx >= 0 ? state.products[idx] : null;

          // In edit mode we take the current image manager state as the source of truth (can be empty if user удалил всё)
          const finalImages = images;
          const updated = normalizeProduct({
            id: prev?.id || editId,
            owner: owner === "guests" ? "guests" : "item",
            category,
            name: nameFinal,
            priceBYN: priceFinal,
            type: isSet ? "set" : "product",
            isSet,
            setItems,
            images: finalImages,
            image: finalImages[0] || "",
            desc: descFinal,
            inStock: inStockFinal,
            createdAt: prev?.createdAt || Date.now()
          });

          if (idx >= 0) state.products[idx] = updated;
          else state.products.unshift(updated);

          persist();

          // reset editor completely (prevents "stuck edit mode" bugs)
          try{ form?.reset(); }catch{}
          if (imageUrlsInput) imageUrlsInput.value = "";
          setDraftImages([]);
          state.editProductId = null;
          if (ownerHidden) ownerHidden.value = state.tab;
          openAdminModal(false);
          updateDeleteButton();

          render();
          openProductModal(updated.id);
          return;
        }

        const product = normalizeProduct({
          id: uid(),
          owner: owner === "guests" ? "guests" : "item",
          category,
          name: nameFinal,
          priceBYN: priceFinal,
          type: isSet ? "set" : "product",
          isSet,
          setItems,
          images,
          image: images[0] || "",
          desc: descFinal,
          inStock: inStockFinal,
          createdAt: Date.now()
        });

        // ensure array (defensive)
        if (!Array.isArray(state.products)) state.products = [];

        state.products.unshift(product);
        persist();

        // hard reset to "create" after publishing (prevents accidental edits instead of new cards)
        state.editProductId = null;

        try{ form?.reset(); }catch{}
        if (imageUrlsInput) imageUrlsInput.value = "";
        setDraftImages([]);
        if (ownerHidden) ownerHidden.value = state.tab;
        openAdminModal(false);
        updateDeleteButton();

        render();
        openProductModal(product.id);
      }

      async function saveDbToFile(){
        const json = JSON.stringify(state.products, null, 2);

        try{
          if (window.showSaveFilePicker){
            const handle = await window.showSaveFilePicker({
              suggestedName: "item-manufacture.db.json",
              types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
            });
            const writable = await handle.createWritable();
            await writable.write(json);
            await writable.close();
            uiToast("DB сохранена в файл.");
            return;
          }
        }catch{
          // fallback below
        }

        const blob = new Blob([json], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "item-manufacture.db.json";
        a.click();
        URL.revokeObjectURL(a.href);
        uiAlert({ title: "Готово", text: "DB скачана. Положи файл в assets/js/ и замени старый.", okText: "ok" });
      }

      function exportDb(){
        const blob = new Blob([JSON.stringify(state.products, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "item-manufacture.db.json";
        a.click();
        URL.revokeObjectURL(a.href);
      }

      async function importDb(file){
        const txt = await file.text();
        const data = JSON.parse(txt);
        if (!Array.isArray(data)) throw new Error("bad db");
        state.products = data.map(normalizeProduct);
        closeProductModal();
        persist();
        render();
        uiToast("DB импортирована.");
      }

      function deleteProductById(id){
        if (!id) return false;

        // remove from products
        const before = state.products.length;
        state.products = state.products.filter(p => p.id !== id);

        // remove from cart too (so totals/count don't break)
        state.cart = state.cart.filter(it => it.id !== id);

        // close product modal if it was open for this product
        if (state.openProductId === id) closeProductModal();

        persist();
        render();
        renderCart();
        return state.products.length !== before;
      }

      function updateDeleteButton(){
        if (!deleteCardBtn) return;
        const isEdit = !!((clothIdHidden?.value || "").trim());
        deleteCardBtn.disabled = !isEdit;
        deleteCardBtn.textContent = isEdit ? "delete" : "delete";
        deleteCardBtn.title = isEdit ? "Удалить эту карточку" : "Удаление доступно только в режиме редактирования";
      }



      // ===== SET category (special) =====
      function getSetCandidates(owner){
        // show only non-set products, same owner scope
        return (state.products || [])
          .filter(p => p && p.owner === owner)
          .filter(p => !isSetProduct(p));
      }

      function renderSetPicker(owner, selectedIds = []){
        if (!setPickerList) return;
        const sel = new Set((selectedIds || []).map(String));
        const list = getSetCandidates(owner);

        if (!list.length){
          setPickerList.innerHTML = `<div class="helper">Пока нет товаров, которые можно собрать в set. Сначала создай обычные карточки.</div>`;
          return;
        }

        setPickerList.innerHTML = list.map(p => {
          const cover = (p.images && p.images[0]) ? p.images[0] : "";
          const img = cover
            ? `<img src="${esc(cover)}" alt="${esc(p.name)}">`
            : `<div class="placeholder" style="font-size:10px; letter-spacing:3px; text-transform:uppercase; color:rgba(0,0,0,.45);">image</div>`;
          const checked = sel.has(p.id) ? "checked" : "";

          return `
            <label class="settile" data-id="${esc(p.id)}">
              <div class="settile__img">${img}</div>
              <div class="settile__body">
                <div class="settile__name">${esc(p.name || "item")}</div>
                <div class="settile__meta">${esc(p.category || "—")}</div>
                <div class="settile__check">
                  <input type="checkbox" name="setItems" value="${esc(p.id)}" ${checked}>
                  <span>include</span>
                </div>
              </div>
            </label>
          `;
        }).join("");
      }

      function applySetMode(){
        if (!form) return;
        const cat = String(catSelect?.value || form.querySelector('[name="category"]')?.value || "");
        const on = isSetCat(cat);
        form.classList.toggle("is-set-mode", on);

        const owner = String(ownerHidden?.value || state.tab || "item");
        if (on){
          const selected = Array.from(form.querySelectorAll('input[name="setItems"]:checked')).map(x => x.value);
          renderSetPicker(owner, selected);
        }
      }

      function render(){
        renderGrid();
        renderCart();
        renderStats();
        animateGrid();
        if (currencySelect) currencySelect.value = state.currency;
      }

      // ===== Product modal (details) =====
      function openProductModal(id){
        const p = state.products.find(x => x.id === id);
        if (!p || !pModal) return;

        state.openProductId = id;
        state.galleryIndex = 0;

        pName.textContent = p.name || "product";
        pMeta.textContent = `${p.owner} · ${p.category || "—"}`;
        const isSet = isSetProduct(p);

        // Price: hidden when sold out OR when it's a SET
        if (pPrice){
          if (isSet || p.inStock === false){
            pPrice.textContent = "";
            pPrice.style.display = "none";
          } else {
            pPrice.style.display = "";
            pPrice.textContent = money(p.priceBYN);
          }
        }
        pCategory.textContent = p.category || "—";
        pDesc.textContent = isSet ? "" : (p.desc || "");
        if (pDesc) pDesc.style.display = isSet ? "none" : "";

                // SET block
        if (pSetBlock && pSetGrid){
          if (isSet){
            const ids = Array.isArray(p.setItems) ? p.setItems : [];
            const items = ids.map(id => state.products.find(x => x.id === id)).filter(Boolean);

            pSetGrid.innerHTML = items.map(it => {
              const cover = (it.images && it.images[0]) ? it.images[0] : "";
              const img = cover
                ? `<img src="${esc(cover)}" alt="${esc(it.name)}">`
                : `<div class="placeholder" style="font-size:10px; letter-spacing:3px; text-transform:uppercase; color:rgba(0,0,0,.45);">image</div>`;

              return `
                <div class="pset__item" data-open="${esc(it.id)}" role="button" tabindex="0" aria-label="Open ${esc(it.name)}">
                  ${img}
                  <div class="t">${esc(it.name || "item")}</div>
                </div>
              `;
            }).join("");

            pSetBlock.style.display = "";
          } else {
            pSetBlock.style.display = "none";
            pSetGrid.innerHTML = "";
          }
        }
        // stock UI (sets are not directly purchasable here)
        if (isSet){
          if (pAdd) pAdd.style.display = "none";
          if (pSold) pSold.style.display = "none";
        } else if (p.inStock === false){
          if (pAdd) pAdd.style.display = "none";
          if (pSold) pSold.style.display = "inline-flex";
        } else {
          if (pSold) pSold.style.display = "none";
          if (pAdd) pAdd.style.display = "";
        }

        if (pAdd){
          pAdd.disabled = false;
          pAdd.dataset.busy = "false";
          pAdd.classList.remove("btn--added");
          pAdd.textContent = "add to cart";
        }

        // thumbs + main
        const imgs = (p.images && p.images.length) ? p.images : [];
        pThumbs.innerHTML = imgs.map((src, i) => `
          <button class="thumb" type="button" data-i="${i}" data-active="${i===0 ? "true" : "false"}" aria-label="image ${i+1}">
            <img src="${esc(src)}" alt="${esc(p.name)} ${i+1}">
          </button>
        `).join("");

        setMainImage(0);

        pModal.dataset.open = "true";
        pModal.setAttribute("aria-hidden", "false");
        document.body.classList.add("modal-lock");
      }

      function closeProductModal(){
        if (!pModal) return;
        state.openProductId = null;
        state.galleryIndex = 0;
        pModal.dataset.open = "false";
        pModal.setAttribute("aria-hidden", "true");
        document.body.classList.remove("modal-lock");
      }

      function setMainImage(i){
        const p = state.products.find(x => x.id === state.openProductId);
        if (!p) return;

        const imgs = (p.images && p.images.length) ? p.images : [];
        const idx = Math.max(0, Math.min(i, Math.max(0, imgs.length - 1)));
        state.galleryIndex = idx;

        if (!imgs.length){
          pMainWrap.innerHTML = `<div class="placeholder">image</div>`;
          pThumbs.innerHTML = "";
          return;
        }

        pMainWrap.innerHTML = `<img src="${esc(imgs[idx])}" alt="${esc(p.name)}">`;
        $$(".thumb", pThumbs).forEach(t => t.dataset.active = (Number(t.dataset.i) === idx) ? "true" : "false");
      }

      // ===== Events wiring =====
      tabButtons.forEach(b => b.addEventListener("click", () => setTab(b.dataset.tab)));
      goSocial?.addEventListener("click", () => { location.href = "item-manufacture-social.html"; });
      chipButtons.forEach(c => c.addEventListener("click", () => setSection(c.dataset.cat)));

      searchInput?.addEventListener("input", (e) => {
        state.query = e.target.value || "";
        closeProductModal();
        render();
      });

      currencySelect?.addEventListener("change", (e) => {
        state.currency = e.target.value;
        persist();
        render();
      });

      cartOpen?.addEventListener("click", () => openCart(true, { pulse: true }));
      cartClose?.addEventListener("click", () => openCart(false));

      cart?.addEventListener("click", (e) => {
        const btn = e.target.closest(".qtybtn");
        if (!btn) return;
        const row = e.target.closest(".cart-item");
        if (!row) return;
        adjustQty(row.dataset.id, btn.dataset.q === "inc" ? 1 : -1);
      });

      // Card click -> open modal
      function tryOpenFromEvent(e){
        const card = e.target.closest(".card.card--shop");
        if (!card) return;
        const id = card.dataset.id;
        openProductModal(id);
      }
      grid?.addEventListener("click", tryOpenFromEvent);

      // keyboard open on Enter/Space
      grid?.addEventListener("keydown", (e) => {
        const card = e.target.closest(".card.card--shop");
        if (!card) return;
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          openProductModal(card.dataset.id);
        }
      });

      // product modal events
      pClose?.addEventListener("click", closeProductModal);
      pEdit?.addEventListener("click", () => {
        const id = state.openProductId;
        if (!id) return;
        closeProductModal();
        openEditorForProduct(id);
      });
      pClose2?.addEventListener("click", closeProductModal);
      pModal?.addEventListener("click", (e) => { if (e.target === pModal) closeProductModal(); });

      pThumbs?.addEventListener("click", (e) => {
        const t = e.target.closest(".thumb");
        if (!t) return;
        setMainImage(Number(t.dataset.i));
      });

      // SET items click -> open referenced product
      pSetGrid?.addEventListener("click", (e) => {
        const it = e.target.closest(".pset__item");
        if (!it) return;
        const openId = String(it.dataset.open || "");
        if (!openId) return;
        openProductModal(openId);
      });

      pSetGrid?.addEventListener("keydown", (e) => {
        const it = e.target.closest(".pset__item");
        if (!it) return;
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          const openId = String(it.dataset.open || "");
          if (!openId) return;
          openProductModal(openId);
        }
      });

      pAdd?.addEventListener("click", () => {
  const id = state.openProductId;
  if (!id) return;

  const p = state.products.find(x => x.id === id);
  if (p && p.inStock === false){
    uiToast("archived");
    return;
  }

  if (pAdd.dataset.busy === "true") return;
  pAdd.dataset.busy = "true";

  // confirm click (subtle)
  pAdd.classList.add("btn--added");
  pAdd.textContent = "added ✓";
  pAdd.disabled = true;

  addToCart(id);

  // close product modal, then open cart panel
  closeProductModal();
  setTimeout(() => openCart(true, { pulse: true }), 160);

  // reset button for the next open (openProductModal also resets)
  setTimeout(() => {
    pAdd.disabled = false;
    pAdd.dataset.busy = "false";
    pAdd.classList.remove("btn--added");
    pAdd.textContent = "add to cart";
  }, 650);
});

      // Escape + arrows for gallery
      document.addEventListener("keydown", (e) => {
        if (pModal?.dataset.open !== "true") return;
        if (e.key === "Escape") closeProductModal();
        if (e.key === "ArrowLeft") setMainImage(state.galleryIndex - 1);
        if (e.key === "ArrowRight") setMainImage(state.galleryIndex + 1);
      });

      // admin modal
            addClothBtn?.addEventListener("click", () => {
        if (state.tab === "home") return;
        resetAdminModal();
        if (ownerHidden) ownerHidden.value = state.tab;
        openAdminModal(true);
      });

      saveDbBtn?.addEventListener("click", saveDbToFile);

      modalClose?.addEventListener("click", () => { openAdminModal(false); resetAdminModal(); });
      modal?.addEventListener("click", (e) => { if (e.target === modal) { openAdminModal(false); resetAdminModal(); } });

      form?.addEventListener("submit", onPublish);
      catSelect?.addEventListener("change", applySetMode);

      // image manager events
      imgBrowseBtn?.addEventListener("click", () => imgFileInput?.click());

      imgFileInput?.addEventListener("change", async (e) => {
        const files = e.target.files ? Array.from(e.target.files) : [];
        await addFilesToDraft(files);
        // allow selecting the same file again later
        e.target.value = "";
      });

      imgClearBtn?.addEventListener("click", () => setDraftImages([]));

      addUrlsBtn?.addEventListener("click", () => {
        addUrlsToDraft(imageUrlsInput?.value || "");
        if (imageUrlsInput) imageUrlsInput.value = "";
      });

      imgPreviewGrid?.addEventListener("click", (e) => {
        const rem = e.target.closest(".imgtile__remove");
        if (rem){
          removeDraftImage(Number(rem.dataset.remove));
          return;
        }
        const tile = e.target.closest(".imgtile");
        if (!tile) return;
        makeCover(Number(tile.dataset.i));
      });

      imgPreviewGrid?.addEventListener("keydown", (e) => {
        const tile = e.target.closest(".imgtile");
        if (!tile) return;
        if (e.key === "Enter" || e.key === " "){
          e.preventDefault();
          makeCover(Number(tile.dataset.i));
        }
      });

      exportDbBtn?.addEventListener("click", exportDb);
      importDbInput?.addEventListener("change", async (e) => {
        const f = e.target.files?.[0];
        if (!f) return;
        try{ await importDb(f); }catch{ await uiAlert({ title: "Ошибка", text: "Ошибка импорта.", okText: "ok" }); }
        importDbInput.value = "";
      });
      
      deleteCardBtn?.addEventListener("click", async () => {
        const id = String(clothIdHidden?.value || "").trim();
        if (!id) return;
        const p = state.products.find(x => x.id === id);
        const name = p?.name ? `“${p.name}”` : "эту карточку";

        const yes = await uiConfirm({
          title: "delete",
          text: `Удалить ${name}? Это действие нельзя отменить.`,
          okText: "delete",
          cancelText: "cancel"
        });
        if (!yes) return;

        const ok = deleteProductById(id);
        // close editor either way
        openAdminModal(false);
        resetAdminModal();

        if (ok) uiToast("Карточка удалена.");
      });

      goItem?.addEventListener("click", () => setTab("item"));
      goGuests?.addEventListener("click", () => setTab("guests"));

      // ===== init =====
      state.cart = loadJSON(KEY_CART, []);
      state.currency = loadJSON(KEY_CURRENCY, "BYN") || "BYN";

      // set initial UI immediately (don’t wait for DB), and never override user's tab choice
      setTab("home", { force: true, silent: true, init: true });

      (async () => {
        try{
          state.products = await loadProducts();
        } finally {
          state.loadingProducts = false;
          // refresh UI for the current tab (no forced jump back to "data")
          render();
          requestAnimationFrame(() => { booted = true; });
        }
      })();

      })();

/* =========================
  NAV: remember where item-user was opened from
  - Writes several keys for compatibility
  - Also navigates with ?from=<page>&returnTo=<page>
  ========================= */
(() => {
  const from = (location.pathname.split("/").pop() || "index.html");

  const RETURN_KEYS = [
    "itemkey.user.returnTo",
    "itemkey.lastPage",
    "itemkey.returnTo",
    "itemkey.prevPage",
    "itemkey.nav.return",
    "itemkey.user.from"
  ];

  const setAll = (v) => {
    try{
      RETURN_KEYS.forEach(k => localStorage.setItem(k, v));
      sessionStorage.setItem("itemkey.user.returnTo", v);
    }catch{}
  };

  // store on load too (so item-user can read even if user typed URL manually)
  setAll(from);

  const userLink = document.querySelector('a.toplink[href^="item-user.html"]');
  if (!userLink) return;

  userLink.addEventListener("click", (e) => {
    e.preventDefault();
    setAll(from);

    const url = new URL(userLink.getAttribute("href") || "item-user.html", location.href);
    url.searchParams.set("from", from);
    url.searchParams.set("returnTo", from);

    // navigate (keep filename only, like the rest of the site)
    location.href = url.pathname.split("/").pop() + "?" + url.searchParams.toString() + url.hash;
  });
})();

/* =========================
      ITEM-USER HEADER LABEL
      показывает @login когда пользователь вошёл
      ========================= */
    (() => {
      const CURRENT_KEY = "itemkey.currentUser";
      let current = null;
      try { current = JSON.parse(localStorage.getItem(CURRENT_KEY) || "null"); } catch { current = null; }

      const userLink = document.querySelector('a.toplink[href^="item-user.html"]');
      if (!userLink) return;

      const tag = userLink.querySelector(".tag");
      if (!tag) return;

      if (current && current.name) {
        tag.textContent = `item-user · @${current.name}`;
        userLink.setAttribute("aria-label", `Item User ${current.name}`);
      } else {
        tag.textContent = "item-user";
        userLink.setAttribute("aria-label", "Item User");
      }
    })();
  </script>

<script>
/* =========================
  HOME (дом) :: GLITCH CONSOLE (full-bleed)
  - interactive menu like software console
  - click OR arrow keys + Enter (also 0/1)
  - philosophy stream: typed chunks + pixel-disintegrate between chunks
  - fast-forward: click the text line OR Space/Enter
  - kill: [kill] line + K key + Esc
  ========================= */
(() => {
  if (!document.body.classList.contains("page-manufacture")) return;

  const homePanel = document.getElementById("homePanel");
  const linesEl = document.getElementById("consoleLines");
  const surface = document.getElementById("consoleSurface");
  const statusEl = document.getElementById("consoleStatus");
  const helpEl = document.getElementById("consoleHelp");
  const canvas = document.getElementById("homeConsoleFx");

  if (!homePanel || !linesEl || !surface || !canvas) return;

  const prefersReduced = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  const TEXT_MOTHER = `item-manufacture - главенствующий отсек в системе item_key. Начал своё существование в 2008, в момент, когда на свет взошел организм. С этого дня он делает простую, грязно-важную работу: показывает прекрасие первозданного уродства.

[абзац]
Одежда в архиве - чистая мануфактура, без фабричного вмешательства. Потому что crafter’у противны бездушные фабрики: там вещь рождается без матери, без имени, без крови - как пустой объект, как ошибка тиража.

[абзац]
Здесь так нельзя. Каждая вещь обязана иметь начало истории. Зародителя. Того, кто вложит в неё себя: мысль / идею / кровь / любовь, ту самую, что появилась вместе с ним же на свет. Вещь несёт бремя продолжения рода человеческого: вещь-бессмертная, вещь-служитель, вещь-свидетель времени организма. Фабрика ломает этот цикл - создаёт бессмысленное “что-то”. Поэтому мы изолируемся. Поэтому каждая вещь - уникальна: нет повторяемых образцов, каждый новый объект существует в едином экземпляре, как шрам — не дизайн, а след.

[абзац]
Жуткий внешний вид ломает общий вид толпы. Он не просит быть принятым - он врезается. Навсегда презренный обществом, он цепляет каждый взгляд своим уродством: взгляд спотыкается, морщится, возвращается. 

[абзац]
Важная часть одежды - эксперименты с материалами и структурой шитья: перекосы, напряжения, стыки, странные ткани, неправильные решения, которые становятся правильными только после принятия себя как урода. Экстраординарный подход заставляет «людей» кривить свои рожи и менять свои «изящные» мысли на одно: вещь / item, прошедшую рядом и оставившую след в воздухе.

[абзац]
Вещи создаются идеей, которую не отверг не-здравомыслящий человеческий мозг. Это результат импульса, уважаемого зародителем. Он приходит, чтобы превратить твой гардероб в морг: место, где висят экспонаты-трупы. 

[абзац]
Вы никогда не узнаете личности экспонатов, на которых размещены вещи. Потому что уродство одежды поглощает внешнее уродство организмов, перекрывает весь передний план картины. Лицо становится фоном. Тело - подложкой. Остаётся главное: предмет, который живёт дольше хозяина, который не спросит разрешения общества на ношение. Предмет, который не хочет нравиться.
Предмет, который существует.`;

  const TEXT_CRAFTER = `Item_crafter - организм. Обитатель свалки. Слушает музыку, которую общество выносит как мусор. Его образ жизни не вписывается, не объясняется, не оправдывается. Его не “понимают” - его отвергают. И он отвечает тем же: не вежливостью, а присутствием.

[абзац]
Он - главный фрик среди знакомых. И главное в нём не эпатаж, а честность: он тот, кто есть, и не делает ремонт своей сущности ради чужих глаз. Он устал от повседневных нормалей - этих тихих правил, которые душат, пока ты улыбаешься. Ломать нормаль жуткими образами, поднятыми с “трупов”. 

[абзац]
Выверни наизнанку всё, что возможно. Круши. Рви. Не чини.
Чинить - значит признать, что оно было сломано, но оно изначально было гнилым.
Для него комплимент - когда кто-то шепчет сквозь зубы: “уродливо… плохо выглядит, ужас”. Вещь прошла мимо и оставила ожог на их “изящных” мыслях. Внутри него уродливая душа, которая не хочет быть приличной - она хочет вылезти наружу, покорёжить воздух, заставить пространство морщиться.

[абзац]
Все его близкие - уроды по-своему. Каждый - отдельная поломка, которую не нужно исправлять. Все «нормальные» были антиоживлены из его жизни”вбелыйшум. уродство_прекрасно-имея_медиатор.

[абзац]
Он - прямой представитель искусства: не “творческий человек”, а организм, который утонул в искусстве и не всплыл. Его возбуждает кривизна, беспорядок, жуть, уродство - не как фигура, а как правда формы. Он уважает свои идеи как первозданный объект и ни за что не антиоживит их даже под натиском левого полушария // «_друзья»`;
const MENU1 = [
    { value: 0, label: "item-manufacture_как_мать_зародитель" },
    { value: 1, label: "item_crafter_как_урод" },
];

  const GLITCH_ALPH = "█▓▒░#%@*/\\|_-+=<>[]{}()!?;:,.~^";

  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function splitSentences(text){
    const parts = text
      .split(/\n+/)
      .map(p => p.trim())
      .filter(Boolean)
      .flatMap(p => (p.match(/[^.!?…]+[.!?…]+|[^.!?…]+$/g) || []).map(s => s.trim()).filter(Boolean));
    return parts;
  }

  function buildChunks(text){
    const raw = String(text || "");

    // paragraph-aware mode:
    // - supports explicit marker "[абзац]"
    // - supports blank lines between paragraphs
    const normalized = raw.replace(/\[абзац\]/gi, "\n\n");

    const paras = normalized
      .split(/\n\s*\n+/)
      .map(p => p.trim())
      .filter(Boolean);

    // If author supplied paragraphs — stream exactly by them
    if (paras.length >= 2) return paras;

    // fallback: smart sentence packing (old behaviour)
    const sents = splitSentences(normalized);
    const target = 260;
    const minLen = 170;
    const maxLen = 380;

    const chunks = [];
    let cur = "";

    for (const s of sents){
      if (!cur){ cur = s; continue; }
      const candidate = (cur + " " + s).trim();

      if (candidate.length > maxLen && cur.length >= minLen){
        chunks.push(cur);
        cur = s;
      } else if (candidate.length >= target && cur.length >= minLen){
        if (candidate.length > maxLen - 18 || Math.random() < 0.55){
          chunks.push(candidate);
          cur = "";
        } else {
          cur = candidate;
        }
      } else {
        cur = candidate;
      }
    }
    if (cur) chunks.push(cur);

    if (chunks.length >= 2 && chunks[chunks.length-1].length < 70){
      chunks[chunks.length-2] = (chunks[chunks.length-2] + " " + chunks[chunks.length-1]).trim();
      chunks.pop();
    }
    return chunks;
  }

  function makeLine(text, cls = "", opt = null){
    const div = document.createElement("div");
    div.className = `cline ${cls}`.trim();
    div.textContent = text;
    div.classList.add("gtext");
    div.dataset.text = text;
    if (opt !== null){
      div.classList.add("option");
      div.dataset.option = String(opt);
      div.setAttribute("role", "option");
      div.tabIndex = -1;
    }
    return div;
  }

  function clearLines(){ linesEl.innerHTML = ""; }

  function animKick(level=0.35){
    if (!prefersReduced) homeFx.burst(level);
    homePanel.classList.remove("home--anim");
    void homePanel.offsetWidth;
    homePanel.classList.add("home--anim");
    setTimeout(()=>homePanel.classList.remove("home--anim"), 260);
  }

  function glitchBurst(level = 0.5){
    if (prefersReduced) return;
    homeFx.burst(level);

    const nodes = Array.from(linesEl.querySelectorAll(".cline")).slice(0, 10);
    const picks = nodes.filter(()=>Math.random() < 0.45);
    const originals = new Map();

    picks.forEach(el=>{
      const s = el.textContent || "";
      originals.set(el, s);
      const n = Math.max(1, Math.floor(s.length * (0.04 + 0.08*level)));
      const arr = s.split("");
      for(let i=0;i<n;i++){
        const p = randInt(0, Math.max(0, arr.length-1));
        if(arr[p] === " ") continue;
        arr[p] = GLITCH_ALPH[randInt(0, GLITCH_ALPH.length-1)];
      }
      const out = arr.join("");
      el.textContent = out;
      el.dataset.text = out;
    });

    setTimeout(()=>{
      originals.forEach((s, el)=>{
        el.textContent = s;
        el.dataset.text = s;
      });
    }, 90 + level*90);
  }

  let screen = "menu1";     // menu1 | menu2 | philo
  let selected = 0;
  let lastPick = 0;
  let stopStream = null;

  function setSelected(idx){
    selected = idx;
    const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
    opts.forEach((el,i)=> el.classList.toggle("is-selected", i === selected));
  }

  // Hover should behave like keyboard selection: only one marker at a time.
  // We update the same `selected` index on mouse move/over, so the marker
  // leaves the previous item and appears on the hovered one.
  linesEl.addEventListener("mousemove", (e) => {
    const opt = e.target.closest(".cline.option");
    if (!opt || !linesEl.contains(opt)) return;
    const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
    const idx = opts.indexOf(opt);
    if (idx >= 0 && idx !== selected){
      setSelected(idx);
    }
  }, { passive: true });

  linesEl.addEventListener("mouseover", (e) => {
    const opt = e.target.closest(".cline.option");
    if (!opt || !linesEl.contains(opt)) return;
    const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
    const idx = opts.indexOf(opt);
    if (idx >= 0 && idx !== selected){
      setSelected(idx);
    }
  }, { passive: true });

  function renderMenu1(){
    if (typeof stopStream === "function") stopStream();
    stopStream = null;

    screen = "menu1";
    if (helpEl) helpEl.textContent = "";
    statusEl.textContent = "v0.0.0.1: Digitization Protocol";

    clearLines();
    linesEl.append(
      // makeLine("cell: item-manufacture", "dim"),
      // makeLine(".........................................", "sep"),
      makeLine("[выбери настройку для осознать]", "dim"),
    );

    MENU1.forEach((o)=> linesEl.append(makeLine(`[${o.value}] ${o.label}`, "", o.value)));

    setSelected(0);
    animKick(0.26);
  }

  function renderMenu2(){
    if (typeof stopStream === "function") stopStream();
    stopStream = null;

    screen = "menu2";
    if (helpEl) helpEl.textContent = "";
    statusEl.textContent = "confirm?";

    clearLines();
    linesEl.append(
      makeLine("меню2:", "dim"),
      makeLine(""),
      makeLine("закончить?", "dim"),
    );

    [{v:0,t:"[0] да"},{v:1,t:"[1] нет"}].forEach(o => linesEl.append(makeLine(o.t, "", o.v)));

    setSelected(0);
    animKick(0.32);
  }

  function goMenu1(){
    if (typeof stopStream === "function") stopStream();
    stopStream = null;
    renderMenu1();
  }

  function activateSelection(){
    if (screen === "menu1"){
      const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
      const picked = opts[selected] ? Number(opts[selected].dataset.option) : selected;

      // [2] social — jump to a separate page (not overlay)
      if (picked === 2){
        glitchBurst(0.26);
        location.href = "item-manufacture-social.html";
        return;
      }

      lastPick = picked;
      renderMenu2();
      return;
    }
    if (screen === "menu2"){
      if (selected === 0) renderMenu1();
      else renderPhilo(lastPick);
    }
  }

    function renderPhilo(which){
    if (typeof stopStream === "function") stopStream();
    stopStream = null;

    screen = "philo";
    if (helpEl) helpEl.textContent = ""; // no hint here
    clearLines();

    // menu header
    linesEl.append(makeLine("меню:", "dim"));
    MENU1.forEach(o => linesEl.append(makeLine(`[${o.value}] ${o.label}`, "dim")));

    linesEl.append(
      makeLine(""),
      makeLine(which === 0 ? ">> item-manufacture_как_мать_зародитель" : ">> item_crafter_как_урод", ""),
      makeLine(".........................................", "sep"),
    );
const typeLine = makeLine("", "type-line", null);
    linesEl.append(typeLine);

    const nextLine = makeLine("[next]", "", "next");
    linesEl.append(nextLine);

    const killLine = makeLine("[kill]", "", "kill");
    killLine.style.marginTop = "2px";
    linesEl.append(killLine);

    // default command selection: [next]
    setSelected(0);

    const cursor = document.createElement("span");
    cursor.className = "cursor";
    typeLine.appendChild(cursor);

    const chunks = buildChunks(which === 0 ? TEXT_MOTHER : TEXT_CRAFTER);
    const totalChunks = Math.max(1, chunks.length);
    const modeLabel = (which === 0) ? "mode: mother" : "mode: crafter";

    const setStream = (n, stateLabel = "") => {
      const a = String(n).padStart(2,"0");
      const b = String(totalChunks).padStart(2,"0");
      statusEl.textContent = `${modeLabel} · stream ${a}/${b}${stateLabel ? " · " + stateLabel : ""}`;
    };

    let alive = true;
    let idx = 0;

    // manual control
    let typing = false;
    let ready = false;
    let forceComplete = false;

    function setTypeText(s){
      const cur = typeLine.querySelector(".cursor");
      typeLine.textContent = s;
      typeLine.dataset.text = s;
      typeLine.classList.add("gtext");
      if (cur) typeLine.appendChild(cur);
    }

    function markReady(){
      nextLine.classList.toggle("is-ready", ready);
      nextLine.dataset.text = nextLine.textContent;
    }

    function disintegrate(current, done){
      if (prefersReduced){
        setTypeText("");
        done && done();
        return;
      }
      const frames = 11;
      let f = 0;
      const base = (current || "").split("");
      const tick = () => {
        if (!alive) return;
        f++;
        const p = f / frames;
        const out = base.map(ch => {
          if (ch === " ") return " ";
          if (Math.random() < p*0.86){
            return (Math.random() < p*0.35) ? " " : GLITCH_ALPH[randInt(0, GLITCH_ALPH.length-1)];
          }
          return ch;
        }).join("");
        setTypeText(out);
        homeFx.burst(0.10 + p*0.18);
        if (Math.random() < 0.20) glitchBurst(0.14);
        if (f < frames){
          setTimeout(tick, 26 + Math.random()*26);
        } else {
          setTypeText("");
          done && done();
        }
      };
      tick();
    }

    const baseSpeed = prefersReduced ? 26 : 42; // ms per char (faster)

    let typeTimer = null;
    let typeRun = 0;


    function typeChunk(chunk){
      if (!alive) return;

      const run = ++typeRun;
      if (typeTimer){ clearTimeout(typeTimer); typeTimer = null; }

      typing = true;
      ready = false;
      forceComplete = false;
      setStream(idx + 1, "typing");
      markReady();

      let p = 0;

      const step = () => {
        if (!alive) return;

        if (run !== typeRun) return;

        if (forceComplete){
          setTypeText(chunk);
          typeTimer = null;
          typing = false;
          ready = true;
          setStream(idx + 1, "ready");
          markReady();
          homeFx.burst(0.20);
          glitchBurst(0.10);
          return;
        }

        p++;
        setTypeText(chunk.slice(0, p));

        if (!prefersReduced && Math.random() < 0.10){
          homeFx.burst(0.10);
        }

        if (p < chunk.length){
          typeTimer = setTimeout(step, baseSpeed + Math.random()*22);
        } else {
          typing = false;
          typeTimer = null;
          ready = true;
          setStream(idx + 1, "ready");
          markReady();
          // tiny attention pulse on next
          if (!prefersReduced){
            glitchBurst(0.16);
            homeFx.burst(0.18);
          }
        }
      };

      step();
    }

    function goNext(){
      if (!alive) return;
      if (!chunks.length) return;

      if (typing){
        // skip typing immediately (no waiting for next timeout tick)
        typeRun++; // invalidate any pending step()
        if (typeTimer){ clearTimeout(typeTimer); typeTimer = null; }
        forceComplete = false;
        setTypeText(chunks[idx] || "");
        typing = false;
        ready = true;
        setStream(idx + 1, "ready");
        markReady();
        homeFx.burst(0.22);
        glitchBurst(0.12);
        return;
      }

      if (!ready) return;

      ready = false;
      markReady();
      setStream(idx + 1, "shift");

      const cur = typeLine.textContent || "";
      disintegrate(cur, () => {
        if (!alive) return;
        idx = (idx + 1) % chunks.length;
        setStream(idx + 1, "typing");
        setTimeout(() => typeChunk(chunks[idx]), 90);
      });
    }

    function goKill(){
      glitchBurst(0.34);
      goMenu1();
      surface.focus();
    }

    // interactions
    const onTypeClick = () => { if(!alive) return; goNext(); };
    const onKey = (ev) => {
      if (!alive) return;
      if (screen !== "philo") return;

      if (ev.key === "Escape"){
        ev.preventDefault();
        goKill();
        return;
      }

      // Navigate between [next] and [kill] like in menus
      if (ev.key === "ArrowUp" || ev.key === "ArrowDown" || ev.key === "ArrowLeft" || ev.key === "ArrowRight"){
        ev.preventDefault();
        const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
        if (!opts.length) return;
        const dir = (ev.key === "ArrowUp" || ev.key === "ArrowLeft") ? -1 : 1;
        selected = (selected + dir + opts.length) % opts.length;
        setSelected(selected);
        glitchBurst(0.14);
        return;
      }

      // Enter activates selected command
      if (ev.key === "Enter"){
        ev.preventDefault();
        const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
        const opt = opts[selected];
        const cmd = opt ? String(opt.dataset.option || "") : "next";
        if (cmd === "kill") goKill();
        else goNext();
        return;
      }

      // Quick keys: Space / N always act as NEXT (skip/advance)
      if (ev.key === "n" || ev.key === "N" || ev.key === " "){
        ev.preventDefault();
        goNext();
        return;
      }

      if (ev.key === "k" || ev.key === "K"){
        ev.preventDefault();
        goKill();
        return;
      }
    };

    typeLine.addEventListener("click", onTypeClick);
    
    const onCmdClick = (e) => {
      const opt = e.target.closest && e.target.closest(".cline.option");
      if (!opt) return;

      // keep keyboard marker consistent with mouse clicks
      const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
      const ix = opts.indexOf(opt);
      if (ix >= 0) setSelected(ix);

      const cmd = String(opt.dataset.option || "");
      if (cmd === "kill"){ goKill(); return; }
      if (cmd === "next"){ goNext(); return; }
    };
    linesEl.addEventListener("click", onCmdClick);

    surface.addEventListener("keydown", onKey);

    stopStream = () => {
      alive = false;
      typeRun++; // stop any pending typing
      if (typeTimer){ clearTimeout(typeTimer); typeTimer = null; }
      typeLine.removeEventListener("click", onTypeClick);
      linesEl.removeEventListener("click", onCmdClick);
      surface.removeEventListener("keydown", onKey);
      typing = false;
      ready = false;
      forceComplete = false;
    };

    // start
    setStream(1, "typing");
    markReady();
    if (chunks.length) typeChunk(chunks[0]);

    animKick(0.40);
  }
  // Click handling
  linesEl.addEventListener("click", (e) => {
    const opt = e.target.closest && e.target.closest(".cline.option");
    if (!opt) return;

    if (screen === "philo"){
      // handled by the philo controller (avoid double-trigger)
      return;
    }

    const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
    const idx = opts.indexOf(opt);
    if (idx >= 0){
      setSelected(idx);
      glitchBurst(0.22);
      activateSelection();
    }
  });

  // keyboard handling on surface
  surface.addEventListener("keydown", (e) => {
    if (homePanel.style.display === "none") return;

    if (e.key === "Escape"){
      e.preventDefault();
      goMenu1();
      return;
    }

    if (screen === "philo"){
      if (e.key === "k" || e.key === "K"){
        e.preventDefault();
        glitchBurst(0.35);
        goMenu1();
      }
      return;
    }

    const opts = Array.from(linesEl.querySelectorAll(".cline.option"));
    if (!opts.length) return;

    if (e.key === "ArrowUp" || e.key === "ArrowDown"){
      e.preventDefault();
      const dir = e.key === "ArrowUp" ? -1 : 1;
      selected = (selected + dir + opts.length) % opts.length;
      setSelected(selected);
      glitchBurst(0.14);
      return;
    }

    if (e.key === "Enter"){
      e.preventDefault();
      glitchBurst(0.26);
      activateSelection();
      return;
    }

    if (e.key === "0" || e.key === "1" || e.key === "2"){
      e.preventDefault();
      const v = Number(e.key);
      const idx = opts.findIndex(el => Number(el.dataset.option) === v);
      if (idx >= 0){
        setSelected(idx);
        glitchBurst(0.18);
        activateSelection();
      }
    }
  });

  homePanel.addEventListener("click", () => surface.focus(), { passive:true });

  // ---- Background FX (interactive, subtle; NO circles) ----
  const homeFx = (() => {
    const c = canvas;
    const ctx = c.getContext("2d", { alpha: true });

    let dpr = 1;
    let burstPow = 0;
    let px = 0.5, py = 0.5, tpx = 0.5, tpy = 0.5;

    function fit(){
      const r = homePanel.getBoundingClientRect();
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      c.width = Math.max(2, Math.floor(r.width * dpr));
      c.height = Math.max(2, Math.floor(r.height * dpr));
      c.style.width = r.width + "px";
      c.style.height = r.height + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function burst(v=0.4){
      burstPow = Math.max(burstPow, clamp(v,0,1));
    }

    function frame(now){
      const visible = homePanel.style.display !== "none";
      const w = c.width / dpr, h = c.height / dpr;
      const t = now / 1000;

      if (!visible){
        requestAnimationFrame(frame);
        return;
      }

      px += (tpx - px) * (prefersReduced ? 0.05 : 0.08);
      py += (tpy - py) * (prefersReduced ? 0.05 : 0.08);

      burstPow = Math.max(0, burstPow - 0.012);
      const intensity = prefersReduced ? 0.07 : clamp(0.09 + burstPow*0.55, 0, 1);

      ctx.clearRect(0,0,w,h);

      const cx = w*(0.5 + (px-0.5)*0.10);
      const cy = h*(0.5 + (py-0.5)*0.08);

      ctx.save();
      ctx.globalCompositeOperation = "multiply";
      ctx.globalAlpha = 0.06 + intensity*0.12;
      const grd = ctx.createRadialGradient(cx, cy, 30, cx, cy, Math.max(w,h)*0.75);
      grd.addColorStop(0, "rgba(0,0,0,0.00)");
      grd.addColorStop(1, "rgba(0,0,0,0.25)");
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = "multiply";
      ctx.globalAlpha = 0.08 + intensity*0.12;
      for(let y=0; y<h; y+=3){
        const a = (Math.sin(t*18 + y*0.14) + 1) * 0.5;
        ctx.fillStyle = `rgba(0,0,0,${0.020 + 0.020*a})`;
        ctx.fillRect(0, y, w, 1);
      }
      ctx.restore();

      if(!prefersReduced){
        ctx.save();
        ctx.globalAlpha = 0.05 + intensity*0.11;
        ctx.globalCompositeOperation = "multiply";
        const rows = 18;
        for(let r=0;r<rows;r++){
          const yy = Math.floor((r/rows)*h + (Math.sin(t*0.7+r)*2));
          for(let x=0; x<w; x+=6){
            if(Math.random() < 0.18){
              const a = 0.05 + Math.random()*0.10;
              ctx.fillStyle = `rgba(0,0,0,${a})`;
              ctx.fillRect(x + (Math.random()*3), yy, 1, 1);
            }
          }
        }
        ctx.restore();
      }

      if(!prefersReduced && Math.random() < (0.018 + intensity*0.06)){
        ctx.save();
        ctx.globalCompositeOperation = "multiply";
        ctx.globalAlpha = 0.10 + intensity*0.14;
        const yy = Math.random()*h;
        const hh = 6 + Math.random()*12;
        const dx = (Math.random()*2 - 1) * (16 + intensity*65);
        ctx.drawImage(c, 0, yy, w, hh, dx, yy, w, hh);
        ctx.restore();
      }

      requestAnimationFrame(frame);
    }

    window.addEventListener("mousemove", (e)=>{
      const r = homePanel.getBoundingClientRect();
      const x = (e.clientX - r.left) / Math.max(1, r.width);
      const y = (e.clientY - r.top) / Math.max(1, r.height);
      tpx = clamp(x, 0, 1);
      tpy = clamp(y, 0, 1);
    }, { passive:true });

    window.addEventListener("resize", () => fit(), { passive:true });

    const ro = new ResizeObserver(() => fit());
    ro.observe(homePanel);

    fit();
    requestAnimationFrame(frame);

    return { burst };
  })();

  renderMenu1();
  setTimeout(() => surface.focus(), 60);
})();
</script>

<script id="noScrollKeys">
(() => {
  // Prevent arrow keys/space from scrolling the page when using console
  document.addEventListener("keydown", (e) => {
    const keys = ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End"," "];
    if (!keys.includes(e.key)) return;

    // if an input is focused, don't interfere
    const t = e.target;
    const tag = t && t.tagName ? t.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select" || (t && t.isContentEditable)) return;

    const home = document.getElementById("homePanel");
    const surf = document.getElementById("consoleSurface");
    if (!home || !surf) return;

    // Only lock when HOME console exists on this page
    // (page is static anyway, but this guarantees no accidental scroll)
    e.preventDefault();
    // keep focus on the console so arrows always work
    if (document.activeElement !== surf) surf.focus();
  }, { capture: true });
})();
</script>

</body>
</html>
